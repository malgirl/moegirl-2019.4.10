{"parse":{"title":"\u6a21\u5757:TableTools","pageid":265312,"wikitext":{"*":"--[[\n------------------------------------------------------------------------------------\n--                               TableTools                                       --\n--                                                                                --\n-- This module includes a number of functions for dealing with Lua tables.        --\n-- It is a meta-module, meant to be called from other Lua modules, and should     --\n-- not be called directly from #invoke.                                           --\n------------------------------------------------------------------------------------\n--]]\n\nlocal libraryUtil = require('libraryUtil')\n\nlocal p = {}\n\n-- Define often-used variables and functions.\nlocal floor = math.floor\nlocal infinity = math.huge\nlocal checkType = libraryUtil.checkType\n\n--[[\n------------------------------------------------------------------------------------\n-- isPositiveInteger\n--\n-- This function returns true if the given value is a positive integer, and false\n-- if not. Although it doesn't operate on tables, it is included here as it is\n-- useful for determining whether a given table key is in the array part or the\n-- hash part of a table.\n------------------------------------------------------------------------------------\n--]]\nfunction p.isPositiveInteger(v)\n\tif type(v) == 'number' and v >= 1 and floor(v) == v and v < infinity then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend\n\n--[[\n------------------------------------------------------------------------------------\n-- isNan\n--\n-- This function returns true if the given number is a NaN value, and false\n-- if not. Although it doesn't operate on tables, it is included here as it is\n-- useful for determining whether a value can be a valid table key. Lua will\n-- generate an error if a NaN is used as a table key.\n------------------------------------------------------------------------------------\n--]]\nfunction p.isNan(v)\n\tif type(v) == 'number' and tostring(v) == '-nan' then\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend\n\n--[[\n------------------------------------------------------------------------------------\n-- shallowClone\n--\n-- This returns a clone of a table. The value returned is a new table, but all\n-- subtables and functions are shared. Metamethods are respected, but the returned\n-- table will have no metatable of its own.\n------------------------------------------------------------------------------------\n--]]\nfunction p.shallowClone(t)\n\tlocal ret = {}\n\tfor k, v in pairs(t) do\n\t\tret[k] = v\n\tend\n\treturn ret\nend\n\n--[[\n------------------------------------------------------------------------------------\n-- removeDuplicates\n--\n-- This removes duplicate values from an array. Non-positive-integer keys are\n-- ignored. The earliest value is kept, and all subsequent duplicate values are\n-- removed, but otherwise the array order is unchanged.\n------------------------------------------------------------------------------------\n--]]\nfunction p.removeDuplicates(t)\n\tcheckType('removeDuplicates', 1, t, 'table')\n\tlocal isNan = p.isNan\n\tlocal ret, exists = {}, {}\n\tfor i, v in ipairs(t) do\n\t\tif isNan(v) then\n\t\t\t-- NaNs can't be table keys, and they are also unique, so we don't need to check existence.\n\t\t\tret[#ret + 1] = v\n\t\telse\n\t\t\tif not exists[v] then\n\t\t\t\tret[#ret + 1] = v\n\t\t\t\texists[v] = true\n\t\t\tend\n\t\tend\t\n\tend\n\treturn ret\nend\t\t\t\n\n--[[\n------------------------------------------------------------------------------------\n-- numKeys\n--\n-- This takes a table and returns an array containing the numbers of any numerical\n-- keys that have non-nil values, sorted in numerical order.\n------------------------------------------------------------------------------------\n--]]\nfunction p.numKeys(t)\n\tcheckType('numKeys', 1, t, 'table')\n\tlocal isPositiveInteger = p.isPositiveInteger\n\tlocal nums = {}\n\tfor k, v in pairs(t) do\n\t\tif isPositiveInteger(k) then\n\t\t\tnums[#nums + 1] = k\n\t\tend\n\tend\n\ttable.sort(nums)\n\treturn nums\nend\n\n--[[\n------------------------------------------------------------------------------------\n-- affixNums\n--\n-- This takes a table and returns an array containing the numbers of keys with the\n-- specified prefix and suffix. For example, for the table\n-- {a1 = 'foo', a3 = 'bar', a6 = 'baz'} and the prefix \"a\", affixNums will\n-- return {1, 3, 6}.\n------------------------------------------------------------------------------------\n--]]\nfunction p.affixNums(t, prefix, suffix)\n\tcheckType('affixNums', 1, t, 'table')\n\tcheckType('affixNums', 2, prefix, 'string', true)\n\tcheckType('affixNums', 3, suffix, 'string', true)\n\n\tlocal function cleanPattern(s)\n\t\t-- Cleans a pattern so that the magic characters ()%.[]*+-?^$ are interpreted literally.\n\t\ts = s:gsub('([%(%)%%%.%[%]%*%+%-%?%^%$])', '%%%1')\n\t\treturn s\n\tend\n\n\tprefix = prefix or ''\n\tsuffix = suffix or ''\n\tprefix = cleanPattern(prefix)\n\tsuffix = cleanPattern(suffix)\n\tlocal pattern = '^' .. prefix .. '([1-9]%d*)' .. suffix .. '$'\n\n\tlocal nums = {}\n\tfor k, v in pairs(t) do\n\t\tif type(k) == 'string' then\t\t\t\n\t\t\tlocal num = mw.ustring.match(k, pattern)\n\t\t\tif num then\n\t\t\t\tnums[#nums + 1] = tonumber(num)\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(nums)\n\treturn nums\nend\n\n--[[\n------------------------------------------------------------------------------------\n-- numData\n--\n-- Given a table with keys like (\"foo1\", \"bar1\", \"foo2\", \"baz2\"), returns a table\n-- of subtables in the format \n-- { [1] = {foo = 'text', bar = 'text'}, [2] = {foo = 'text', baz = 'text'} }\n-- Keys that don't end with an integer are stored in a subtable named \"other\".\n-- The compress option compresses the table so that it can be iterated over with\n-- ipairs.\n------------------------------------------------------------------------------------\n--]]\nfunction p.numData(t, compress)\n\tcheckType('numData', 1, t, 'table')\n\tcheckType('numData', 2, compress, 'boolean', true)\n\tlocal ret = {}\n\tfor k, v in pairs(t) do\n\t\tlocal prefix, num = mw.ustring.match(tostring(k), '^([^0-9]*)([1-9][0-9]*)$')\n\t\tif num then\n\t\t\tnum = tonumber(num)\n\t\t\tlocal subtable = ret[num] or {}\n\t\t\tif prefix == '' then\n\t\t\t\t-- Positional parameters match the blank string; put them at the start of the subtable instead.\n\t\t\t\tprefix = 1\n\t\t\tend\n\t\t\tsubtable[prefix] = v\n\t\t\tret[num] = subtable\n\t\telse\n\t\t\tlocal subtable = ret.other or {}\n\t\t\tsubtable[k] = v\n\t\t\tret.other = subtable\n\t\tend\n\tend\n\tif compress then\n\t\tlocal other = ret.other\n\t\tret = p.compressSparseArray(ret)\n\t\tret.other = other\n\tend\n\treturn ret\nend\n\n--[[\n------------------------------------------------------------------------------------\n-- compressSparseArray\n--\n-- This takes an array with one or more nil values, and removes the nil values\n-- while preserving the order, so that the array can be safely traversed with\n-- ipairs.\n------------------------------------------------------------------------------------\n--]]\nfunction p.compressSparseArray(t)\n\tcheckType('compressSparseArray', 1, t, 'table')\n\tlocal ret = {}\n\tlocal nums = p.numKeys(t)\n\tfor _, num in ipairs(nums) do\n\t\tret[#ret + 1] = t[num]\n\tend\n\treturn ret\nend\n\n--[[\n------------------------------------------------------------------------------------\n-- sparseIpairs\n--\n-- This is an iterator for sparse arrays. It can be used like ipairs, but can\n-- handle nil values.\n------------------------------------------------------------------------------------\n--]]\nfunction p.sparseIpairs(t)\n\tcheckType('sparseIpairs', 1, t, 'table')\n\tlocal nums = p.numKeys(t)\n\tlocal i = 0\n\tlocal lim = #nums\n\treturn function ()\n\t\ti = i + 1\n\t\tif i <= lim then\n\t\t\tlocal key = nums[i]\n\t\t\treturn key, t[key]\n\t\telse\n\t\t\treturn nil, nil\n\t\tend\n\tend\nend\n\n--[[\n------------------------------------------------------------------------------------\n-- size\n--\n-- This returns the size of a key/value pair table. It will also work on arrays,\n-- but for arrays it is more efficient to use the # operator.\n------------------------------------------------------------------------------------\n--]]\nfunction p.size(t)\n\tcheckType('size', 1, t, 'table')\n\tlocal i = 0\n\tfor k in pairs(t) do\n\t\ti = i + 1\n\tend\n\treturn i\nend\n\nreturn p"}}}