{"parse":{"title":"\u6a21\u5757:String","pageid":144150,"wikitext":{"*":"--[[  \n\n\u5f15\u81ea\u7ef4\u57fa\u767e\u79d1\uff08enwiki:Module:String\uff0coldid=552254999\uff09\n\nThis module is intended to provide access to basic string functions.\n\nMost of the functions provided here can be invoked with named parameters, \nunnamed parameters, or a mixture.  If named parameters are used, Mediawiki will \nautomatically remove any leading or trailing whitespace from the parameter.  \nDepending on the intended use, it may be advantageous to either preserve or\nremove such whitespace.\n\nGlobal options\n    ignore_errors: If set to 'true' or 1, any error condition will result in \n        an empty string being returned rather than an error message.  \n        \n    error_category: If an error occurs, specifies the name of a category to \n        include with the error message.  The default category is  \n        [Category:Errors reported by Module String].\n        \n    no_category: If set to 'true' or 1, no category will be added if an error\n        is generated.\n        \nUnit tests for this module are available at Module:String/tests.\n----\n\u8be5\u6a21\u5757\u65e8\u5728\u63d0\u4f9b\u5bf9\u57fa\u672c\u5b57\u7b26\u4e32\u51fd\u6570\u7684\u8bbf\u95ee\u3002\n\n\u8fd9\u91cc\u63d0\u4f9b\u7684\u5927\u591a\u6570\u51fd\u6570\u90fd\u53ef\u4ee5\u7528\u547d\u540d\u53c2\u6570\u8c03\u7528\uff0c\n\u672a\u547d\u540d\u7684\u53c2\u6570\u6216\u6df7\u5408\u7740\u7528\u3002 \u5982\u679c\u4f7f\u7528\u547d\u540d\u53c2\u6570\uff0c\u5a92\u4f53\u7ef4\u57fa\u5c06\u4f1a\n\u4ece\u53c2\u6570\u4e2d\u81ea\u52a8\u5220\u9664\u4efb\u4f55\u524d\u90e8\u6216\u8005\u5c3e\u90e8\u7684\u7a7a\u683c\u7b26\u53f7\u3002\n\u53d6\u51b3\u4e8e\u9884\u671f\u7684\u7528\u9014\uff0c\u4fdd\u5b58\u6216\u53ef\u80fd\u662f\u6709\u5229\u7684\n\u5220\u9664\u8fd9\u6837\u7684\u7a7a\u767d\u3002\n\n\u5168\u5c40\u9009\u9879\n\u00a0\u00a0\u00a0\u00a0 ignore_errors\uff1a\u5982\u679c\u8bbe\u7f6e\u4e3a'true'\u62161\uff0c\u5219\u4f1a\u5bfc\u81f4\u4efb\u4f55\u9519\u8bef\u60c5\u51b5\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\u800c\u4e0d\u662f\u9519\u8bef\u6d88\u606f\u3002\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0 error_category\uff1a\u5982\u679c\u53d1\u751f\u9519\u8bef\uff0c\u8bf7\u6307\u5b9a\u8981\u5206\u7c7b\u7684\u540d\u79f0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u5305\u542b\u9519\u8bef\u6d88\u606f\u3002 \u9ed8\u8ba4\u5206\u7c7b\u662f\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 [Category:Errors reported by Module String]\u3002(\u7c7b\u522b\uff1a\u6a21\u5757\u5b57\u7b26\u4e32\u62a5\u544a\u7684\u9519\u8bef)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0 no_category\uff1a\u5982\u679c\u8bbe\u7f6e\u4e3a'true'\u62161\uff0c\u5982\u679c\u53d1\u751f\u9519\u8bef\uff0c\u5219\u4e0d\u4f1a\u6dfb\u52a0\u4efb\u4f55\u5206\u7c7b\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u751f\u6210\u3002\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u8fd9\u4e2a\u6a21\u5757\u7684\u6d4b\u8bd5\u5355\u5143\u53ef\u4ee5\u5728Module\uff1aString / tests\u4e0b\u627e\u5230\u3002\n]]\n\nlocal str = {}\n\n--[[\nlen\n\nThis function returns the length of the target string.\n\nUsage:\n{{#invoke:String|len|target_string|}}\nOR\n{{#invoke:String|len|s=target_string}}\n\nParameters\n    s: The string whose length to report\n\nIf invoked using named parameters, Mediawiki will automatically remove any leading or\ntrailing whitespace from the target string.  \n----\nLEN\n\n\u8be5\u51fd\u6570\u8fd4\u56de\u76ee\u6807\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002\n\n\u7528\u6cd5\uff1a\n{{#invoke:String|len|target_string|}}\n\u8981\u4e48\n{{#invoke:String|len|s=target_string}}\n\n\u53c2\u6570\n\u00a0\u00a0\u00a0\u00a0 s\uff1a\u8981\u62a5\u544a\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\n\n\u5982\u679c\u4f7f\u7528\u547d\u540d\u53c2\u6570\u8c03\u7528\uff0c\u5a92\u4f53\u7ef4\u57fa\u5c06\u81ea\u52a8\u5220\u9664\u4efb\u4f55\u524d\u90e8\u6216\n\u540e\u90e8\u76ee\u6807\u5b57\u7b26\u4e32\u7684\u7a7a\u683c\u3002\n]]\nfunction str.len( frame )\n    local new_args = str._getParameters( frame.args, {'s'} );\n    local s = new_args['s'] or '';\n    return mw.ustring.len( s )\nend\n\n--[[\nsub\n\nThis function returns a substring of the target string at specified indices.\n\nUsage:\n{{#invoke:String|sub|target_string|start_index|end_index}}\nOR\n{{#invoke:String|sub|s=target_string|i=start_index|j=end_index}}\n\nParameters\n    s: The string to return a subset of\n    i: The fist index of the substring to return, defaults to 1.\n    j: The last index of the string to return, defaults to the last character.\n    \nThe first character of the string is assigned an index of 1.  If either i or j\nis a negative value, it is interpreted the same as selecting a character by \ncounting from the end of the string.  Hence, a value of -1 is the same as \nselecting the last character of the string.\n\nIf the requested indices are out of range for the given string, an error is \nreported.\n----\n\u5b50\n\n\u8a72\u51fd\u6578\u8fd4\u56de\u6307\u5b9a\u7d22\u5f15\u8655\u76ee\u6a19\u5b57\u7b26\u4e32\u7684\u5b50\u5b57\u7b26\u4e32\u3002\n\n\u7528\u6cd5\uff1a\n{{#invoke\uff1a\u5b57\u7b26\u4e32|\u5206| target_string| START_INDEX| END_INDEX}}\n\u8981\u4e48\n{{#invoke\uff1a\u5b57\u7b26\u4e32|\u5b50| S= target_string| I= START_INDEX| J = END_INDEX}}\n\n\u53c3\u6578\n\u00a0\u00a0\u00a0\u00a0 s\uff1a\u8fd4\u56de\u4e00\u500b\u5b50\u96c6\u7684\u5b57\u7b26\u4e32\n\u00a0\u00a0\u00a0\u00a0 i\uff1a\u8981\u8fd4\u56de\u7684\u5b50\u5b57\u7b26\u4e32\u7684\u7b2c\u4e00\u500b\u7d22\u5f15\uff0c\u9ed8\u8a8d\u70ba1\u3002\n\u00a0\u00a0\u00a0\u00a0 j\uff1a\u8981\u8fd4\u56de\u7684\u5b57\u7b26\u4e32\u7684\u6700\u5f8c\u4e00\u500b\u7d22\u5f15\uff0c\u9ed8\u8a8d\u70ba\u6700\u5f8c\u4e00\u500b\u5b57\u7b26\u3002\n\u00a0\u00a0\u00a0\u00a0\n\u5b57\u7b26\u4e32\u7684\u7b2c\u4e00\u500b\u5b57\u7b26\u88ab\u5206\u914d\u7d22\u5f151.\u5982\u679ci\u6216j\n\u662f\u4e00\u500b\u8ca0\u503c\uff0c\u5b83\u88ab\u89e3\u91cb\u70ba\u8207\u901a\u904e\u9078\u64c7\u4e00\u500b\u5b57\u7b26\u76f8\u540c\n\u5f9e\u5b57\u7b26\u4e32\u7684\u672b\u5c3e\u958b\u59cb\u8a08\u6578\u3002 \u56e0\u6b64\uff0c-1\u7684\u503c\u82071\u76f8\u540c\n\u9078\u64c7\u5b57\u7b26\u4e32\u7684\u6700\u5f8c\u4e00\u500b\u5b57\u7b26\u3002\n\n\u5982\u679c\u8acb\u6c42\u7684\u7d22\u5f15\u8d85\u51fa\u7d66\u5b9a\u5b57\u7b26\u4e32\u7684\u7bc4\u570d\uff0c\u5247\u6703\u51fa\u73fe\u932f\u8aa4\n\u5831\u5c0e\u3002\n]]\nfunction str.sub( frame )\n    local new_args = str._getParameters( frame.args, { 's', 'i', 'j' } );\n    local s = new_args['s'] or '';\n    local i = tonumber( new_args['i'] ) or 1;\n    local j = tonumber( new_args['j'] ) or -1;\n    \n    local len = mw.ustring.len( s );\n\n    -- Convert negatives for range checking\n    if i < 0 then\n        i = len + i + 1;\n    end\n    if j < 0 then\n        j = len + j + 1;\n    end\n    \n    if i > len or j > len or i < 1 or j < 1 then\n        return str._error( 'String subset index out of range' );\n    end\n    if j < i then\n        return str._error( 'String subset indices out of order' );\n    end\n    \n    return mw.ustring.sub( s, i, j )\nend\n\n--[[\nThis function implements that features of {{str sub old}} and is kept in order\nto maintain these older templates.\n]]\nfunction str.sublength( frame )\n    local i = tonumber( frame.args.i ) or 0\n    local len = tonumber( frame.args.len )\n    return mw.ustring.sub( frame.args.s, i + 1, len and ( i + len ) )\nend\n\n--[[\nmatch\n\nThis function returns a substring from the source string that matches a \nspecified pattern.\n\nUsage:\n{{#invoke:String|match|source_string|pattern_string|start_index|match_number|plain_flag|nomatch_output}}\nOR\n{{#invoke:String|pos|s=source_string|pattern=pattern_string|start=start_index\n    |match=match_number|plain=plain_flag|nomatch=nomatch_output}}\n\nParameters\n    s: The string to search\n    pattern: The pattern or string to find within the string\n    start: The index within the source string to start the search.  The first\n        character of the string has index 1.  Defaults to 1.\n    match: In some cases it may be possible to make multiple matches on a single \n        string.  This specifies which match to return, where the first match is \n        match= 1.  If a negative number is specified then a match is returned \n        counting from the last match.  Hence match = -1 is the same as requesting\n        the last match.  Defaults to 1.\n    plain: A flag indicating that the pattern should be understood as plain\n        text.  Defaults to false.\n    nomatch: If no match is found, output the \"nomatch\" value rather than an error.\n\nIf invoked using named parameters, Mediawiki will automatically remove any leading or\ntrailing whitespace from each string.  In some circumstances this is desirable, in \nother cases one may want to preserve the whitespace.\n\nIf the match_number or start_index are out of range for the string being queried, then\nthis function generates an error.  An error is also generated if no match is found.\nIf one adds the parameter ignore_errors=true, then the error will be suppressed and \nan empty string will be returned on any failure.\n\nFor information on constructing Lua patterns, a form of [regular expression], see:\n\n* http://www.lua.org/manual/5.1/manual.html#5.4.1\n* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns\n* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Ustring_patterns\n\n]]\nfunction str.match( frame )\n    local new_args = str._getParameters( frame.args, {'s', 'pattern', 'start', 'match', 'plain', 'nomatch'} );\n    local s = new_args['s'] or '';\n    local start = tonumber( new_args['start'] ) or 1;\n    local plain_flag = str._getBoolean( new_args['plain'] or false );\n    local pattern = new_args['pattern'] or '';\n    local match_index = math.floor( tonumber(new_args['match']) or 1 );\n    local nomatch = new_args['nomatch'];\n    \n    if s == '' then\n        return str._error( 'Target string is empty' );\n    end\n    if pattern == '' then\n        return str._error( 'Pattern string is empty' );\n    end\n    if math.abs(start) < 1 or math.abs(start) > mw.ustring.len( s ) then\n        return str._error( 'Requested start is out of range' );\n    end\n    if match_index == 0 then\n        return str._error( 'Match index is out of range' );\n    end\n    if plain_flag then\n        pattern = str._escapePattern( pattern );\n    end\n    \n    local result\n    if match_index == 1 then\n        -- Find first match is simple case\n        result = mw.ustring.match( s, pattern, start )\n    else\n        if start > 1 then\n            s = mw.ustring.sub( s, start );\n        end\n        \n        local iterator = mw.ustring.gmatch(s, pattern);\n        if match_index > 0 then\n            -- Forward search\n            for w in iterator do\n                match_index = match_index - 1;\n                if match_index == 0 then\n                    result = w;\n                    break;\n                end\n            end    \n        else\n            -- Reverse search\n            local result_table = {};\n            local count = 1;\n            for w in iterator do\n                result_table[count] = w;\n                count = count + 1;\n            end\n            \n            result = result_table[ count + match_index ];            \n        end\n    end        \n    \n    if result == nil then\n        if nomatch == nil then\n            return str._error( 'Match not found' );\n        else\n            return nomatch;\n        end\n    else\n        return result;\n    end\nend\n\n--[[\npos\n\nThis function returns a single character from the target string at position pos.\n\nUsage:\n{{#invoke:String|pos|target_string|index_value}}\nOR\n{{#invoke:String|pos|target=target_string|pos=index_value}}\n\nParameters\n    target: The string to search\n    pos: The index for the character to return\n\nIf invoked using named parameters, Mediawiki will automatically remove any leading or\ntrailing whitespace from the target string.  In some circumstances this is desirable, in \nother cases one may want to preserve the whitespace.\n\nThe first character has an index value of 1.\n\nIf one requests a negative value, this function will select a character by counting backwards \nfrom the end of the string.  In other words pos = -1 is the same as asking for the last character.\n\nA requested value of zero, or a value greater than the length of the string returns an error.\n]]\nfunction str.pos( frame )\n    local new_args = str._getParameters( frame.args, {'target', 'pos'} );\n    local target_str = new_args['target'] or '';\n    local pos = tonumber( new_args['pos'] ) or 0;\n\n    if pos == 0 or math.abs(pos) > mw.ustring.len( target_str ) then\n        return str._error( 'String index out of range' );\n    end    \n    \n    return mw.ustring.sub( target_str, pos, pos );\nend\n\n--[[\nstr_find\n\nThis function duplicates the behavior of {{str_find}}, including all of its quirks.\nThis is provided in order to support existing templates, but is NOT RECOMMENDED for \nnew code and templates.  New code is recommended to use the \"find\" function instead.\n\nReturns the first index in \"source\" that is a match to \"target\".  Indexing is 1-based,\nand the function returns -1 if the \"target\" string is not present in \"source\".\n\nImportant Note: If the \"target\" string is empty / missing, this function returns a\nvalue of \"1\", which is generally unexpected behavior, and must be accounted for\nseparatetly.\n]]\nfunction str.str_find( frame )\n    local new_args = str._getParameters( frame.args, {'source', 'target'} );\n    local source_str = new_args['source'] or '';\n    local target_str = new_args['target'] or '';\n\n    if target_str == '' then\n        return 1;\n    end    \n    \n    local start = mw.ustring.find( source_str, target_str, 1, true )\n    if start == nil then\n        start = -1\n    end\n    \n    return start\nend\n\n--[[\nfind\n\nThis function allows one to search for a target string or pattern within another\nstring.\n\nUsage:\n{{#invoke:String|find|source_str|target_string|start_index|plain_flag}}\nOR\n{{#invoke:String|find|source=source_str|target=target_str|start=start_index|plain=plain_flag}}\n\nParameters\n    source: The string to search\n    target: The string or pattern to find within source\n    start: The index within the source string to start the search, defaults to 1\n    plain: Boolean flag indicating that target should be understood as plain\n        text and not as a Lua style regular expression, defaults to true\n\nIf invoked using named parameters, Mediawiki will automatically remove any leading or\ntrailing whitespace from the parameter.  In some circumstances this is desirable, in \nother cases one may want to preserve the whitespace.\n\nThis function returns the first index >= \"start\" where \"target\" can be found \nwithin \"source\".  Indices are 1-based.  If \"target\" is not found, then this \nfunction returns 0.  If either \"source\" or \"target\" are missing / empty, this\nfunction also returns 0.\n\nThis function should be safe for UTF-8 strings.\n]]\nfunction str.find( frame )\n    local new_args = str._getParameters( frame.args, {'source', 'target', 'start', 'plain' } ); \n    local source_str = new_args['source'] or '';\n    local pattern = new_args['target'] or '';\n    local start_pos = tonumber(new_args['start']) or 1;\n    local plain = new_args['plain'] or true;\n        \n    if source_str == '' or pattern == '' then\n        return 0;\n    end    \n    \n    plain = str._getBoolean( plain );\n\n    local start = mw.ustring.find( source_str, pattern, start_pos, plain )\n    if start == nil then\n        start = 0\n    end\n    \n    return start\nend\n\n--[[\nreplace\n\nThis function allows one to replace a target string or pattern within another\nstring.\n\nUsage:\n{{#invoke:String|replace|source_str|pattern_string|replace_string|replacement_count|plain_flag}}\nOR\n{{#invoke:String|replace|source=source_string|pattern=pattern_string|replace=replace_string|\n   count=replacement_count|plain=plain_flag}}\n\nParameters\n    source: The string to search\n    pattern: The string or pattern to find within source\n    replace: The replacement text\n    count: The number of occurences to replace, defaults to all.\n    plain: Boolean flag indicating that pattern should be understood as plain\n        text and not as a Lua style regular expression, defaults to true \n]]\nfunction str.replace( frame )\n    local new_args = str._getParameters( frame.args, {'source', 'pattern', 'replace', 'count', 'plain' } ); \n    local source_str = new_args['source'] or '';\n    local pattern = new_args['pattern'] or '';\n    local replace = new_args['replace'] or '';\n    local count = tonumber( new_args['count'] );\n    local plain = new_args['plain'] or true;\n        \n    if source_str == '' or pattern == '' then\n        return source_str;\n    end    \n    plain = str._getBoolean( plain );\n\n    if plain then\n        pattern = str._escapePattern( pattern );\n        replace = mw.ustring.gsub( replace, \"%%\", \"%%%%\" ); --Only need to escape replacement sequences.\n    end\n    \n    local result;\n\n    if count ~= nil then\n        result = mw.ustring.gsub( source_str, pattern, replace, count );\n    else\n        result = mw.ustring.gsub( source_str, pattern, replace );\n    end        \n\n    return result;\nend\n\n--[[ \n    simple function to pipe string.rep to templates.\n]]\n\nfunction str.rep( frame )\n    local repetitions = tonumber( frame.args[2] )\n    if not repetitions then \n        return str._error( 'function rep expects a number as second parameter, received \"' .. ( frame.args[2] or '' ) .. '\"' )\n    end\n    return string.rep( frame.args[1] or '', repetitions )\nend\n\n--[[\nHelper function that populates the argument list given that user may need to use a mix of\nnamed and unnamed parameters.  This is relevant because named parameters are not\nidentical to unnamed parameters due to string trimming, and when dealing with strings\nwe sometimes want to either preserve or remove that whitespace depending on the application.\n]]\nfunction str._getParameters( frame_args, arg_list )\n    local new_args = {};\n    local index = 1;\n    local value;\n    \n    for i,arg in ipairs( arg_list ) do\n        value = frame_args[arg]\n        if value == nil then\n            value = frame_args[index];\n            index = index + 1;\n        end\n        new_args[arg] = value;\n    end\n    \n    return new_args;\nend        \n\n--[[\nHelper function to handle error messages.\n]]\nfunction str._error( error_str )\n    local frame = mw.getCurrentFrame();\n    local error_category = frame.args.error_category or 'Errors reported by Module String';\n    local ignore_errors = frame.args.ignore_errors or false;\n    local no_category = frame.args.no_category or false;\n    \n    if str._getBoolean(ignore_errors) then\n        return '';\n    end\n    \n    local error_str = '<strong class=\"error\">String Module Error: ' .. error_str .. '</strong>';\n    if error_category ~= '' and not str._getBoolean( no_category ) then\n        error_str = '[[Category:' .. error_category .. ']]' .. error_str;\n    end        \n    \n    return error_str;\nend\n\n--[[\nHelper Function to interpret boolean strings\n]]\nfunction str._getBoolean( boolean_str )\n    local boolean_value;\n    \n    if type( boolean_str ) == 'string' then\n        boolean_str = boolean_str:lower();\n        if boolean_str == 'false' or boolean_str == 'no' or boolean_str == '0' \n                or boolean_str == '' then\n            boolean_value = false;\n        else\n            boolean_value = true;\n        end    \n    elseif type( boolean_str ) == 'boolean' then\n        boolean_value = boolean_str;\n    else\n        error( 'No boolean value found' );\n    end    \n    return boolean_value\nend\n\n--[[\nHelper function that escapes all pattern characters so that they will be treated \nas plain text.\n]]\nfunction str._escapePattern( pattern_str )\n    return mw.ustring.gsub( pattern_str, \"([%(%)%.%%%+%-%*%?%[%^%$%]])\", \"%%%1\" );\nend\n\nreturn str"}}}