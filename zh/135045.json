{"parse":{"title":"\u6a21\u5757:Utawari","pageid":304824,"wikitext":{"*":"local module = {};\nlocal noLyric = false;\n\nlocal getArgs = require('Module:Arguments').getArgs\nfunction module.main(frame)\n\tlocal args = getArgs(frame)\n\treturn module._main(args)\nend\n\nfunction module._main(args)\n\tlocal nodes = {}\n\tfor i, v in ipairs(args) do table.insert(nodes, module.createNode()) end --\u521d\u59cb\u5316\u7ed3\u679ctable\u3002\n\t\n\t-- \u5efa\u7acb\u5f15\u7528\u6811\u3002\n\tfor i, v in ipairs(args) do\n\t\tmodule.analyzeLine(i, v, nodes)\n\tend\n\t\n\tlocal lineSeparator = nil\n\tif args[\"noLyric\"] == nil then --\u6b4c\u8bcd\u6a21\u5f0f\n\t\tnoLyric = false\n\t\tlineSeparator = \"\\r\\n\" --{{LyricsKai}}/{{LyricsKai/colors}}\u4e2d\u7684\u6362\u884c\u5b57\u7b26\u4e32\u3002\n\telse --\u975e\u6b4c\u8bcd\u6a21\u5f0f\n\t\tnoLyric = true\n\t\tlineSeparator = args[\"lineSeparator\"]\n\t\tif lineSeparator == nil then\n\t\t\tlineSeparator = \"\\r\\n\\r\\n\" --wiki\u7684\u6362\u884c\u5b57\u7b26\u4e32\u3002\n\t\tend\n\tend\n\treturn module.output(nodes, lineSeparator)\nend\n\nfunction module.analyzeLine(index, line, result)\n\tlocal currentNode = result[index]\n\tlocal r = module.stringSplitX(line, \"##|#%d+\", \n\t\tfunction(t, i, l)\n\t\t\tif (t == \"##\") then\n\t\t\t\treturn \"#\"\n\t\t\telse\n\t\t\t\tlocal referenceNode = result[tonumber(string.sub(t, 2, l))]\n\t\t\t\t\n\t\t\t\tmodule.setParent(referenceNode, currentNode)\n\t\t\t\treturn referenceNode\n\t\t\tend\n\t\tend\n\t)\n\t\n\tfor i,v in ipairs(r) do\n\t\ttable.insert(currentNode.data, v)\n\tend\nend\n\nfunction module.output(nodes, lineSeparator)\n\tlocal result = {}\n\tlocal outputLine = function(node)\n\t\tlocal outputTabInternal = nil\n\t\toutputTabInternal = function(n, t)\n\t\t\tif (n.parent == nil) then return end\n\t\t\toutputTabInternal(n.parent, t)\n\t\t\t\n\t\t\tfor _i, _d in ipairs(n.parent.data) do\n\t\t\t\tif _d == n then break\n\t\t\t\telseif module.tableFind(nodes, _d) ~= nil then --Do nothing.\n\t\t\t\telse\n\t\t\t\t\ttable.insert(t, _d)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\tlocal tabs = {}\n\t\toutputTabInternal(node, tabs)\n\t\t\n\t\tlocal datas = {}\n\t\tfor i, d in ipairs(node.data) do\n\t\t\tif module.tableFind(nodes, d) == nil then\n\t\t\t\ttable.insert(datas, d)\n\t\t\tend\n\t\tend\n\t\t\n\t\tif next(tabs) == nil then\n\t\t\ttable.insert(result, table.concat(datas))\n\t\telse\n\t\t\tlocal span = mw.html.create(\"span\")\n\t\t\t-- span:attr(\"class\", \"mw-parser-output\")\n\t\t\tlocal sub = mw.html.create(\"span\")\n\t\t\tif noLyric then\n\t\t\t\tsub:attr(\"class\", \"Utawari-nolyric-tab\") --\u975e\u6b4c\u8bcd\u6a21\u5f0f\u4f7f\u7528\u7684\u6837\u5f0f\u3002\n\t\t\telse\n\t\t\t\tsub:attr(\"class\", \"Utawari-lyric-tab\") --\u6b4c\u8bcd\u6a21\u5f0f\u4f7f\u7528\u7684\u6837\u5f0f\u3002\n\t\t\tend\n\t\t\tsub:node(table.concat(tabs))\n\t\t\tspan:node(sub) span:node(table.concat(datas))\n\t\t\ttable.insert(result, tostring(span))\n\t\tend\n\tend\n\t\n\tfor i, v in ipairs(nodes) do outputLine(v) end\n\t\n\treturn table.concat(result, lineSeparator)\nend\n\n--\u5224\u65adnode1\u662f\u5426\u4e3anode2\u7684\u4e0a\u5c42\u8282\u70b9\u3002\nfunction module.isAncestor(node1, node2)\n\tif node2.parent == nil then\n\t\treturn false\n\telseif node2.parent == mode1 then \n\t\treturn true\n\telse\n\t\treturn module.isAncestor(node1, node2.parent)\n\tend\nend\n\n--\u5c06node2\u8bbe\u4e3anode1\u7684\u7236\u8282\u70b9\u3002\nfunction module.setParent(node1, node2)\n\tif node1.parent ~= nil then error(\"\u65e0\u6cd5\u4fee\u6539\u7236\u8282\u70b9\u3002\")\n\telseif module.isAncestor(node1, node2) then error(\"\u5faa\u73af\u8bbe\u7f6e\u7236\u8282\u70b9\u3002\")\n\telse\n\t\tnode1.parent = node2\n\t\ttable.insert(node2.children, node1)\n\tend\nend\n\n--\u521b\u5efa\u4e00\u4e2a\u65b0\u8282\u70b9\u3002\nfunction module.createNode()\n\treturn {\n\t\tparent = nil,\n\t\tchildren = {},\n\t\tdata = {}\n\t}\nend\n\nfunction module.stringSplitX(s, pattern, func)\n\tlocal result = {}\n\tlocal localIndex = 1\n\twhile true do\n\t\tlocal text, index, length = module.stringMatchX(s, pattern, localIndex)\n\t\tif index == nil then break end\n\t\t\n\t\tif index > localIndex then table.insert(result, string.sub(s, localIndex, index - 1)) end \n\t\ttable.insert(result, func(text, index, length))\n\t\tlocalIndex = index + length\n\tend\n\t\n\tif localIndex <= string.len(s) then table.insert(result, string.sub(s, localIndex, string.len(s))) end\n\t\n\treturn result;\nend\n\nfunction module.stringMatchX(s, pattern, init)\n\tlocal x, y = module.stringFindX(s, pattern, init)\n\t\n\tif x == nil or y == nil then\n\t\treturn nil, nil, nil\n\telse\n\t\tlocal text = string.sub(s, x, y)\n\t\tlocal length = y - x + 1\n\t\n\t\treturn text, x, length\n\tend\nend\n\nfunction module.stringFindX(str, pattern, init)\n\tlocal va1, va2 = string.find(pattern, \"|\")\n\tlocal patterntable = {}\n\tif va1 ~= nil then\n\t\ttable.insert(patterntable, string.sub(pattern, 1, va1 - 1))\n\t\ttable.insert(patterntable, string.sub(pattern, va1 + 1, string.len(pattern)))\n\tend\n\t\n\tva1, va2 = string.find(str, patterntable[1], init)\n\tif va1 == nil then return string.find(str, patterntable[2], init)\n\telse\n\t\tva3, va4 = string.find(str, patterntable[2], init)\n\t\tif va3 == nil then return va1, va2 end\n\t\t\n\t\tif va1 < va3 then return va1, va2\n\t\telseif va1 > va3 then return va3, va4\n\t\telse\n\t\t\tif va2 <= va4 then return va1, va2\n\t\t\telse return va3, va4\n\t\t\tend\n\t\tend\n\tend\n\treturn va1, va2\nend\n\nfunction module.tableFind(t, item)\n\tfor i,v in ipairs(t) do\n\t\tif v == item then return i end\n\tend\n\t\n\treturn nil\nend\n\nreturn module"}}}