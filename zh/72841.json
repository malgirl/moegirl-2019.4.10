{"parse":{"title":"User:Nbdd0121/tools/wikihighlight.js","pageid":163290,"wikitext":{"*":"//<pre> Disable signature replacing\nCodeMirror.defineMode('mediawiki', function() {\n\tfunction arrayRemove(array, object) {\n\t\tvar index = array.indexOf(object);\n\t\tif (index !== -1) array.splice(index, 1);\n\t}\n\n\tvar module = {};\n\tvar config = {\n\t\tprotocols: [\n\t\t\t'bitcoin:', 'ftp://', 'ftps://', 'geo:', 'git://', 'gopher://', 'http://',\n\t\t\t'https://', 'irc://', 'ircs://', 'magnet:', 'mailto:', 'mms://', 'news:',\n\t\t\t'nntp://', 'redis://', 'sftp://', 'sip:', 'sips:', 'sms:', 'ssh://',\n\t\t\t'svn://', 'tel:', 'telnet://', 'urn:', 'worldwind://', 'xmpp:',\n\t\t\t// Note '//'' should not be included here\n\t\t],\n\t\tlinktrail: false\n\t};\n\n\tvar EXT_LINK_ADDR = /(?:[0-9.]+|\\[[0-9a-fA-F:.]+\\]|[^\\]\\[<>\"\\s])/; // Match host name, include IPv4, IPv6 and Domain name\n\tvar EXT_LINK_PROTOCOL_NOREL = new RegExp(config.protocols.join('|'));\n\tvar EXT_LINK_PROTOCOL = new RegExp(config.protocols.join('|') + '|//');\n\tvar EXT_LINK_URL = /(?:[0-9.]+|\\[[0-9a-fA-F:.]+\\]|[^\\]\\[<>\"\\s])[^\\]\\[<>\"\\s]*/;\n\n\tvar ALLOWED_TAGS = {\n\t\tbdi: true,\n\t\tins: true,\n\t\tu: true,\n\t\tfont: true,\n\t\tbig: true,\n\t\tsmall: true,\n\t\tsub: true,\n\t\tsup: true,\n\t\th1: true,\n\t\th2: true,\n\t\th3: true,\n\t\th4: true,\n\t\th5: true,\n\t\th6: true,\n\t\tcite: true,\n\t\tcode: true,\n\t\tstrike: true,\n\t\ttt: true,\n\t\tvar: true,\n\t\tdiv: true,\n\t\tcenter: true,\n\t\tblockquote: true,\n\t\tol: true,\n\t\tul: true,\n\t\tdl: true,\n\t\ttable: true,\n\t\tcaption: true,\n\t\tpre: true,\n\t\truby: true,\n\t\trb: true,\n\t\trp: true,\n\t\trt: true,\n\t\trtc: true,\n\t\tp: true,\n\t\tspan: true,\n\t\tabbr: true,\n\t\tdfn: true,\n\t\tkbd: true,\n\t\tsamp: true,\n\t\tdata: true,\n\t\ttime: true,\n\t\tmark: true,\n\t\tbr: false,\n\t\twbr: false,\n\t\thr: false,\n\t\tli: true,\n\t\tdt: true,\n\t\tdd: true,\n\t\ttd: true,\n\t\tth: true,\n\t\ttr: true,\n\t\t// These tags are added here but they are not html\n\t\tnoinclude: true,\n\t\tincludeonly: true,\n\t\tonlyinclude: true\n\t};\n\n\tfunction generateStyleMixinTagHandler(style) {\n\t\treturn {\n\t\t\topen: function(stream, state) {\n\t\t\t\tstate.mixinStyle.push(style);\n\t\t\t},\n\t\t\tclose: function(stream, state) {\n\t\t\t\tvar index = state.mixinStyle.indexOf(style);\n\t\t\t\tif (index !== -1) state.mixinStyle.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\tALLOWED_TAGS['s'] = ALLOWED_TAGS['strike'] = ALLOWED_TAGS['del'] = generateStyleMixinTagHandler('strikethrough'); // Alias\n\tALLOWED_TAGS['b'] = ALLOWED_TAGS['strong'] = generateStyleMixinTagHandler('strong'); // Alias\n\tALLOWED_TAGS['i'] = ALLOWED_TAGS['em'] = generateStyleMixinTagHandler('em'); // Alias\n\n\tALLOWED_TAGS['nowiki'] = {\n\t\topen: function(stream, state) {\n\t\t\tstate.unclosedTags.pop();\n\t\t\tstate.handler = parseNowikiTag;\n\t\t},\n\t\tcanSelfClose: true\n\t\t\t// close never reached\n\t};\n\n\tALLOWED_TAGS['pre'] = {\n\t\topen: function(stream, state) {\n\t\t\tstate.mixinStyle.push('mw-pre');\n\t\t\tstate.unclosedTags.pop();\n\t\t\tstate.handler = parsePreTag;\n\t\t},\n\t\tcanSelfClose: true\n\t\t\t// close never reached\n\t};\n\n\t// Extension:Cite\n\tALLOWED_TAGS['ref'] = true;\n\tALLOWED_TAGS['references'] = false;\n\n\t// Other extensions\n\tALLOWED_TAGS['categorytree'] = true;\n\tALLOWED_TAGS['charinsert'] = true;\n\tALLOWED_TAGS['choose'] = true;\n\tALLOWED_TAGS['dynamicpagelist'] = true;\n\tALLOWED_TAGS['flashmp3'] = true;\n\tALLOWED_TAGS['gallery'] = true;\n\tALLOWED_TAGS['imagemap'] = true;\n\tALLOWED_TAGS['indicator'] = true;\n\tALLOWED_TAGS['inputbox'] = true;\n\tALLOWED_TAGS['poem'] = true;\n\tALLOWED_TAGS['poll'] = true;\n\tALLOWED_TAGS['sm2'] = true;\n\n\t// Utility\n\tfunction tagCanSelfClose(tagname) {\n\t\tvar tag = ALLOWED_TAGS[tagname];\n\t\tif (tag === false) {\n\t\t\treturn true;\n\t\t}\n\t\tif (typeof tag !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\tif ('canSelfClose' in tag) {\n\t\t\treturn tag.canSelfClose;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction makeStyle(style, state) {\n\t\tif (state.bold) {\n\t\t\tstyle += ' strong';\n\t\t}\n\t\tif (state.italic) {\n\t\t\tstyle += ' em';\n\t\t}\n\t\tstyle += ' ' + state.mixinStyle.join(' ');\n\t\treturn style;\n\t}\n\n\tfunction parseWikitext(stream, state) {\n\t\tvar sol = stream.sol();\n\n\t\tvar match = stream.match(EXT_LINK_PROTOCOL_NOREL);\n\t\tif (match) {\n\t\t\tif (stream.match(EXT_LINK_ADDR, false)) {\n\t\t\t\t// The URL must looks like a URL\n\t\t\t\tstate.stack.push(state.handler);\n\t\t\t\tstate.handler = parseFreeExternalLink;\n\t\t\t\treturn 'mw-extlink';\n\t\t\t} else {\n\t\t\t\t// Does not look like URL, backUp\n\t\t\t\tstream.backUp(match[0].length);\n\t\t\t}\n\t\t}\n\n\t\tstream.backUp(1);\n\t\tvar sow = !/\\w/.exec(stream.next());\n\n\t\tif (sow) {\n\t\t\tmatch = stream.match(/(?:ISBN|RFC|PMID)\\s+/);\n\t\t\tif (match) {\n\t\t\t\tif (match[0].startsWith('ISBN')) {\n\t\t\t\t\tvar match2 = stream.match(/(?:97[89][- ]?)?(?:[0-9][- ]?){9}[0-9Xx]\\b/);\n\t\t\t\t\tif (match2) {\n\t\t\t\t\t\treturn 'mw-isbn';\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar match2 = stream.match(/[0-9]+\\b/);\n\t\t\t\t\tif (match2) {\n\t\t\t\t\t\tif (match[0].startsWith('RFC')) {\n\t\t\t\t\t\t\treturn 'mw-rfc';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn 'mw-pmid';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstream.backUp(match[0].length);\n\t\t\t}\n\t\t}\n\n\t\tif (sol) {\n\t\t\t// Table\n\t\t\tif (stream.match(/\\s*(:*)\\s*(?=\\{\\|)/)) {\n\t\t\t\tstate.stack.push(state.handler);\n\t\t\t\tstate.handler = parseTableStart;\n\t\t\t\treturn 'mw-ident';\n\t\t\t}\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '-':\n\t\t\t\t\tif (stream.match(/-{4,}/)) {\n\t\t\t\t\t\treturn 'mw-hr';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#': // TODO #REDIRECT\n\t\t\t\tcase '*':\n\t\t\t\tcase ';':\n\t\t\t\tcase ':':\n\t\t\t\t\tstream.match(/[*#;:]*/);\n\t\t\t\t\treturn 'mw-ident';\n\t\t\t\tcase ' ':\n\t\t\t\t\tstream.next();\n\t\t\t\t\treturn 'line-cm-mw-pre';\n\t\t\t\tcase '=':\n\t\t\t\t\tmatch = stream.match(/(={1,6})(?=.+?\\1\\s*$)/);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tstate.handler = makeParseSectionHeader(match[1].length);\n\t\t\t\t\t\treturn 'mw-section line-cm-mw-section-' + match[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tswitch (stream.peek()) {\n\t\t\tcase '\\'':\n\t\t\t\tif (stream.match(/'+(?=''''')/)) { // more than 5 apostrophes, only last five are considered\n\t\t\t\t\treturn makeStyle('', state);\n\t\t\t\t}\n\t\t\t\tif (stream.match(/'(?='''(?!'))/)) { // 4 apostrophes, only last three are considered\n\t\t\t\t\treturn makeStyle('', state);\n\t\t\t\t}\n\t\t\t\tif (stream.match(\"'''\")) {\n\t\t\t\t\tif (!state.bold) {\n\t\t\t\t\t\tstate.bold = true;\n\t\t\t\t\t\treturn 'mw-bold-start';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.bold = false;\n\t\t\t\t\t\treturn 'mw-bold-end';\n\t\t\t\t\t}\n\t\t\t\t} else if (stream.match(\"''\")) {\n\t\t\t\t\tif (!state.italic) {\n\t\t\t\t\t\tstate.italic = true;\n\t\t\t\t\t\treturn 'mw-italic-start';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.italic = false;\n\t\t\t\t\t\treturn 'mw-italic-end';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// TODO Mismatch Recovery\n\t\t\t\tbreak;\n\t\t\tcase '~':\n\t\t\t\tvar match = stream.match(/~{3,5}/);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn 'mw-signature';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '_':\n\t\t\t\tif (sow) {\n\t\t\t\t\tvar match = stream.match(/\\b__[A-Z_]+?__/);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn 'mw-magic-word';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tif (stream.match('{{')) {\n\t\t\t\t\tstate.stack.push(state.handler);\n\t\t\t\t\tstate.handler = parseTemplateName;\n\t\t\t\t\treturn 'mw-template-start';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tif (stream.match('[[')) {\n\t\t\t\t\tif (!stream.match(/[^\\|\\[\\]]+(?:\\|.*?)?\\]\\]/, false)) { // Not a link\n\t\t\t\t\t\treturn makeStyle('', state);\n\t\t\t\t\t}\n\t\t\t\t\tstate.stack.push(state.handler);\n\t\t\t\t\tstate.handler = parseLinkTarget;\n\t\t\t\t\treturn 'mw-link-start';\n\t\t\t\t} else {\n\t\t\t\t\tstream.next();\n\t\t\t\t\tvar match = stream.match(EXT_LINK_PROTOCOL);\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\tif (stream.match(EXT_LINK_ADDR, false) && stream.match(/.+?]/, false)) {\n\t\t\t\t\t\t\t// The URL must looks like a URL\n\t\t\t\t\t\t\tstate.stack.push(state.handler);\n\t\t\t\t\t\t\tstate.handler = parseExternalLink;\n\t\t\t\t\t\t\t// Still have to back up the URL, rendered differently\n\t\t\t\t\t\t\tstream.backUp(match[0].length);\n\t\t\t\t\t\t\treturn 'mw-extlink-start';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Does not look like URL, backUp\n\t\t\t\t\t\t\tstream.backUp(match[0].length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Bug reported by AnnAngela\n\t\t\t\t\t// [{{}} does not render correctly\n\t\t\t\t\treturn makeStyle('', state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\t\treturn parseEntityOnly(stream, state);\n\t\t\tcase '<':\n\t\t\t\tif (stream.match('<!--')) {\n\t\t\t\t\tstate.stack.push(state.handler);\n\t\t\t\t\tstate.handler = parseComment;\n\t\t\t\t\treturn 'mw-comment';\n\t\t\t\t}\n\t\t\t\tstream.next(); // eat <\n\t\t\t\tvar closing = !!stream.eat('/');\n\t\t\t\tvar tagname = stream.match(/\\w+/);\n\t\t\t\tif (!tagname || !(tagname[0] in ALLOWED_TAGS)) {\n\t\t\t\t\t// The eaten ones are treated as plain text if this is not a tag or not allowed\n\t\t\t\t\treturn makeStyle('', state);\n\t\t\t\t}\n\t\t\t\ttagname = tagname[0];\n\t\t\t\tvar match = stream.match(/[^<]*?(\\/)?>/, false);\n\t\t\t\tif (!match) {\n\t\t\t\t\t// No closing >, treat as text\n\t\t\t\t\treturn makeStyle('', state);\n\t\t\t\t}\n\t\t\t\tvar selfClose = false;\n\t\t\t\tif (match[1]) {\n\t\t\t\t\t// Self-closing tag processing\n\t\t\t\t\tif (!closing && !tagCanSelfClose(tagname)) {\n\t\t\t\t\t\t// Not self-closing tag, treat as text\n\t\t\t\t\t\treturn makeStyle('', state);\n\t\t\t\t\t}\n\t\t\t\t\tselfClose = true;\n\t\t\t\t}\n\n\t\t\t\tif (closing) {\n\t\t\t\t\tvar uc = state.unclosedTags.slice();\n\t\t\t\t\twhile (uc.length) {\n\t\t\t\t\t\tif (uc.pop() === tagname) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// If closing tag\n\t\t\t\t\tif (state.unclosedTags[uc.length] === tagname) {\n\t\t\t\t\t\tstate.unclosedTags = uc;\n\t\t\t\t\t\tif (stream.match(/[^<]*?>/)) {\n\t\t\t\t\t\t\tif (typeof(ALLOWED_TAGS[tagname]) === 'object')\n\t\t\t\t\t\t\t\tALLOWED_TAGS[tagname].close(stream, state);\n\n\t\t\t\t\t\t\tstate.handler = state.stack.pop();\n\t\t\t\t\t\t\treturn 'mw-tag-close';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Otherwise, treat as text\n\t\t\t\t\treturn makeStyle('', state);\n\t\t\t\t} else {\n\t\t\t\t\tif (ALLOWED_TAGS[tagname] && !selfClose) { // If not self-closing\n\t\t\t\t\t\tstate.unclosedTags.push(tagname);\n\t\t\t\t\t}\n\t\t\t\t\tstate.stack.push(state.handler);\n\t\t\t\t\tstate.handler = makeParseOpenTag(tagname, selfClose);\n\t\t\t\t\treturn 'mw-tag-open';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tstream.next();\n\t\treturn makeStyle('', state);\n\t}\n\n\tfunction parseFreeExternalLink(stream, state) {\n\t\tvar match = stream.match(EXT_LINK_URL);\n\t\tvar text = match[0];\n\n\t\t// {{, ~~~, '' will start their effect, so detect and correct\n\t\tvar match = /\\{\\{|~~~|''/.exec(text);\n\t\tif (match) {\n\t\t\t// Pushback the wrongly included part\n\t\t\tstream.backUp(text.length - match.index);\n\t\t\ttext = text.substring(0, match.index);\n\t\t}\n\n\t\t// There are some symbols common in English, they are \n\t\t// not treated as part of URL if they are trailing.\n\t\t// If there is no left parenthesis, \n\t\t// we assume that right parenthese will then not be part of URL\n\t\tvar regex = text.indexOf('(') !== -1 ? /[,;\\\\.:!?]+$/ : /[,;\\\\.:!?)]+$/;\n\t\tvar match = regex.exec(text);\n\t\tvar detLength = match ? match[0].length : 0;\n\t\tif (detLength !== 0) {\n\t\t\tstream.backUp(detLength);\n\t\t}\n\n\t\tstate.handler = state.stack.pop();\n\t\treturn 'mw-extlink';\n\t}\n\n\tfunction makeParseSectionHeader(count) {\n\t\tvar regExp = new RegExp('={' + count + '}\\\\s*$');\n\t\treturn function(stream, state) {\n\t\t\tif (stream.match(regExp)) {\n\t\t\t\treturn 'mw-section';\n\t\t\t}\n\t\t\treturn parseWikitext(stream, state);\n\t\t}\n\t}\n\n\tfunction parseComment(stream, state) {\n\t\tif (stream.match('-->')) {\n\t\t\tstate.handler = state.stack.pop();\n\t\t} else {\n\t\t\tstream.next();\n\t\t}\n\t\treturn 'mw-comment';\n\t}\n\n\tfunction parseTableStart(stream, state) {\n\t\tstream.match('{|');\n\t\tstate.handler = state.stack.pop();\n\t\treturn 'mw-table-start';\n\t}\n\n\tfunction makeParseOpenTag(tagname, selfClose) {\n\t\treturn function(stream, state) {\n\t\t\tif (stream.match(/\\/?>/)) {\n\t\t\t\tif (!selfClose) {\n\t\t\t\t\tstate.handler = parseWikitext;\n\t\t\t\t\tif (typeof(ALLOWED_TAGS[tagname]) === 'object') {\n\t\t\t\t\t\tALLOWED_TAGS[tagname].open(stream, state);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstate.handler = state.stack.pop();\n\t\t\t\t}\n\t\t\t\treturn 'mw-tag-open';\n\t\t\t} else {\n\t\t\t\tstream.next();\n\t\t\t\treturn 'mw-tag-attr';\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction parseEntityOnly(stream, state) {\n\t\tif (stream.next() === '&') {\n\t\t\tvar success;\n\t\t\tif (stream.eat('#')) {\n\t\t\t\tif (stream.eat('x')) {\n\t\t\t\t\tsuccess = stream.eatWhile(/[a-fA-F\\d]/);\n\t\t\t\t} else {\n\t\t\t\t\tsuccess = stream.eatWhile(/[\\d]/);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsuccess = stream.eatWhile(/[\\w\\.\\-:]/);\n\t\t\t}\n\t\t\tif (success) {\n\t\t\t\tsuccess = stream.eat(';');\n\t\t\t}\n\t\t\tif (success) {\n\t\t\t\treturn makeStyle('mw-entity', state);\n\t\t\t}\n\t\t}\n\t\treturn makeStyle('', state);\n\t}\n\n\t/* Internal link parsing */\n\n\tfunction parseLinkTarget(stream, state) {\n\t\tstream.match(/.+?(?=\\||\\]\\])/);\n\t\tif (stream.peek() === '|') {\n\t\t\tstate.handler = parseLinkPipe;\n\t\t} else {\n\t\t\tstate.handler = parseLinkEnd;\n\t\t}\n\t\treturn 'mw-link-target';\n\t}\n\n\tfunction parseLinkEnd(stream, state) {\n\t\tstream.match(']]');\n\t\tif (config.linktrail) {\n\t\t\tstate.handler = parseLinkTrail;\n\t\t} else {\n\t\t\tstate.handler = state.stack.pop();\n\t\t}\n\t\treturn 'mw-link-end';\n\t}\n\n\tfunction parseLinkTrail(stream, state) {\n\t\tstream.match(/\\w*/);\n\t\tstate.handler = state.stack.pop();\n\t\treturn 'mw-link-trail';\n\t}\n\n\tfunction parseLinkPipe(stream, state) {\n\t\tstream.match('|');\n\t\tstate.handler = parseLinkText;\n\t\treturn 'mw-link-pipe';\n\t}\n\n\tfunction parseLinkText(stream, state) {\n\t\tif (stream.match(']]', false)) {\n\t\t\t// Maybe just return directly?\n\t\t\tstate.handler = parseLinkEnd;\n\t\t\treturn '';\n\t\t}\n\t\tvar ret = parseWikitext(stream, state);\n\t\treturn ret + ' mw-link-text';\n\t}\n\n\t// External link parsing\n\tfunction parseExternalLink(stream, state) {\n\t\tvar match = stream.match(EXT_LINK_URL);\n\t\tvar text = match[0];\n\n\t\t// {{, ~~~, '' will start their effect, so detect and correct\n\t\tvar match = new RegExp(\"\\\\{\\\\{|~~~|''\").exec(text);\n\t\tif (match) {\n\t\t\t// Pushback the wrongly included part\n\t\t\tstream.backUp(text.length - match.index);\n\t\t\ttext = text.substring(0, match.index);\n\t\t}\n\n\t\tstate.handler = parseExternalLinkText;\n\t\treturn 'mw-extlink-target';\n\t}\n\n\tfunction parseExternalLinkText(stream, state) {\n\t\tif (stream.eat(']')) {\n\t\t\tstate.handler = state.stack.pop();\n\t\t\treturn 'mw-extlink-end';\n\t\t}\n\t\tvar ret = parseWikitext(stream, state);\n\t\treturn ret + ' mw-link-text';\n\t}\n\n\t// Template\n\n\tfunction parseTemplateName(stream, state) {\n\t\tif (stream.eat('|')) {\n\t\t\tif (stream.match(/[^\\|\\{\\}]*=/, false)) {\n\t\t\t\tstate.handler = parseTemplateArgName;\n\t\t\t} else {\n\t\t\t\tstate.handler = parseTemplateArg;\n\t\t\t}\n\t\t\treturn 'mw-template-pipe';\n\t\t}\n\t\tif (stream.match('}}')) {\n\t\t\tstate.handler = state.stack.pop();\n\t\t\treturn 'mw-template-end';\n\t\t}\n\t\tstream.next();\n\t\treturn 'mw-template-name';\n\t}\n\n\tfunction parseTemplateArg(stream, state) {\n\t\tif (stream.eat('|')) {\n\t\t\tif (stream.match(/[^\\|\\{\\}]*=/, false)) {\n\t\t\t\tstate.handler = parseTemplateArgName;\n\t\t\t}\n\t\t\treturn 'mw-template-pipe';\n\t\t}\n\t\tif (stream.match('}}')) {\n\t\t\tstate.handler = state.stack.pop();\n\t\t\treturn 'mw-template-end';\n\t\t}\n\t\tvar ret = parseWikitext(stream, state);\n\t\treturn ret + ' mw-template-arg';\n\t}\n\n\tfunction parseTemplateArgName(stream, state) {\n\t\tif (stream.eat('=')) {\n\t\t\tstate.handler = parseTemplateArg;\n\t\t\treturn 'mw-template-assign';\n\t\t}\n\t\t// The below two cases are rare cases, where simple regex for detecting = fails\n\t\tif (stream.eat('|')) {\n\t\t\tif (!stream.match(/[^\\|\\{\\}]*=/, false)) {\n\t\t\t\tstate.handler = parseTemplateArg;\n\t\t\t}\n\t\t\treturn 'mw-template-pipe';\n\t\t}\n\t\tif (stream.match('}}')) {\n\t\t\tstate.handler = state.stack.pop();\n\t\t\treturn 'mw-template-end';\n\t\t}\n\t\tvar ret = parseWikitext(stream, state);\n\t\treturn ret + ' mw-template-argname';\n\t}\n\n\t// Tag handlers\n\n\tfunction parseNowikiTag(stream, state) {\n\t\tif (stream.match(/<\\/nowiki\\s*>/)) {\n\t\t\tstate.handler = state.stack.pop();\n\t\t\treturn 'mw-tag-close';\n\t\t}\n\t\treturn parseEntityOnly(stream, state);\n\t}\n\n\tfunction parsePreTag(stream, state) {\n\t\tif (stream.match(/<\\/pre\\s*>/)) {\n\t\t\tstate.handler = state.stack.pop();\n\t\t\tarrayRemove(state.mixinStyle, 'mw-pre');\n\t\t\treturn 'mw-tag-close';\n\t\t}\n\t\treturn parseEntityOnly(stream, state);\n\t}\n\n\tmodule.startState = function() {\n\t\treturn {\n\t\t\thandler: parseWikitext,\n\t\t\tbold: false,\n\t\t\titalic: false,\n\t\t\tmixinStyle: [],\n\t\t\tunclosedTags: [],\n\t\t\tstack: []\n\t\t};\n\t};\n\n\tmodule.copyState = function(state) {\n\t\treturn {\n\t\t\thandler: state.handler,\n\t\t\tbold: state.bold,\n\t\t\titalic: state.italic,\n\t\t\tmixinStyle: state.mixinStyle.slice(),\n\t\t\tunclosedTags: state.unclosedTags.slice(),\n\t\t\tstack: state.stack.slice()\n\t\t}\n\t};\n\n\tmodule.token = function(stream, state) {\n\t\tif (stream.sol()) {\n\t\t\tstate.bold = false;\n\t\t\tstate.italic = false;\n\t\t}\n\t\ttry {\n\t\t\treturn state.handler(stream, state);\n\t\t} catch (e) {\n\t\t\tstream.next();\n\t\t\tstate.handler = parseWikitext;\n\t\t\tconsole.error('Error in WikiHighlight', e.stack || e);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn module;\n});\n\n$(function() {\n\tvar target = $('#wpTextbox1');\n\tif(target.length) {\n\t\tvar cm = CodeMirror.fromTextArea(target[0], {\n\t\t\tlineNumbers: true,\n\t\t\tlineWrapping: true,\n\t\t\tmode: 'mediawiki'\n\t\t});\n\t\tcm.on('change', function () {\n\t\t\ttarget.trigger('input');\n\t\t});\n\t\t$.valHooks['textarea'] = {\n\t\t\tget: function(elem){ if(elem === target[0]) return cm.getValue(); else return elem.value; },\n\t\t\tset: function(elem, value){ if(elem === target[0]) cm.setValue(value); else elem.value = value; }\n\t\t};\n\t\tvar origTextSelection = $.fn.textSelection;\n\t\t$.fn.textSelection = function(command, options) {\n\t\t\tif (cm.getTextArea() !== this[0]) {\n\t\t\t\treturn origTextSelection.call(this, command, options);\n\t\t\t}\n\t\t\tvar fn, retval;\n\t\t\n\t\t\tfn = {\n\t\t\t\t/**\n\t\t\t\t * Get the contents of the textarea\n\t\t\t\t */\n\t\t\t\tgetContents: function() {\n\t\t\t\t\treturn cm.doc.getValue();\n\t\t\t\t},\n\t\t\n\t\t\t\tsetContents: function(newContents) {\n\t\t\t\t\tcm.doc.setValue(newContents);\n\t\t\t\t},\n\t\t\n\t\t\t\t/**\n\t\t\t\t * Get the currently selected text in this textarea. Will focus the textarea\n\t\t\t\t * in some browsers (IE/Opera)\n\t\t\t\t */\n\t\t\t\tgetSelection: function() {\n\t\t\t\t\treturn cm.doc.getSelection();\n\t\t\t\t},\n\t\t\n\t\t\t\t/**\n\t\t\t\t * Inserts text at the beginning and end of a text selection, optionally\n\t\t\t\t * inserting text at the caret when selection is empty.\n\t\t\t\t */\n\t\t\t\tencapsulateSelection: function(options) {\n\t\t\t\t\treturn this.each(function() {\n\t\t\t\t\t\tvar insertText,\n\t\t\t\t\t\t\tselText,\n\t\t\t\t\t\t\tselectPeri = options.selectPeri,\n\t\t\t\t\t\t\tpre = options.pre,\n\t\t\t\t\t\t\tpost = options.post,\n\t\t\t\t\t\t\tstartCursor = cm.doc.getCursor(true),\n\t\t\t\t\t\t\tendCursor = cm.doc.getCursor(false);\n\t\t\n\t\t\t\t\t\tif (options.selectionStart !== undefined) {\n\t\t\t\t\t\t\t// fn[command].call( this, options );\n\t\t\t\t\t\t\tfn.setSelection({\n\t\t\t\t\t\t\t\tstart: options.selectionStart,\n\t\t\t\t\t\t\t\tend: options.selectionEnd\n\t\t\t\t\t\t\t}); // not tested\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\tselText = cm.doc.getSelection();\n\t\t\t\t\t\tif (!selText) {\n\t\t\t\t\t\t\tselText = options.peri;\n\t\t\t\t\t\t} else if (options.replace) {\n\t\t\t\t\t\t\tselectPeri = false;\n\t\t\t\t\t\t\tselText = options.peri;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselectPeri = false;\n\t\t\t\t\t\t\twhile (selText.charAt(selText.length - 1) === ' ') {\n\t\t\t\t\t\t\t\t// Exclude ending space char\n\t\t\t\t\t\t\t\tselText = selText.substring(0, selText.length - 1);\n\t\t\t\t\t\t\t\tpost += ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (selText.charAt(0) === ' ') {\n\t\t\t\t\t\t\t\t// Exclude prepending space char\n\t\t\t\t\t\t\t\tselText = selText.substring(1, selText.length);\n\t\t\t\t\t\t\t\tpre = ' ' + pre;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Do the splitlines stuff.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Wrap each line of the selected text with pre and post\n\t\t\t\t\t\t */\n\t\t\t\t\t\tfunction doSplitLines(selText, pre, post) {\n\t\t\t\t\t\t\tvar i,\n\t\t\t\t\t\t\t\tinsertText = '',\n\t\t\t\t\t\t\t\tselTextArr = selText.split('\\n');\n\t\t\n\t\t\t\t\t\t\tfor (i = 0; i < selTextArr.length; i++) {\n\t\t\t\t\t\t\t\tinsertText += pre + selTextArr[i] + post;\n\t\t\t\t\t\t\t\tif (i !== selTextArr.length - 1) {\n\t\t\t\t\t\t\t\t\tinsertText += '\\n';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn insertText;\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\tif (options.splitlines) {\n\t\t\t\t\t\t\tselectPeri = false;\n\t\t\t\t\t\t\tinsertText = doSplitLines(selText, pre, post);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinsertText = pre + selText + post;\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\tif (options.ownline) {\n\t\t\t\t\t\t\tif (startCursor.ch !== 0) {\n\t\t\t\t\t\t\t\tinsertText = '\\n' + insertText;\n\t\t\t\t\t\t\t\tpre += '\\n';\n\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\tif (cm.doc.getLine(endCursor.line).length !== endCursor.ch) {\n\t\t\t\t\t\t\t\tinsertText += '\\n';\n\t\t\t\t\t\t\t\tpost += '\\n';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\tcm.doc.replaceSelection(insertText);\n\t\t\n\t\t\t\t\t\tif (selectPeri) {\n\t\t\t\t\t\t\tcm.doc.setSelection(\n\t\t\t\t\t\t\t\tcm.doc.posFromIndex(cm.doc.indexFromPos(startCursor) + pre.length),\n\t\t\t\t\t\t\t\tcm.doc.posFromIndex(cm.doc.indexFromPos(startCursor) + pre.length + selText.length)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\n\t\t\t\t/**\n\t\t\t\t * Get the position (in resolution of bytes not necessarily characters)\n\t\t\t\t * in a textarea\n\t\t\t\t */\n\t\t\t\tgetCaretPosition: function(options) {\n\t\t\t\t\tvar caretPos = cm.doc.indexFromPos(cm.doc.getCursor(true)),\n\t\t\t\t\t\tendPos = cm.doc.indexFromPos(cm.doc.getCursor(false));\n\t\t\t\t\tif (options.startAndEnd) {\n\t\t\t\t\t\treturn [caretPos, endPos];\n\t\t\t\t\t}\n\t\t\t\t\treturn caretPos;\n\t\t\t\t},\n\t\t\n\t\t\t\tsetSelection: function(options) {\n\t\t\t\t\treturn this.each(function() {\n\t\t\t\t\t\tcm.doc.setSelection(cm.doc.posFromIndex(options.start), cm.doc.posFromIndex(options.end));\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\n\t\t\t\t/**\n\t\t\t\t * Scroll a textarea to the current cursor position. You can set the cursor\n\t\t\t\t * position with setSelection()\n\t\t\t\t */\n\t\t\t\tscrollToCaretPosition: function() {\n\t\t\t\t\treturn this.each(function() {\n\t\t\t\t\t\tcm.scrollIntoView(null);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\n\t\t\tswitch (command) {\n\t\t\t\t// case 'getContents': // no params\n\t\t\t\t// case 'setContents': // no params with defaults\n\t\t\t\t// case 'getSelection': // no params\n\t\t\t\tcase 'encapsulateSelection':\n\t\t\t\t\toptions = $.extend({\n\t\t\t\t\t\tpre: '', // Text to insert before the cursor/selection\n\t\t\t\t\t\tperi: '', // Text to insert between pre and post and select afterwards\n\t\t\t\t\t\tpost: '', // Text to insert after the cursor/selection\n\t\t\t\t\t\townline: false, // Put the inserted text on a line of its own\n\t\t\t\t\t\treplace: false, // If there is a selection, replace it with peri instead of leaving it alone\n\t\t\t\t\t\tselectPeri: true, // Select the peri text if it was inserted (but not if there was a selection and replace==false, or if splitlines==true)\n\t\t\t\t\t\tsplitlines: false, // If multiple lines are selected, encapsulate each line individually\n\t\t\t\t\t\tselectionStart: undefined, // Position to start selection at\n\t\t\t\t\t\tselectionEnd: undefined // Position to end selection at. Defaults to start\n\t\t\t\t\t}, options);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'getCaretPosition':\n\t\t\t\t\toptions = $.extend({\n\t\t\t\t\t\t// Return [start, end] instead of just start\n\t\t\t\t\t\tstartAndEnd: false\n\t\t\t\t\t}, options);\n\t\t\t\t\t// FIXME: We may not need character position-based functions if we insert markers in the right places\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'setSelection':\n\t\t\t\t\toptions = $.extend({\n\t\t\t\t\t\t// Position to start selection at\n\t\t\t\t\t\tstart: undefined,\n\t\t\t\t\t\t// Position to end selection at. Defaults to start\n\t\t\t\t\t\tend: undefined,\n\t\t\t\t\t\t// Element to start selection in (iframe only)\n\t\t\t\t\t\tstartContainer: undefined,\n\t\t\t\t\t\t// Element to end selection in (iframe only). Defaults to startContainer\n\t\t\t\t\t\tendContainer: undefined\n\t\t\t\t\t}, options);\n\t\t\n\t\t\t\t\tif (options.end === undefined) {\n\t\t\t\t\t\toptions.end = options.start;\n\t\t\t\t\t}\n\t\t\t\t\tif (options.endContainer === undefined) {\n\t\t\t\t\t\toptions.endContainer = options.startContainer;\n\t\t\t\t\t}\n\t\t\t\t\t// FIXME: We may not need character position-based functions if we insert markers in the right places\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scrollToCaretPosition':\n\t\t\t\t\toptions = $.extend({\n\t\t\t\t\t\tforce: false // Force a scroll even if the caret position is already visible\n\t\t\t\t\t}, options);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t\tretval = fn[command].call(this, options);\n\t\t\n\t\t\treturn retval;\n\t\t};\n\t};\n});\n//</pre>"}}}