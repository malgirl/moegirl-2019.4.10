{"parse":{"title":"\u6a21\u5757:Date","pageid":304026,"wikitext":{"*":"-- Date functions for use by other modules.\n-- I18N and time zones are not supported.\n\nlocal MINUS = '\u2212'  -- Unicode U+2212 MINUS SIGN\nlocal floor = math.floor\n\nlocal Date, DateDiff, diffmt  -- forward declarations\nlocal uniq = { 'unique identifier' }\n\nlocal function is_date(t)\n\t-- The system used to make a date read-only means there is no unique\n\t-- metatable that is conveniently accessible to check.\n\treturn type(t) == 'table' and t._id == uniq\nend\n\nlocal function is_diff(t)\n\treturn type(t) == 'table' and getmetatable(t) == diffmt\nend\n\nlocal function _list_join(list, sep)\n\treturn table.concat(list, sep)\nend\n\nlocal function collection()\n\t-- Return a table to hold items.\n\treturn {\n\t\tn = 0,\n\t\tadd = function (self, item)\n\t\t\tself.n = self.n + 1\n\t\t\tself[self.n] = item\n\t\tend,\n\t\tjoin = _list_join,\n\t}\nend\n\nlocal function strip_to_nil(text)\n\t-- If text is a string, return its trimmed content, or nil if empty.\n\t-- Otherwise return text (convenient when Date fields are provided from\n\t-- another module which may pass a string, a number, or another type).\n\tif type(text) == 'string' then\n\t\ttext = text:match('(%S.-)%s*$')\n\tend\n\treturn text\nend\n\nlocal function is_leap_year(year, calname)\n\t-- Return true if year is a leap year.\n\tif calname == 'Julian' then\n\t\treturn year % 4 == 0\n\tend\n\treturn (year % 4 == 0 and year % 100 ~= 0) or year % 400 == 0\nend\n\nlocal function days_in_month(year, month, calname)\n\t-- Return number of days (1..31) in given month (1..12).\n\tif month == 2 and is_leap_year(year, calname) then\n\t\treturn 29\n\tend\n\treturn ({ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })[month]\nend\n\nlocal function h_m_s(time)\n\t-- Return hour, minute, second extracted from fraction of a day.\n\ttime = floor(time * 24 * 3600 + 0.5)  -- number of seconds\n\tlocal second = time % 60\n\ttime = floor(time / 60)\n\treturn floor(time / 60), time % 60, second\nend\n\nlocal function hms(date)\n\t-- Return fraction of a day from date's time, where (0 <= fraction < 1)\n\t-- if the values are valid, but could be anything if outside range.\n\treturn (date.hour + (date.minute + date.second / 60) / 60) / 24\nend\n\nlocal function julian_date(date)\n\t-- Return jd, jdz from a Julian or Gregorian calendar date where\n\t--   jd = Julian date and its fractional part is zero at noon\n\t--   jdz = same, but assume time is 00:00:00 if no time given\n\t-- http://www.tondering.dk/claus/cal/julperiod.php#formula\n\t-- Testing shows this works for all dates from year -9999 to 9999!\n\t-- JDN 0 is the 24-hour period starting at noon UTC on Monday\n\t--    1 January 4713 BC  = (-4712, 1, 1)   Julian calendar\n\t--   24 November 4714 BC = (-4713, 11, 24) Gregorian calendar\n\tlocal offset\n\tlocal a = floor((14 - date.month)/12)\n\tlocal y = date.year + 4800 - a\n\tif date.calendar == 'Julian' then\n\t\toffset = floor(y/4) - 32083\n\telse\n\t\toffset = floor(y/4) - floor(y/100) + floor(y/400) - 32045\n\tend\n\tlocal m = date.month + 12*a - 3\n\tlocal jd = date.day + floor((153*m + 2)/5) + 365*y + offset\n\tif date.hastime then\n\t\tjd = jd + hms(date) - 0.5\n\t\treturn jd, jd\n\tend\n\treturn jd, jd - 0.5\nend\n\nlocal function set_date_from_jd(date)\n\t-- Set the fields of table date from its Julian date field.\n\t-- Return true if date is valid.\n\t-- http://www.tondering.dk/claus/cal/julperiod.php#formula\n\t-- This handles the proleptic Julian and Gregorian calendars.\n\t-- Negative Julian dates are not defined but they work.\n\tlocal calname = date.calendar\n\tlocal low, high  -- min/max limits for date ranges \u22129999-01-01 to 9999-12-31\n\tif calname == 'Gregorian' then\n\t\tlow, high = -1930999.5, 5373484.49999\n\telseif calname == 'Julian' then\n\t\tlow, high = -1931076.5, 5373557.49999\n\telse\n\t\treturn\n\tend\n\tlocal jd = date.jd\n\tif not (type(jd) == 'number' and low <= jd and jd <= high) then\n\t\treturn\n\tend\n\tlocal jdn = floor(jd)\n\tif date.hastime then\n\t\tlocal time = jd - jdn  -- 0 <= time < 1\n\t\tif time >= 0.5 then    -- if at or after midnight of next day\n\t\t\tjdn = jdn + 1\n\t\t\ttime = time - 0.5\n\t\telse\n\t\t\ttime = time + 0.5\n\t\tend\n\t\tdate.hour, date.minute, date.second = h_m_s(time)\n\telse\n\t\tdate.second = 0\n\t\tdate.minute = 0\n\t\tdate.hour = 0\n\tend\n\tlocal b, c\n\tif calname == 'Julian' then\n\t\tb = 0\n\t\tc = jdn + 32082\n\telse  -- Gregorian\n\t\tlocal a = jdn + 32044\n\t\tb = floor((4*a + 3)/146097)\n\t\tc = a - floor(146097*b/4)\n\tend\n\tlocal d = floor((4*c + 3)/1461)\n\tlocal e = c - floor(1461*d/4)\n\tlocal m = floor((5*e + 2)/153)\n\tdate.day = e - floor((153*m + 2)/5) + 1\n\tdate.month = m + 3 - 12*floor(m/10)\n\tdate.year = 100*b + d - 4800 + floor(m/10)\n\treturn true\nend\n\nlocal function fix_numbers(numbers, y, m, d, H, M, S, partial, hastime, calendar)\n\t-- Put the result of normalizing the given values in table numbers.\n\t-- The result will have valid m, d values if y is valid; caller checks y.\n\t-- The logic of PHP mktime is followed where m or d can be zero to mean\n\t-- the previous unit, and -1 is the one before that, etc.\n\t-- Positive values carry forward.\n\tlocal date\n\tif not (1 <= m and m <= 12) then\n\t\tdate = Date(y, 1, 1)\n\t\tif not date then return end\n\t\tdate = date + ((m - 1) .. 'm')\n\t\ty, m = date.year, date.month\n\tend\n\tlocal days_hms\n\tif not partial then\n\t\tif hastime and H and M and S then\n\t\t\tif not (0 <= H and H <= 23 and\n\t\t\t\t\t0 <= M and M <= 59 and\n\t\t\t\t\t0 <= S and S <= 59) then\n\t\t\t\tdays_hms = hms({ hour = H, minute = M, second = S })\n\t\t\tend\n\t\tend\n\t\tif days_hms or not (1 <= d and d <= days_in_month(y, m, calendar)) then\n\t\t\tdate = date or Date(y, m, 1)\n\t\t\tif not date then return end\n\t\t\tdate = date + (d - 1 + (days_hms or 0))\n\t\t\ty, m, d = date.year, date.month, date.day\n\t\t\tif days_hms then\n\t\t\t\tH, M, S = date.hour, date.minute, date.second\n\t\t\tend\n\t\tend\n\tend\n\tnumbers.year = y\n\tnumbers.month = m\n\tnumbers.day = d\n\tif days_hms then\n\t\t-- Don't set H unless it was valid because a valid H will set hastime.\n\t\tnumbers.hour = H\n\t\tnumbers.minute = M\n\t\tnumbers.second = S\n\tend\nend\n\nlocal function set_date_from_numbers(date, numbers, options)\n\t-- Set the fields of table date from numeric values.\n\t-- Return true if date is valid.\n\tif type(numbers) ~= 'table' then\n\t\treturn\n\tend\n\tlocal y = numbers.year   or date.year\n\tlocal m = numbers.month  or date.month\n\tlocal d = numbers.day    or date.day\n\tlocal H = numbers.hour\n\tlocal M = numbers.minute or date.minute or 0\n\tlocal S = numbers.second or date.second or 0\n\tlocal need_fix\n\tif y and m and d then\n\t\tdate.partial = nil\n\t\tif not (-9999 <= y and y <= 9999 and\n\t\t\t1 <= m and m <= 12 and\n\t\t\t1 <= d and d <= days_in_month(y, m, date.calendar)) then\n\t\t\t\tif not date.want_fix then\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\t\tneed_fix = true\n\t\tend\n\telseif y and date.partial then\n\t\tif d or not (-9999 <= y and y <= 9999) then\n\t\t\treturn\n\t\tend\n\t\tif m and not (1 <= m and m <= 12) then\n\t\t\tif not date.want_fix then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tneed_fix = true\n\t\tend\n\telse\n\t\treturn\n\tend\n\tif date.partial then\n\t\tH = nil  -- ignore any time\n\t\tM = nil\n\t\tS = nil\n\telse\n\t\tif H then\n\t\t\t-- It is not possible to set M or S without also setting H.\n\t\t\tdate.hastime = true\n\t\telse\n\t\t\tH = 0\n\t\tend\n\t\tif not (0 <= H and H <= 23 and\n\t\t\t\t0 <= M and M <= 59 and\n\t\t\t\t0 <= S and S <= 59) then\n\t\t\tif date.want_fix then\n\t\t\t\tneed_fix = true\n\t\t\telse\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\tend\n\tdate.want_fix = nil\n\tif need_fix then\n\t\tfix_numbers(numbers, y, m, d, H, M, S, date.partial, date.hastime, date.calendar)\n\t\treturn set_date_from_numbers(date, numbers, options)\n\tend\n\tdate.year = y    -- -9999 to 9999 ('n BC' \u2192 year = 1 - n)\n\tdate.month = m   -- 1 to 12 (may be nil if partial)\n\tdate.day = d     -- 1 to 31 (* = nil if partial)\n\tdate.hour = H    -- 0 to 59 (*)\n\tdate.minute = M  -- 0 to 59 (*)\n\tdate.second = S  -- 0 to 59 (*)\n\tif type(options) == 'table' then\n\t\tfor _, k in ipairs({ 'am', 'era', 'format' }) do\n\t\t\tif options[k] then\n\t\t\t\tdate.options[k] = options[k]\n\t\t\tend\n\t\tend\n\tend\n\treturn true\nend\n\nlocal function make_option_table(options1, options2)\n\t-- If options1 is a string, return a table with its settings, or\n\t-- if it is a table, use its settings.\n\t-- Missing options are set from table options2 or defaults.\n\t-- If a default is used, a flag is set so caller knows the value was not intentionally set.\n\t-- Valid option settings are:\n\t-- am: 'am', 'a.m.', 'AM', 'A.M.'\n\t--     'pm', 'p.m.', 'PM', 'P.M.' (each has same meaning as corresponding item above)\n\t-- era: 'BCMINUS', 'BCNEGATIVE', 'BC', 'B.C.', 'BCE', 'B.C.E.', 'AD', 'A.D.', 'CE', 'C.E.'\n\t-- Option am = 'am' does not mean the hour is AM; it means 'am' or 'pm' is used, depending on the hour,\n\t--    and am = 'pm' has the same meaning.\n\t-- Similarly, era = 'BC' means 'BC' is used if year <= 0.\n\t-- BCMINUS displays a MINUS if year < 0 and the display format does not include %{era}.\n\t-- BCNEGATIVE is similar but displays a hyphen.\n\tlocal result = { bydefault = {} }\n\tif type(options1) == 'table' then\n\t\tresult.am = options1.am\n\t\tresult.era = options1.era\n\telseif type(options1) == 'string' then\n\t\t-- Example: 'am:AM era:BC' or 'am=AM era=BC'.\n\t\tfor item in options1:gmatch('%S+') do\n\t\t\tlocal lhs, rhs = item:match('^(%w+)[:=](.+)$')\n\t\t\tif lhs then\n\t\t\t\tresult[lhs] = rhs\n\t\t\tend\n\t\tend\n\tend\n\toptions2 = type(options2) == 'table' and options2 or {}\n\tlocal defaults = { am = 'am', era = 'BC' }\n\tfor k, v in pairs(defaults) do\n\t\tif not result[k] then\n\t\t\tif options2[k] then\n\t\t\t\tresult[k] = options2[k]\n\t\t\telse\n\t\t\t\tresult[k] = v\n\t\t\t\tresult.bydefault[k] = true\n\t\t\tend\n\t\tend\n\tend\n\treturn result\nend\n\nlocal ampm_options = {\n\t-- lhs = input text accepted as an am/pm option\n\t-- rhs = code used internally\n\t['am']   = 'am',\n\t['AM']   = 'AM',\n\t['a.m.'] = 'a.m.',\n\t['A.M.'] = 'A.M.',\n\t['pm']   = 'am',  -- same as am\n\t['PM']   = 'AM',\n\t['p.m.'] = 'a.m.',\n\t['P.M.'] = 'A.M.',\n}\n\nlocal era_text = {\n\t-- Text for displaying an era with a positive year (after adjusting\n\t-- by replacing year with 1 - year if date.year <= 0).\n\t-- options.era = { year<=0 , year>0 }\n\t['BCMINUS']    = { 'BC'    , ''    , isbc = true, sign = MINUS },\n\t['BCNEGATIVE'] = { 'BC'    , ''    , isbc = true, sign = '-'   },\n\t['BC']         = { 'BC'    , ''    , isbc = true },\n\t['B.C.']       = { 'B.C.'  , ''    , isbc = true },\n\t['BCE']        = { 'BCE'   , ''    , isbc = true },\n\t['B.C.E.']     = { 'B.C.E.', ''    , isbc = true },\n\t['AD']         = { 'BC'    , 'AD'   },\n\t['A.D.']       = { 'B.C.'  , 'A.D.' },\n\t['CE']         = { 'BCE'   , 'CE'   },\n\t['C.E.']       = { 'B.C.E.', 'C.E.' },\n}\n\nlocal function get_era_for_year(era, year)\n\treturn (era_text[era] or era_text['BC'])[year > 0 and 2 or 1] or ''\nend\n\nlocal function strftime(date, format, options)\n\t-- Return date formatted as a string using codes similar to those\n\t-- in the C strftime library function.\n\tlocal sformat = string.format\n\tlocal shortcuts = {\n\t\t['%c'] = '%-I:%M %p %-d %B %-Y %{era}',  -- date and time: 2:30 pm 1 April 2016\n\t\t['%x'] = '%-d %B %-Y %{era}',            -- date:          1 April 2016\n\t\t['%X'] = '%-I:%M %p',                    -- time:          2:30 pm\n\t}\n\tif shortcuts[format] then\n\t\tformat = shortcuts[format]\n\tend\n\tlocal codes = {\n\t\ta = { field = 'dayabbr' },\n\t\tA = { field = 'dayname' },\n\t\tb = { field = 'monthabbr' },\n\t\tB = { field = 'monthname' },\n\t\tu = { fmt = '%d'  , field = 'dowiso' },\n\t\tw = { fmt = '%d'  , field = 'dow' },\n\t\td = { fmt = '%02d', fmt2 = '%d', field = 'day' },\n\t\tm = { fmt = '%02d', fmt2 = '%d', field = 'month' },\n\t\tY = { fmt = '%04d', fmt2 = '%d', field = 'year' },\n\t\tH = { fmt = '%02d', fmt2 = '%d', field = 'hour' },\n\t\tM = { fmt = '%02d', fmt2 = '%d', field = 'minute' },\n\t\tS = { fmt = '%02d', fmt2 = '%d', field = 'second' },\n\t\tj = { fmt = '%03d', fmt2 = '%d', field = 'dayofyear' },\n\t\tI = { fmt = '%02d', fmt2 = '%d', field = 'hour', special = 'hour12' },\n\t\tp = { field = 'hour', special = 'am' },\n\t}\n\toptions = make_option_table(options, date.options)\n\tlocal amopt = options.am\n\tlocal eraopt = options.era\n\tlocal function replace_code(spaces, modifier, id)\n\t\tlocal code = codes[id]\n\t\tif code then\n\t\t\tlocal fmt = code.fmt\n\t\t\tif modifier == '-' and code.fmt2 then\n\t\t\t\tfmt = code.fmt2\n\t\t\tend\n\t\t\tlocal value = date[code.field]\n\t\t\tif not value then\n\t\t\t\treturn nil  -- an undefined field in a partial date\n\t\t\tend\n\t\t\tlocal special = code.special\n\t\t\tif special then\n\t\t\t\tif special == 'hour12' then\n\t\t\t\t\tvalue = value % 12\n\t\t\t\t\tvalue = value == 0 and 12 or value\n\t\t\t\telseif special == 'am' then\n\t\t\t\t\tlocal ap = ({\n\t\t\t\t\t\t['a.m.'] = { 'a.m.', 'p.m.' },\n\t\t\t\t\t\t['AM'] = { 'AM', 'PM' },\n\t\t\t\t\t\t['A.M.'] = { 'A.M.', 'P.M.' },\n\t\t\t\t\t})[ampm_options[amopt]] or { 'am', 'pm' }\n\t\t\t\t\treturn (spaces == '' and '' or '&nbsp;') .. (value < 12 and ap[1] or ap[2])\n\t\t\t\tend\n\t\t\tend\n\t\t\tif code.field == 'year' then\n\t\t\t\tlocal sign = (era_text[eraopt] or {}).sign\n\t\t\t\tif not sign or format:find('%{era}', 1, true) then\n\t\t\t\t\tsign = ''\n\t\t\t\t\tif value <= 0 then\n\t\t\t\t\t\tvalue = 1 - value\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tif value >= 0 then\n\t\t\t\t\t\tsign = ''\n\t\t\t\t\telse\n\t\t\t\t\t\tvalue = -value\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\treturn spaces .. sign .. sformat(fmt, value)\n\t\t\tend\n\t\t\treturn spaces .. (fmt and sformat(fmt, value) or value)\n\t\tend\n\tend\n\tlocal function replace_property(spaces, id)\n\t\tif id == 'era' then\n\t\t\t-- Special case so can use local era option.\n\t\t\tlocal result = get_era_for_year(eraopt, date.year)\n\t\t\tif result == '' then\n\t\t\t\treturn ''\n\t\t\tend\n\t\t\treturn (spaces == '' and '' or '&nbsp;') .. result\n\t\tend\n\t\tlocal result = date[id]\n\t\tif type(result) == 'string' then\n\t\t\treturn spaces .. result\n\t\tend\n\t\tif type(result) == 'number' then\n\t\t\treturn  spaces .. tostring(result)\n\t\tend\n\t\tif type(result) == 'boolean' then\n\t\t\treturn  spaces .. (result and '1' or '0')\n\t\tend\n\t\t-- This occurs if id is an undefined field in a partial date, or is the name of a function.\n\t\treturn nil\n\tend\n\tlocal PERCENT = '\\127PERCENT\\127'\n\treturn (format\n\t\t:gsub('%%%%', PERCENT)\n\t\t:gsub('(%s*)%%{(%w+)}', replace_property)\n\t\t:gsub('(%s*)%%(%-?)(%a)', replace_code)\n\t\t:gsub(PERCENT, '%%')\n\t)\nend\n\nlocal function _date_text(date, fmt, options)\n\t-- Return a formatted string representing the given date.\n\tif not is_date(date) then\n\t\terror('date:text: need a date (use \"date:text()\" with a colon)', 2)\n\tend\n\tif type(fmt) == 'string' and fmt:match('%S') then\n\t\tif fmt:find('%', 1, true) then\n\t\t\treturn strftime(date, fmt, options)\n\t\tend\n\telseif date.partial then\n\t\tfmt = date.month and 'my' or 'y'\n\telse\n\t\tfmt = 'dmy'\n\t\tif date.hastime then\n\t\t\tfmt = (date.second > 0 and 'hms ' or 'hm ') .. fmt\n\t\tend\n\tend\n\tlocal function bad_format()\n\t\t-- For consistency with other format processing, return given format\n\t\t-- (or cleaned format if original was not a string) if invalid.\n\t\treturn mw.text.nowiki(fmt)\n\tend\n\tif date.partial then\n\t\t-- Ignore days in standard formats like 'ymd'.\n\t\tif fmt == 'ym' or fmt == 'ymd' then\n\t\t\tfmt = date.month and '%Y-%m %{era}' or '%Y %{era}'\n\t\telseif fmt == 'my' or fmt == 'dmy' or fmt == 'mdy' then\n\t\t\tfmt = date.month and '%B %-Y %{era}' or '%-Y %{era}'\n\t\telseif fmt == 'y' then\n\t\t\tfmt = date.month and '%-Y %{era}' or '%-Y %{era}'\n\t\telse\n\t\t\treturn bad_format()\n\t\tend\n\t\treturn strftime(date, fmt, options)\n\tend\n\tlocal function hm_fmt()\n\t\tlocal plain = make_option_table(options, date.options).bydefault.am\n\t\treturn plain and '%H:%M' or '%-I:%M %p'\n\tend\n\tlocal need_time = date.hastime\n\tlocal t = collection()\n\tfor item in fmt:gmatch('%S+') do\n\t\tlocal f\n\t\tif item == 'hm' then\n\t\t\tf = hm_fmt()\n\t\t\tneed_time = false\n\t\telseif item == 'hms' then\n\t\t\tf = '%H:%M:%S'\n\t\t\tneed_time = false\n\t\telseif item == 'ymd' then\n\t\t\tf = '%Y-%m-%d %{era}'\n\t\telseif item == 'mdy' then\n\t\t\tf = '%B %-d, %-Y %{era}'\n\t\telseif item == 'dmy' then\n\t\t\tf = '%-d %B %-Y %{era}'\n\t\telse\n\t\t\treturn bad_format()\n\t\tend\n\t\tt:add(f)\n\tend\n\tfmt = t:join(' ')\n\tif need_time then\n\t\tfmt = hm_fmt() .. ' ' .. fmt\n\tend\n\treturn strftime(date, fmt, options)\nend\n\nlocal day_info = {\n\t-- 0=Sun to 6=Sat\n\t[0] = { 'Sun', 'Sunday' },\n\t{ 'Mon', 'Monday' },\n\t{ 'Tue', 'Tuesday' },\n\t{ 'Wed', 'Wednesday' },\n\t{ 'Thu', 'Thursday' },\n\t{ 'Fri', 'Friday' },\n\t{ 'Sat', 'Saturday' },\n}\n\nlocal month_info = {\n\t-- 1=Jan to 12=Dec\n\t{ 'Jan', 'January' },\n\t{ 'Feb', 'February' },\n\t{ 'Mar', 'March' },\n\t{ 'Apr', 'April' },\n\t{ 'May', 'May' },\n\t{ 'Jun', 'June' },\n\t{ 'Jul', 'July' },\n\t{ 'Aug', 'August' },\n\t{ 'Sep', 'September' },\n\t{ 'Oct', 'October' },\n\t{ 'Nov', 'November' },\n\t{ 'Dec', 'December' },\n}\n\nlocal function name_to_number(text, translate)\n\tif type(text) == 'string' then\n\t\treturn translate[text:lower()]\n\tend\nend\n\nlocal function day_number(text)\n\treturn name_to_number(text, {\n\t\tsun = 0, sunday = 0,\n\t\tmon = 1, monday = 1,\n\t\ttue = 2, tuesday = 2,\n\t\twed = 3, wednesday = 3,\n\t\tthu = 4, thursday = 4,\n\t\tfri = 5, friday = 5,\n\t\tsat = 6, saturday = 6,\n\t})\nend\n\nlocal function month_number(text)\n\treturn name_to_number(text, {\n\t\tjan = 1, january = 1,\n\t\tfeb = 2, february = 2,\n\t\tmar = 3, march = 3,\n\t\tapr = 4, april = 4,\n\t\tmay = 5,\n\t\tjun = 6, june = 6,\n\t\tjul = 7, july = 7,\n\t\taug = 8, august = 8,\n\t\tsep = 9, september = 9, sept = 9,\n\t\toct = 10, october = 10,\n\t\tnov = 11, november = 11,\n\t\tdec = 12, december = 12,\n\t})\nend\n\nlocal function _list_text(list, fmt)\n\t-- Return a list of formatted strings from a list of dates.\n\tif not type(list) == 'table' then\n\t\terror('date:list:text: need \"list:text()\" with a colon', 2)\n\tend\n\tlocal result = { join = _list_join }\n\tfor i, date in ipairs(list) do\n\t\tresult[i] = date:text(fmt)\n\tend\n\treturn result\nend\n\nlocal function _date_list(date, spec)\n\t-- Return a possibly empty numbered table of dates meeting the specification.\n\t-- Dates in the list are in ascending order (oldest date first).\n\t-- The spec should be a string of form \"<count> <day> <op>\"\n\t-- where each item is optional and\n\t--   count = number of items wanted in list\n\t--   day = abbreviation or name such as Mon or Monday\n\t--   op = >, >=, <, <= (default is > meaning after date)\n\t-- If no count is given, the list is for the specified days in date's month.\n\t-- The default day is date's day.\n\t-- The spec can also be a positive or negative number:\n\t--   -5 is equivalent to '5 <'\n\t--   5  is equivalent to '5' which is '5 >'\n\tif not is_date(date) then\n\t\terror('date:list: need a date (use \"date:list()\" with a colon)', 2)\n\tend\n\tlocal list = { text = _list_text }\n\tif date.partial then\n\t\treturn list\n\tend\n\tlocal count, offset, operation\n\tlocal ops = {\n\t\t['>='] = { before = false, include = true  },\n\t\t['>']  = { before = false, include = false },\n\t\t['<='] = { before = true , include = true  },\n\t\t['<']  = { before = true , include = false },\n\t}\n\tif spec then\n\t\tif type(spec) == 'number' then\n\t\t\tcount = floor(spec + 0.5)\n\t\t\tif count < 0 then\n\t\t\t\tcount = -count\n\t\t\t\toperation = ops['<']\n\t\t\tend\n\t\telseif type(spec) == 'string' then\n\t\t\tlocal num, day, op = spec:match('^%s*(%d*)%s*(%a*)%s*([<>=]*)%s*$')\n\t\t\tif not num then\n\t\t\t\treturn list\n\t\t\tend\n\t\t\tif num ~= '' then\n\t\t\t\tcount = tonumber(num)\n\t\t\tend\n\t\t\tif day ~= '' then\n\t\t\t\tlocal dow = day_number(day:gsub('[sS]$', ''))  -- accept plural days\n\t\t\t\tif not dow then\n\t\t\t\t\treturn list\n\t\t\t\tend\n\t\t\t\toffset = dow - date.dow\n\t\t\tend\n\t\t\toperation = ops[op]\n\t\telse\n\t\t\treturn list\n\t\tend\n\tend\n\toffset = offset or 0\n\toperation = operation or ops['>']\n\tlocal datefrom, dayfirst, daylast\n\tif operation.before then\n\t\tif offset > 0 or (offset == 0 and not operation.include) then\n\t\t\toffset = offset - 7\n\t\tend\n\t\tif count then\n\t\t\tif count > 1 then\n\t\t\t\toffset = offset - 7*(count - 1)\n\t\t\tend\n\t\t\tdatefrom = date + offset\n\t\telse\n\t\t\tdaylast = date.day + offset\n\t\t\tdayfirst = daylast % 7\n\t\t\tif dayfirst == 0 then\n\t\t\t\tdayfirst = 7\n\t\t\tend\n\t\tend\n\telse\n\t\tif offset < 0 or (offset == 0 and not operation.include) then\n\t\t\toffset = offset + 7\n\t\tend\n\t\tif count then\n\t\t\tdatefrom = date + offset\n\t\telse\n\t\t\tdayfirst = date.day + offset\n\t\t\tdaylast = date.monthdays\n\t\tend\n\tend\n\tif not count then\n\t\tif daylast < dayfirst then\n\t\t\treturn list\n\t\tend\n\t\tcount = floor((daylast - dayfirst)/7) + 1\n\t\tdatefrom = Date(date, {day = dayfirst})\n\tend\n\tfor i = 1, count do\n\t\tif not datefrom then break end  -- exceeds date limits\n\t\tlist[i] = datefrom\n\t\tdatefrom = datefrom + 7\n\tend\n\treturn list\nend\n\n-- A table to get the current date/time (UTC), but only if needed.\nlocal current = setmetatable({}, {\n\t__index = function (self, key)\n\t\tlocal d = os.date('!*t')\n\t\tself.year = d.year\n\t\tself.month = d.month\n\t\tself.day = d.day\n\t\tself.hour = d.hour\n\t\tself.minute = d.min\n\t\tself.second = d.sec\n\t\treturn rawget(self, key)\n\tend })\n\nlocal function extract_date(newdate, text)\n\t-- Parse the date/time in text and return n, o where\n\t--   n = table of numbers with date/time fields\n\t--   o = table of options for AM/PM or AD/BC or format, if any\n\t-- or return nothing if date is known to be invalid.\n\t-- Caller determines if the values in n are valid.\n\t-- A year must be positive ('1' to '9999'); use 'BC' for BC.\n\t-- In a y-m-d string, the year must be four digits to avoid ambiguity\n\t-- ('0001' to '9999'). The only way to enter year <= 0 is by specifying\n\t-- the date as three numeric parameters like ymd Date(-1, 1, 1).\n\t-- Dates of form d/m/y, m/d/y, y/m/d are rejected as potentially ambiguous.\n\tlocal date, options = {}, {}\n\tif text:sub(-1) == 'Z' then\n\t\t-- Extract date/time from a Wikidata timestamp.\n\t\t-- The year can be 1 to 16 digits but this module handles 1 to 4 digits only.\n\t\t-- Examples: '+2016-06-21T14:30:00Z', '-0000000180-00-00T00:00:00Z'.\n\t\tlocal sign, y, m, d, H, M, S = text:match('^([+%-])(%d+)%-(%d%d)%-(%d%d)T(%d%d):(%d%d):(%d%d)Z$')\n\t\tif sign then\n\t\t\ty = tonumber(y)\n\t\t\tif sign == '-' and y > 0 then\n\t\t\t\ty = -y\n\t\t\tend\n\t\t\tif y <= 0 then\n\t\t\t\toptions.era = 'BCE'\n\t\t\tend\n\t\t\tdate.year = y\n\t\t\tm = tonumber(m)\n\t\t\td = tonumber(d)\n\t\t\tH = tonumber(H)\n\t\t\tM = tonumber(M)\n\t\t\tS = tonumber(S)\n\t\t\tif m == 0 then\n\t\t\t\tnewdate.partial = true\n\t\t\t\treturn date, options\n\t\t\tend\n\t\t\tdate.month = m\n\t\t\tif d == 0 then\n\t\t\t\tnewdate.partial = true\n\t\t\t\treturn date, options\n\t\t\tend\n\t\t\tdate.day = d\n\t\t\tif H > 0 or M > 0 or S > 0 then\n\t\t\t\tdate.hour = H\n\t\t\t\tdate.minute = M\n\t\t\t\tdate.second = S\n\t\t\tend\n\t\t\treturn date, options\n\t\tend\n\t\treturn\n\tend\n\tlocal function extract_ymd(item)\n\t\t-- Called when no day or month has been set.\n\t\tlocal y, m, d = item:match('^(%d%d%d%d)%-(%w+)%-(%d%d?)$')\n\t\tif y then\n\t\t\tif date.year then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tif m:match('^%d%d?$') then\n\t\t\t\tm = tonumber(m)\n\t\t\telse\n\t\t\t\tm = month_number(m)\n\t\t\tend\n\t\t\tif m then\n\t\t\t\tdate.year = tonumber(y)\n\t\t\t\tdate.month = m\n\t\t\t\tdate.day = tonumber(d)\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\tlocal function extract_day_or_year(item)\n\t\t-- Called when a day would be valid, or\n\t\t-- when a year would be valid if no year has been set and partial is set.\n\t\tlocal number, suffix = item:match('^(%d%d?%d?%d?)(.*)$')\n\t\tif number then\n\t\t\tlocal n = tonumber(number)\n\t\t\tif #number <= 2 and n <= 31 then\n\t\t\t\tsuffix = suffix:lower()\n\t\t\t\tif suffix == '' or suffix == 'st' or suffix == 'nd' or suffix == 'rd' or suffix == 'th' then\n\t\t\t\t\tdate.day = n\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\telseif suffix == '' and newdate.partial and not date.year then\n\t\t\t\tdate.year = n\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\tlocal function extract_month(item)\n\t\t-- A month must be given as a name or abbreviation; a number could be ambiguous.\n\t\tlocal m = month_number(item)\n\t\tif m then\n\t\t\tdate.month = m\n\t\t\treturn true\n\t\tend\n\tend\n\tlocal function extract_time(item)\n\t\tlocal h, m, s = item:match('^(%d%d?):(%d%d)(:?%d*)$')\n\t\tif date.hour or not h then\n\t\t\treturn\n\t\tend\n\t\tif s ~= '' then\n\t\t\ts = s:match('^:(%d%d)$')\n\t\t\tif not s then\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\t\tdate.hour = tonumber(h)\n\t\tdate.minute = tonumber(m)\n\t\tdate.second = tonumber(s)  -- nil if empty string\n\t\treturn true\n\tend\n\tlocal item_count = 0\n\tlocal index_time\n\tlocal function set_ampm(item)\n\t\tlocal H = date.hour\n\t\tif H and not options.am and index_time + 1 == item_count then\n\t\t\toptions.am = ampm_options[item]  -- caller checked this is not nil\n\t\t\tif item:match('^[Aa]') then\n\t\t\t\tif not (1 <= H and H <= 12) then\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\t\tif H == 12 then\n\t\t\t\t\tdate.hour = 0\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif not (1 <= H and H <= 23) then\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\t\tif H <= 11 then\n\t\t\t\t\tdate.hour = H + 12\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\tend\n\tfor item in text:gsub(',', ' '):gsub('&nbsp;', ' '):gmatch('%S+') do\n\t\titem_count = item_count + 1\n\t\tif era_text[item] then\n\t\t\t-- Era is accepted in peculiar places.\n\t\t\tif options.era then\n\t\t\t\treturn\n\t\t\tend\n\t\t\toptions.era = item\n\t\telseif ampm_options[item] then\n\t\t\tif not set_ampm(item) then\n\t\t\t\treturn\n\t\t\tend\n\t\telseif item:find(':', 1, true) then\n\t\t\tif not extract_time(item) then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tindex_time = item_count\n\t\telseif date.day and date.month then\n\t\t\tif date.year then\n\t\t\t\treturn  -- should be nothing more so item is invalid\n\t\t\tend\n\t\t\tif not item:match('^(%d%d?%d?%d?)$') then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tdate.year = tonumber(item)\n\t\telseif date.day then\n\t\t\tif not extract_month(item) then\n\t\t\t\treturn\n\t\t\tend\n\t\telseif date.month then\n\t\t\tif not extract_day_or_year(item) then\n\t\t\t\treturn\n\t\t\tend\n\t\telseif extract_month(item) then\n\t\t\toptions.format = 'mdy'\n\t\telseif extract_ymd(item) then\n\t\t\toptions.format = 'ymd'\n\t\telseif extract_day_or_year(item) then\n\t\t\tif date.day then\n\t\t\t\toptions.format = 'dmy'\n\t\t\tend\n\t\telse\n\t\t\treturn\n\t\tend\n\tend\n\tif not date.year or date.year == 0 then\n\t\treturn\n\tend\n\tlocal era = era_text[options.era]\n\tif era and era.isbc then\n\t\tdate.year = 1 - date.year\n\tend\n\treturn date, options\nend\n\nlocal function autofill(date1, date2)\n\t-- Fill any missing month or day in each date using the\n\t-- corresponding component from the other date, if present,\n\t-- or with 1 if both dates are missing the month or day.\n\t-- This gives a good result for calculating the difference\n\t-- between two partial dates when no range is wanted.\n\t-- Return filled date1, date2 (two full dates).\n\tlocal function filled(a, b)\n\t\tlocal fillmonth, fillday\n\t\tif not a.month then\n\t\t\tfillmonth = b.month or 1\n\t\tend\n\t\tif not a.day then\n\t\t\tfillday = b.day or 1\n\t\tend\n\t\tif fillmonth or fillday then  -- need to create a new date\n\t\t\ta = Date(a, { month = fillmonth, day = fillday })\n\t\tend\n\t\treturn a\n\tend\n\treturn filled(date1, date2), filled(date2, date1)\nend\n\nlocal function date_add_sub(lhs, rhs, is_sub)\n\t-- Return a new date from calculating (lhs + rhs) or (lhs - rhs),\n\t-- or return nothing if invalid.\n\t-- The result is nil if the calculated date exceeds allowable limits.\n\t-- Caller ensures that lhs is a date; its properties are copied for the new date.\n\tif lhs.partial then\n\t\t-- Adding to a partial is not supported.\n\t\t-- Can subtract a date or partial from a partial, but this is not called for that.\n\t\treturn\n\tend\n\tlocal function is_prefix(text, word, minlen)\n\t\tlocal n = #text\n\t\treturn (minlen or 1) <= n and n <= #word and text == word:sub(1, n)\n\tend\n\tlocal function do_days(n)\n\t\tlocal forcetime, jd\n\t\tif floor(n) == n then\n\t\t\tjd = lhs.jd\n\t\telse\n\t\t\tforcetime = not lhs.hastime\n\t\t\tjd = lhs.jdz\n\t\tend\n\t\tjd = jd + (is_sub and -n or n)\n\t\tif forcetime then\n\t\t\tjd = tostring(jd)\n\t\t\tif not jd:find('.', 1, true) then\n\t\t\t\tjd = jd .. '.0'\n\t\t\tend\n\t\tend\n\t\treturn Date(lhs, 'juliandate', jd)\n\tend\n\tif type(rhs) == 'number' then\n\t\t-- Add/subtract days, including fractional days.\n\t\treturn do_days(rhs)\n\tend\n\tif type(rhs) == 'string' then\n\t\t-- rhs is a single component like '26m' or '26 months' (with optional sign).\n\t\t-- Fractions like '3.25d' are accepted for the units which are handled as days.\n\t\tlocal sign, numstr, id = rhs:match('^%s*([+-]?)([%d%.]+)%s*(%a+)$')\n\t\tif sign then\n\t\t\tif sign == '-' then\n\t\t\t\tis_sub = not (is_sub and true or false)\n\t\t\tend\n\t\t\tlocal y, m, days\n\t\t\tlocal num = tonumber(numstr)\n\t\t\tif not num then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tid = id:lower()\n\t\t\tif is_prefix(id, 'years') then\n\t\t\t\ty = num\n\t\t\t\tm = 0\n\t\t\telseif is_prefix(id, 'months') then\n\t\t\t\ty = floor(num / 12)\n\t\t\t\tm = num % 12\n\t\t\telseif is_prefix(id, 'weeks') then\n\t\t\t\tdays = num * 7\n\t\t\telseif is_prefix(id, 'days') then\n\t\t\t\tdays = num\n\t\t\telseif is_prefix(id, 'hours') then\n\t\t\t\tdays = num / 24\n\t\t\telseif is_prefix(id, 'minutes', 3) then\n\t\t\t\tdays = num / (24 * 60)\n\t\t\telseif is_prefix(id, 'seconds') then\n\t\t\t\tdays = num / (24 * 3600)\n\t\t\telse\n\t\t\t\treturn\n\t\t\tend\n\t\t\tif days then\n\t\t\t\treturn do_days(days)\n\t\t\tend\n\t\t\tif numstr:find('.', 1, true) then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tif is_sub then\n\t\t\t\ty = -y\n\t\t\t\tm = -m\n\t\t\tend\n\t\t\tassert(-11 <= m and m <= 11)\n\t\t\ty = lhs.year + y\n\t\t\tm = lhs.month + m\n\t\t\tif m > 12 then\n\t\t\t\ty = y + 1\n\t\t\t\tm = m - 12\n\t\t\telseif m < 1 then\n\t\t\t\ty = y - 1\n\t\t\t\tm = m + 12\n\t\t\tend\n\t\t\tlocal d = math.min(lhs.day, days_in_month(y, m, lhs.calendar))\n\t\t\treturn Date(lhs, y, m, d)\n\t\tend\n\tend\n\tif is_diff(rhs) then\n\t\tlocal days = rhs.age_days\n\t\tif (is_sub or false) ~= (rhs.isnegative or false) then\n\t\t\tdays = -days\n\t\tend\n\t\treturn lhs + days\n\tend\nend\n\nlocal full_date_only = {\n\tdayabbr = true,\n\tdayname = true,\n\tdow = true,\n\tdayofweek = true,\n\tdowiso = true,\n\tdayofweekiso = true,\n\tdayofyear = true,\n\tgsd = true,\n\tjuliandate = true,\n\tjd = true,\n\tjdz = true,\n\tjdnoon = true,\n}\n\n-- Metatable for a date's calculated fields.\nlocal datemt = {\n\t__index = function (self, key)\n\t\tif rawget(self, 'partial') then\n\t\t\tif full_date_only[key] then return end\n\t\t\tif key == 'monthabbr' or key == 'monthdays' or key == 'monthname' then\n\t\t\t\tif not self.month then return end\n\t\t\tend\n\t\tend\n\t\tlocal value\n\t\tif key == 'dayabbr' then\n\t\t\tvalue = day_info[self.dow][1]\n\t\telseif key == 'dayname' then\n\t\t\tvalue = day_info[self.dow][2]\n\t\telseif key == 'dow' then\n\t\t\tvalue = (self.jdnoon + 1) % 7  -- day-of-week 0=Sun to 6=Sat\n\t\telseif key == 'dayofweek' then\n\t\t\tvalue = self.dow\n\t\telseif key == 'dowiso' then\n\t\t\tvalue = (self.jdnoon % 7) + 1  -- ISO day-of-week 1=Mon to 7=Sun\n\t\telseif key == 'dayofweekiso' then\n\t\t\tvalue = self.dowiso\n\t\telseif key == 'dayofyear' then\n\t\t\tlocal first = Date(self.year, 1, 1, self.calendar).jdnoon\n\t\t\tvalue = self.jdnoon - first + 1  -- day-of-year 1 to 366\n\t\telseif key == 'era' then\n\t\t\t-- Era text (never a negative sign) from year and options.\n\t\t\tvalue = get_era_for_year(self.options.era, self.year)\n\t\telseif key == 'format' then\n\t\t\tvalue = self.options.format or 'dmy'\n\t\telseif key == 'gsd' then\n\t\t\t-- GSD = 1 from 00:00:00 to 23:59:59 on 1 January 1 AD Gregorian calendar,\n\t\t\t-- which is from jd 1721425.5 to 1721426.49999.\n\t\t\tvalue = floor(self.jd - 1721424.5)\n\t\telseif key == 'juliandate' or key == 'jd' or key == 'jdz' then\n\t\t\tlocal jd, jdz = julian_date(self)\n\t\t\trawset(self, 'juliandate', jd)\n\t\t\trawset(self, 'jd', jd)\n\t\t\trawset(self, 'jdz', jdz)\n\t\t\treturn key == 'jdz' and jdz or jd\n\t\telseif key == 'jdnoon' then\n\t\t\t-- Julian date at noon (an integer) on the calendar day when jd occurs.\n\t\t\tvalue = floor(self.jd + 0.5)\n\t\telseif key == 'isleapyear' then\n\t\t\tvalue = is_leap_year(self.year, self.calendar)\n\t\telseif key == 'monthabbr' then\n\t\t\tvalue = month_info[self.month][1]\n\t\telseif key == 'monthdays' then\n\t\t\tvalue = days_in_month(self.year, self.month, self.calendar)\n\t\telseif key == 'monthname' then\n\t\t\tvalue = month_info[self.month][2]\n\t\tend\n\t\tif value ~= nil then\n\t\t\trawset(self, key, value)\n\t\t\treturn value\n\t\tend\n\tend,\n}\n\n-- Date operators.\nlocal function mt_date_add(lhs, rhs)\n\tif not is_date(lhs) then\n\t\tlhs, rhs = rhs, lhs  -- put date on left (it must be a date for this to have been called)\n\tend\n\treturn date_add_sub(lhs, rhs)\nend\n\nlocal function mt_date_sub(lhs, rhs)\n\tif is_date(lhs) then\n\t\tif is_date(rhs) then\n\t\t\treturn DateDiff(lhs, rhs)\n\t\tend\n\t\treturn date_add_sub(lhs, rhs, true)\n\tend\nend\n\nlocal function mt_date_concat(lhs, rhs)\n\treturn tostring(lhs) .. tostring(rhs)\nend\n\nlocal function mt_date_tostring(self)\n\treturn self:text()\nend\n\nlocal function mt_date_eq(lhs, rhs)\n\t-- Return true if dates identify same date/time where, for example,\n\t-- Date(-4712, 1, 1, 'Julian') == Date(-4713, 11, 24, 'Gregorian') is true.\n\t-- This is called only if lhs and rhs have the same type and the same metamethod.\n\tif lhs.partial or rhs.partial then\n\t\t-- One date is partial; the other is a partial or a full date.\n\t\t-- The months may both be nil, but must be the same.\n\t\treturn lhs.year == rhs.year and lhs.month == rhs.month and lhs.calendar == rhs.calendar\n\tend\n\treturn lhs.jdz == rhs.jdz\nend\n\nlocal function mt_date_lt(lhs, rhs)\n\t-- Return true if lhs < rhs, for example,\n\t-- Date('1 Jan 2016') < Date('06:00 1 Jan 2016') is true.\n\t-- This is called only if lhs and rhs have the same type and the same metamethod.\n\tif lhs.partial or rhs.partial then\n\t\t-- One date is partial; the other is a partial or a full date.\n\t\tif lhs.calendar ~= rhs.calendar then\n\t\t\treturn lhs.calendar == 'Julian'\n\t\tend\n\t\tif lhs.partial then\n\t\t\tlhs = lhs.partial.first\n\t\tend\n\t\tif rhs.partial then\n\t\t\trhs = rhs.partial.first\n\t\tend\n\tend\n\treturn lhs.jdz < rhs.jdz\nend\n\n--[[ Examples of syntax to construct a date:\nDate(y, m, d, 'julian')             default calendar is 'gregorian'\nDate(y, m, d, H, M, S, 'julian')\nDate('juliandate', jd, 'julian')    if jd contains \".\" text output includes H:M:S\nDate('currentdate')\nDate('currentdatetime')\nDate('1 April 1995', 'julian')      parse date from text\nDate('1 April 1995 AD', 'julian')   using an era sets a flag to do the same for output\nDate('04:30:59 1 April 1995', 'julian')\nDate(date)                          copy of an existing date\nDate(date, t)                       same, updated with y,m,d,H,M,S fields from table t\nDate(t)                       \t\tdate with y,m,d,H,M,S fields from table t\n]]\nfunction Date(...)  -- for forward declaration above\n\t-- Return a table holding a date assuming a uniform calendar always applies\n\t-- (proleptic Gregorian calendar or proleptic Julian calendar), or\n\t-- return nothing if date is invalid.\n\t-- A partial date has a valid year, however its month may be nil, and\n\t-- its day and time fields are nil.\n\t-- Field partial is set to false (if a full date) or a table (if a partial date).\n\tlocal calendars = { julian = 'Julian', gregorian = 'Gregorian' }\n\tlocal newdate = {\n\t\t_id = uniq,\n\t\tcalendar = 'Gregorian',  -- default is Gregorian calendar\n\t\thastime = false,  -- true if input sets a time\n\t\thour = 0,  -- always set hour/minute/second so don't have to handle nil\n\t\tminute = 0,\n\t\tsecond = 0,\n\t\toptions = {},\n\t\tlist = _date_list,\n\t\tsubtract = function (self, rhs, options)\n\t\t\treturn DateDiff(self, rhs, options)\n\t\tend,\n\t\ttext = _date_text,\n\t}\n\tlocal argtype, datetext, is_copy, jd_number, tnums\n\tlocal numindex = 0\n\tlocal numfields = { 'year', 'month', 'day', 'hour', 'minute', 'second' }\n\tlocal numbers = {}\n\tfor _, v in ipairs({...}) do\n\t\tv = strip_to_nil(v)\n\t\tlocal vlower = type(v) == 'string' and v:lower() or nil\n\t\tif v == nil then\n\t\t\t-- Ignore empty arguments after stripping so modules can directly pass template parameters.\n\t\telseif calendars[vlower] then\n\t\t\tnewdate.calendar = calendars[vlower]\n\t\telseif vlower == 'partial' then\n\t\t\tnewdate.partial = true\n\t\telseif vlower == 'fix' then\n\t\t\tnewdate.want_fix = true\n\t\telseif is_date(v) then\n\t\t\t-- Copy existing date (items can be overridden by other arguments).\n\t\t\tif is_copy or tnums then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tis_copy = true\n\t\t\tnewdate.calendar = v.calendar\n\t\t\tnewdate.partial = v.partial\n\t\t\tnewdate.hastime = v.hastime\n\t\t\tnewdate.options = v.options\n\t\t\tnewdate.year = v.year\n\t\t\tnewdate.month = v.month\n\t\t\tnewdate.day = v.day\n\t\t\tnewdate.hour = v.hour\n\t\t\tnewdate.minute = v.minute\n\t\t\tnewdate.second = v.second\n\t\telseif type(v) == 'table' then\n\t\t\tif tnums then\n\t\t\t\treturn\n\t\t\tend\n\t\t\ttnums = {}\n\t\t\tlocal tfields = { year=1, month=1, day=1, hour=2, minute=2, second=2 }\n\t\t\tfor tk, tv in pairs(v) do\n\t\t\t\tif tfields[tk] then\n\t\t\t\t\ttnums[tk] = tonumber(tv)\n\t\t\t\tend\n\t\t\t\tif tfields[tk] == 2 then\n\t\t\t\t\tnewdate.hastime = true\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tlocal num = tonumber(v)\n\t\t\tif not num and argtype == 'setdate' and numindex == 1 then\n\t\t\t\tnum = month_number(v)\n\t\t\tend\n\t\t\tif num then\n\t\t\t\tif not argtype then\n\t\t\t\t\targtype = 'setdate'\n\t\t\t\tend\n\t\t\t\tif argtype == 'setdate' and numindex < 6 then\n\t\t\t\t\tnumindex = numindex + 1\n\t\t\t\t\tnumbers[numfields[numindex]] = num\n\t\t\t\telseif argtype == 'juliandate' and not jd_number then\n\t\t\t\t\tjd_number = num\n\t\t\t\t\tif type(v) == 'string' then\n\t\t\t\t\t\tif v:find('.', 1, true) then\n\t\t\t\t\t\t\tnewdate.hastime = true\n\t\t\t\t\t\tend\n\t\t\t\t\telseif num ~= floor(num) then\n\t\t\t\t\t\t-- The given value was a number. The time will be used\n\t\t\t\t\t\t-- if the fractional part is nonzero.\n\t\t\t\t\t\tnewdate.hastime = true\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\treturn\n\t\t\t\tend\n\t\t\telseif argtype then\n\t\t\t\treturn\n\t\t\telseif type(v) == 'string' then\n\t\t\t\tif v == 'currentdate' or v == 'currentdatetime' or v == 'juliandate' then\n\t\t\t\t\targtype = v\n\t\t\t\telse\n\t\t\t\t\targtype = 'datetext'\n\t\t\t\t\tdatetext = v\n\t\t\t\tend\n\t\t\telse\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\tend\n\tif argtype == 'datetext' then\n\t\tif tnums or not set_date_from_numbers(newdate, extract_date(newdate, datetext)) then\n\t\t\treturn\n\t\tend\n\telseif argtype == 'juliandate' then\n\t\tnewdate.partial = nil\n\t\tnewdate.jd = jd_number\n\t\tif not set_date_from_jd(newdate) then\n\t\t\treturn\n\t\tend\n\telseif argtype == 'currentdate' or argtype == 'currentdatetime' then\n\t\tnewdate.partial = nil\n\t\tnewdate.year = current.year\n\t\tnewdate.month = current.month\n\t\tnewdate.day = current.day\n\t\tif argtype == 'currentdatetime' then\n\t\t\tnewdate.hour = current.hour\n\t\t\tnewdate.minute = current.minute\n\t\t\tnewdate.second = current.second\n\t\t\tnewdate.hastime = true\n\t\tend\n\t\tnewdate.calendar = 'Gregorian'  -- ignore any given calendar name\n\telseif argtype == 'setdate' then\n\t\tif tnums or not set_date_from_numbers(newdate, numbers) then\n\t\t\treturn\n\t\tend\n\telseif not (is_copy or tnums) then\n\t\treturn\n\tend\n\tif tnums then\n\t\tnewdate.jd = nil  -- force recalculation in case jd was set before changes from tnums\n\t\tif not set_date_from_numbers(newdate, tnums) then\n\t\t\treturn\n\t\tend\n\tend\n\tif newdate.partial then\n\t\tlocal year = newdate.year\n\t\tlocal month = newdate.month\n\t\tlocal first = Date(year, month or 1, 1, newdate.calendar)\n\t\tmonth = month or 12\n\t\tlocal last = Date(year, month, days_in_month(year, month), newdate.calendar)\n\t\tnewdate.partial = { first = first, last = last }\n\telse\n\t\tnewdate.partial = false  -- avoid index lookup\n\tend\n\tsetmetatable(newdate, datemt)\n\tlocal readonly = {}\n\tlocal mt = {\n\t\t__index = newdate,\n\t\t__newindex = function(t, k, v) error('date.' .. tostring(k) .. ' is read-only', 2) end,\n\t\t__add = mt_date_add,\n\t\t__sub = mt_date_sub,\n\t\t__concat = mt_date_concat,\n\t\t__tostring = mt_date_tostring,\n\t\t__eq = mt_date_eq,\n\t\t__lt = mt_date_lt,\n\t}\n\treturn setmetatable(readonly, mt)\nend\n\nlocal function _diff_age(diff, code, options)\n\t-- Return a tuple of integer values from diff as specified by code, except that\n\t-- each integer may be a list of two integers for a diff with a partial date, or\n\t-- return nil if the code is not supported.\n\t-- If want round, the least significant unit is rounded to nearest whole unit.\n\t-- For a duration, an extra day is added.\n\tlocal wantround, wantduration, wantrange\n\tif type(options) == 'table' then\n\t\twantround = options.round\n\t\twantduration = options.duration\n\t\twantrange = options.range\n\telse\n\t\twantround = options\n\tend\n\tif not is_diff(diff) then\n\t\tlocal f = wantduration and 'duration' or 'age'\n\t\terror(f .. ': need a date difference (use \"diff:' .. f .. '()\" with a colon)', 2)\n\tend\n\tif diff.partial then\n\t\t-- Ignore wantround, wantduration.\n\t\tlocal function choose(v)\n\t\t\tif type(v) == 'table' then\n\t\t\t\tif not wantrange or v[1] == v[2] then\n\t\t\t\t\t-- Example: Date('partial', 2005) - Date('partial', 2001) gives\n\t\t\t\t\t-- diff.years = { 3, 4 } to show the range of possible results.\n\t\t\t\t\t-- If do not want a range, choose the second value as more expected.\n\t\t\t\t\treturn v[2]\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn v\n\t\tend\n\t\tif code == 'ym' or code == 'ymd' then\n\t\t\tif not wantrange and diff.iszero then\n\t\t\t\t-- This avoids an unexpected result such as\n\t\t\t\t-- Date('partial', 2001) - Date('partial', 2001)\n\t\t\t\t-- giving diff = { years = 0, months = { 0, 11 } }\n\t\t\t\t-- which would be reported as 0 years and 11 months.\n\t\t\t\treturn 0, 0\n\t\t\tend\n\t\t\treturn choose(diff.partial.years), choose(diff.partial.months)\n\t\tend\n\t\tif code == 'y' then\n\t\t\treturn choose(diff.partial.years)\n\t\tend\n\t\tif code == 'm' or code == 'w' or code == 'd' then\n\t\t\treturn choose({ diff.partial.mindiff:age(code), diff.partial.maxdiff:age(code) })\n\t\tend\n\t\treturn nil\n\tend\n\tlocal extra_days = wantduration and 1 or 0\n\tif code == 'wd' or code == 'w' or code == 'd' then\n\t\tlocal offset = wantround and 0.5 or 0\n\t\tlocal days = diff.age_days + extra_days\n\t\tif code == 'wd' or code == 'd' then\n\t\t\tdays = floor(days + offset)\n\t\t\tif code == 'd' then\n\t\t\t\treturn days\n\t\t\tend\n\t\t\treturn floor(days/7), days % 7\n\t\tend\n\t\treturn floor(days/7 + offset)\n\tend\n\tlocal H, M, S = diff.hours, diff.minutes, diff.seconds\n\tif code == 'dh' or code == 'dhm' or code == 'dhms' or code == 'h' or code == 'hm' or code == 'hms' then\n\t\tlocal days = floor(diff.age_days + extra_days)\n\t\tlocal inc_hour\n\t\tif wantround then\n\t\t\tif code == 'dh' or code == 'h' then\n\t\t\t\tif M >= 30 then\n\t\t\t\t\tinc_hour = true\n\t\t\t\tend\n\t\t\telseif code == 'dhm' or code == 'hm' then\n\t\t\t\tif S >= 30 then\n\t\t\t\t\tM = M + 1\n\t\t\t\t\tif M >= 60 then\n\t\t\t\t\t\tM = 0\n\t\t\t\t\t\tinc_hour = true\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t-- Nothing needed because S is an integer.\n\t\t\tend\n\t\t\tif inc_hour then\n\t\t\t\tH = H + 1\n\t\t\t\tif H >= 24 then\n\t\t\t\t\tH = 0\n\t\t\t\t\tdays = days + 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif code == 'dh' or code == 'dhm' or code == 'dhms' then\n\t\t\tif code == 'dh' then\n\t\t\t\treturn days, H\n\t\t\telseif code == 'dhm' then\n\t\t\t\treturn days, H, M\n\t\t\telse\n\t\t\t\treturn days, H, M, S\n\t\t\tend\n\t\tend\n\t\tlocal hours = days * 24 + H\n\t\tif code == 'h' then\n\t\t\treturn hours\n\t\telseif code == 'hm' then\n\t\t\treturn hours, M\n\t\tend\n\t\treturn hours, M, S\n\tend\n\tif wantround then\n\t\tlocal inc_hour\n\t\tif code == 'ymdh' or code == 'ymwdh' then\n\t\t\tif M >= 30 then\n\t\t\t\tinc_hour = true\n\t\t\tend\n\t\telseif code == 'ymdhm' or code == 'ymwdhm' then\n\t\t\tif S >= 30 then\n\t\t\t\tM = M + 1\n\t\t\t\tif M >= 60 then\n\t\t\t\t\tM = 0\n\t\t\t\t\tinc_hour = true\n\t\t\t\tend\n\t\t\tend\n\t\telseif code == 'ymd' or code == 'ymwd' or code == 'yd' or code == 'md' then\n\t\t\tif H >= 12 then\n\t\t\t\textra_days = extra_days + 1\n\t\t\tend\n\t\tend\n\t\tif inc_hour then\n\t\t\tH = H + 1\n\t\t\tif H >= 24 then\n\t\t\t\tH = 0\n\t\t\t\textra_days = extra_days + 1\n\t\t\tend\n\t\tend\n\tend\n\tlocal y, m, d = diff.years, diff.months, diff.days\n\tif extra_days > 0 then\n\t\td = d + extra_days\n\t\tif d > 28 or code == 'yd' then\n\t\t\t-- Recalculate in case have passed a month.\n\t\t\tdiff = diff.date1 + extra_days - diff.date2\n\t\t\ty, m, d = diff.years, diff.months, diff.days\n\t\tend\n\tend\n\tif code == 'ymd' then\n\t\treturn y, m, d\n\telseif code == 'yd' then\n\t\tif y > 0 then\n\t\t\t-- It is known that diff.date1 > diff.date2.\n\t\t\tdiff = diff.date1 - (diff.date2 + (y .. 'y'))\n\t\tend\n\t\treturn y, floor(diff.age_days)\n\telseif code == 'md' then\n\t\treturn y * 12 + m, d\n\telseif code == 'ym' or code == 'm' then\n\t\tif wantround then\n\t\t\tif d >= 16 then\n\t\t\t\tm = m + 1\n\t\t\t\tif m >= 12 then\n\t\t\t\t\tm = 0\n\t\t\t\t\ty = y + 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif code == 'ym' then\n\t\t\treturn y, m\n\t\tend\n\t\treturn y * 12 + m\n\telseif code == 'ymw' then\n\t\tlocal weeks = floor(d/7)\n\t\tif wantround then\n\t\t\tlocal days = d % 7\n\t\t\tif days > 3 or (days == 3 and H >= 12) then\n\t\t\t\tweeks = weeks + 1\n\t\t\tend\n\t\tend\n\t\treturn y, m, weeks\n\telseif code == 'ymwd' then\n\t\treturn y, m, floor(d/7), d % 7\n\telseif code == 'ymdh' then\n\t\treturn y, m, d, H\n\telseif code == 'ymwdh' then\n\t\treturn y, m, floor(d/7), d % 7, H\n\telseif code == 'ymdhm' then\n\t\treturn y, m, d, H, M\n\telseif code == 'ymwdhm' then\n\t\treturn y, m, floor(d/7), d % 7, H, M\n\tend\n\tif code == 'y' then\n\t\tif wantround and m >= 6 then\n\t\t\ty = y + 1\n\t\tend\n\t\treturn y\n\tend\n\treturn nil\nend\n\nlocal function _diff_duration(diff, code, options)\n\tif type(options) ~= 'table' then\n\t\toptions = { round = options }\n\tend\n\toptions.duration = true\n\treturn _diff_age(diff, code, options)\nend\n\n-- Metatable for some operations on date differences.\ndiffmt = {  -- for forward declaration above\n\t__concat = function (lhs, rhs)\n\t\treturn tostring(lhs) .. tostring(rhs)\n\tend,\n\t__tostring = function (self)\n\t\treturn tostring(self.age_days)\n\tend,\n\t__index = function (self, key)\n\t\tlocal value\n\t\tif key == 'age_days' then\n\t\t\tif rawget(self, 'partial') then\n\t\t\t\tlocal function jdz(date)\n\t\t\t\t\treturn (date.partial and date.partial.first or date).jdz\n\t\t\t\tend\n\t\t\t\tvalue = jdz(self.date1) - jdz(self.date2)\n\t\t\telse\n\t\t\t\tvalue = self.date1.jdz - self.date2.jdz\n\t\t\tend\n\t\tend\n\t\tif value ~= nil then\n\t\t\trawset(self, key, value)\n\t\t\treturn value\n\t\tend\n\tend,\n}\n\nfunction DateDiff(date1, date2, options)  -- for forward declaration above\n\t-- Return a table with the difference between two dates (date1 - date2).\n\t-- The difference is negative if date1 is older than date2.\n\t-- Return nothing if invalid.\n\t-- If d = date1 - date2 then\n\t--     date1 = date2 + d\n\t-- If date1 >= date2 and the dates have no H:M:S time specified then\n\t--     date1 = date2 + (d.years..'y') + (d.months..'m') + d.days\n\t-- where the larger time units are added first.\n\t-- The result of Date(2015,1,x) + '1m' is Date(2015,2,28) for\n\t-- x = 28, 29, 30, 31. That means, for example,\n\t--     d = Date(2015,3,3) - Date(2015,1,31)\n\t-- gives d.years, d.months, d.days = 0, 1, 3 (excluding date1).\n\tif not (is_date(date1) and is_date(date2) and date1.calendar == date2.calendar) then\n\t\treturn\n\tend\n\tlocal wantfill\n\tif type(options) == 'table' then\n\t\twantfill = options.fill\n\tend\n\tlocal isnegative = false\n\tlocal iszero = false\n\tif date1 < date2 then\n\t\tisnegative = true\n\t\tdate1, date2 = date2, date1\n\telseif date1 == date2 then\n\t\tiszero = true\n\tend\n\t-- It is known that date1 >= date2 (period is from date2 to date1).\n\tif date1.partial or date2.partial then\n\t\t-- Two partial dates might have timelines:\n\t\t---------------------A=================B--- date1 is from A to B inclusive\n\t\t--------C=======D-------------------------- date2 is from C to D inclusive\n\t\t-- date1 > date2 iff A > C (date1.partial.first > date2.partial.first)\n\t\t-- The periods can overlap ('April 2001' - '2001'):\n\t\t-------------A===B------------------------- A=2001-04-01  B=2001-04-30\n\t\t--------C=====================D------------ C=2001-01-01  D=2001-12-31\n\t\tif wantfill then\n\t\t\tdate1, date2 = autofill(date1, date2)\n\t\telse\n\t\t\tlocal function zdiff(date1, date2)\n\t\t\t\tlocal diff = date1 - date2\n\t\t\t\tif diff.isnegative then\n\t\t\t\t\treturn date1 - date1  -- a valid diff in case we call its methods\n\t\t\t\tend\n\t\t\t\treturn diff\n\t\t\tend\n\t\t\tlocal function getdate(date, which)\n\t\t\t\treturn date.partial and date.partial[which] or date\n\t\t\tend\n\t\t\tlocal maxdiff = zdiff(getdate(date1, 'last'), getdate(date2, 'first'))\n\t\t\tlocal mindiff = zdiff(getdate(date1, 'first'), getdate(date2, 'last'))\n\t\t\tlocal years, months\n\t\t\tif maxdiff.years == mindiff.years then\n\t\t\t\tyears = maxdiff.years\n\t\t\t\tif maxdiff.months == mindiff.months then\n\t\t\t\t\tmonths = maxdiff.months\n\t\t\t\telse\n\t\t\t\t\tmonths = { mindiff.months, maxdiff.months }\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tyears = { mindiff.years, maxdiff.years }\n\t\t\tend\n\t\t\treturn setmetatable({\n\t\t\t\tdate1 = date1,\n\t\t\t\tdate2 = date2,\n\t\t\t\tpartial = {\n\t\t\t\t\tyears = years,\n\t\t\t\t\tmonths = months,\n\t\t\t\t\tmaxdiff = maxdiff,\n\t\t\t\t\tmindiff = mindiff,\n\t\t\t\t},\n\t\t\t\tisnegative = isnegative,\n\t\t\t\tiszero = iszero,\n\t\t\t\tage = _diff_age,\n\t\t\t\tduration = _diff_duration,\n\t\t\t}, diffmt)\n\t\tend\n\tend\n\tlocal y1, m1 = date1.year, date1.month\n\tlocal y2, m2 = date2.year, date2.month\n\tlocal years = y1 - y2\n\tlocal months = m1 - m2\n\tlocal d1 = date1.day + hms(date1)\n\tlocal d2 = date2.day + hms(date2)\n\tlocal days, time\n\tif d1 >= d2 then\n\t\tdays = d1 - d2\n\telse\n\t\tmonths = months - 1\n\t\t-- Get days in previous month (before the \"to\" date) given December has 31 days.\n\t\tlocal dpm = m1 > 1 and days_in_month(y1, m1 - 1, date1.calendar) or 31\n\t\tif d2 >= dpm then\n\t\t\tdays = d1 - hms(date2)\n\t\telse\n\t\t\tdays = dpm - d2 + d1\n\t\tend\n\tend\n\tif months < 0 then\n\t\tyears = years - 1\n\t\tmonths = months + 12\n\tend\n\tdays, time = math.modf(days)\n\tlocal H, M, S = h_m_s(time)\n\treturn setmetatable({\n\t\tdate1 = date1,\n\t\tdate2 = date2,\n\t\tpartial = false,  -- avoid index lookup\n\t\tyears = years,\n\t\tmonths = months,\n\t\tdays = days,\n\t\thours = H,\n\t\tminutes = M,\n\t\tseconds = S,\n\t\tisnegative = isnegative,\n\t\tiszero = iszero,\n\t\tage = _diff_age,\n\t\tduration = _diff_duration,\n\t}, diffmt)\nend\n\nreturn {\n\t_current = current,\n\t_Date = Date,\n\t_days_in_month = days_in_month,\n}"}}}