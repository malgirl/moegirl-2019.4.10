{"parse":{"title":"\u6a21\u5757:Age","pageid":304022,"wikitext":{"*":"-- Implement various \"age of\" and other date-related templates.\n\nlocal _Date, _currentDate\nlocal function getExports(frame)\n\t-- Return objects exported from the date module or its sandbox.\n\tif not _Date then\n\t\tlocal sandbox = frame:getTitle():find('sandbox', 1, true) and '/sandbox' or ''\n\t\tlocal datemod = require('Module:Date' .. sandbox)\n\t\t_Date = datemod._Date\n\t\t_currentDate = datemod._current\n\tend\n\treturn _Date, _currentDate\nend\n\nlocal Collection  -- a table to hold items\nCollection = {\n\tadd = function (self, item)\n\t\tif item ~= nil then\n\t\t\tself.n = self.n + 1\n\t\t\tself[self.n] = item\n\t\tend\n\tend,\n\tjoin = function (self, sep)\n\t\treturn table.concat(self, sep)\n\tend,\n\tremove = function (self, pos)\n\t\tif self.n > 0 and (pos == nil or (0 < pos and pos <= self.n)) then\n\t\t\tself.n = self.n - 1\n\t\t\treturn table.remove(self, pos)\n\t\tend\n\tend,\n\tsort = function (self, comp)\n\t\ttable.sort(self, comp)\n\tend,\n\tnew = function ()\n\t\treturn setmetatable({n = 0}, Collection)\n\tend\n}\nCollection.__index = Collection\n\nlocal function stripToNil(text)\n\t-- If text is a string, return its trimmed content, or nil if empty.\n\t-- Otherwise return text (which may, for example, be nil).\n\tif type(text) == 'string' then\n\t\ttext = text:match('(%S.-)%s*$')\n\tend\n\treturn text\nend\n\nlocal yes = require('Module:Yesno')\n\nlocal function message(msg, id)\n\t-- Return formatted message text for an error or warning.\n\tlocal categories = {\n\t\terror = '[[Category:Age\u6a21\u5757\u9519\u8bef]]',\n\t\twarning = '[[Category:Age\u6a21\u5757\u9519\u8bef]]',  -- same as error until determine whether 'Age warning' would be worthwhile\n\t}\n\tlocal a, b, category\n\tif id == 'warning' then\n\t\ta = '<sup>[<i>'\n\t\tb = '</i>]</sup>'\n\telse\n\t\ta = '<strong class=\"error\">\u9519\u8bef\uff1a'\n\t\tb = '</strong>'\n\tend\n\tif mw.title.getCurrentTitle():inNamespaces(0) then\n\t\t-- Category only in namespaces: 0=article.\n\t\tcategory = categories[id or 'error']\n\tend\n\treturn\n\t\ta ..\n\t\tmw.text.nowiki(msg) ..\n\t\tb ..\n\t\t(category or '')\nend\n\nlocal function formatNumber(number)\n\t-- Return the given number formatted with commas as group separators,\n\t-- given that the number is an integer.\n\tlocal numstr = tostring(number)\n\tlocal length = #numstr\n\tlocal places = Collection.new()\n\tlocal pos = 0\n\trepeat\n\t\tplaces:add(pos)\n\t\tpos = pos + 3\n\tuntil pos >= length\n\tplaces:add(length)\n\tlocal groups = Collection.new()\n\tfor i = places.n, 2, -1 do\n\t\tlocal p1 = length - places[i] + 1\n\t\tlocal p2 = length - places[i - 1]\n\t\tgroups:add(numstr:sub(p1, p2))\n\tend\n\treturn groups:join(',')\nend\n\nlocal function spellNumber(number, options, i)\n\t-- Return result of spelling number, or\n\t-- return number (as a string) if cannot spell it.\n\t-- i == 1 for the first number which can optionally start with an uppercase letter.\n\tnumber = tostring(number)\n\treturn require('Module:ConvertNumeric').spell_number(\n\t\tnumber,\n\t\tnil,                       -- fraction numerator\n\t\tnil,                       -- fraction denominator\n\t\ti == 1 and options.upper,  -- true: 'One' instead of 'one'\n\t\tnot options.us,            -- true: use 'and' between tens/ones etc\n\t\toptions.adj,               -- true: hyphenated\n\t\toptions.ordinal            -- true: 'first' instead of 'one'\n\t) or number\nend\n\nlocal function makeSort(value, sortable)\n\t-- Return a sort key if requested.\n\t-- Assume value is a valid number which has not overflowed.\n\tif sortable == 'sortable_table' or sortable == 'sortable_on' or sortable == 'sortable_debug' then\n\t\tlocal sortkey\n\t\tif value == 0 then\n\t\t\tsortkey = '5000000000000000000'\n\t\telse\n\t\t\tlocal mag = math.floor(math.log10(math.abs(value)) + 1e-14)\n\t\t\tlocal prefix\n\t\t\tif value > 0 then\n\t\t\t\tprefix = 7000 + mag\n\t\t\telse\n\t\t\t\tprefix = 2999 - mag\n\t\t\t\tvalue = value + 10^(mag+1)\n\t\t\tend\n\t\t\tsortkey = string.format('%d', prefix) .. string.format('%015.0f', math.floor(value * 10^(14-mag)))\n\t\tend\n\t\tlocal lhs, rhs\n\t\tif sortable == 'sortable_table' then\n\t\t\tlhs = 'data-sort-value=\"'\n\t\t\trhs = '\"|'\n\t\telse\n\t\t\tlhs = sortable == 'sortable_debug' and\n\t\t\t\t'<span style=\"border:1px solid;display:inline;\" class=\"sortkey\">' or\n\t\t\t\t'<span style=\"display:none\" class=\"sortkey\">'\n\t\t\trhs = '\u2660</span>'\n\t\tend\n\t\treturn lhs .. sortkey .. rhs\n\tend\nend\n\nlocal translateParameters = {\n\tabbr = {\n\t\toff = 'abbr_off',\n\t\ton = 'abbr_on',\n\t},\n\tdisp = {\n\t\tage = 'disp_age',\n\t\traw = 'disp_raw',\n\t},\n\tformat = {\n\t\traw = 'format_raw',\n\t\tcommas = 'format_commas',\n\t},\n\tround = {\n\t\ton = 'on',\n\t\tyes = 'on',\n\t\tmonths = 'ym',\n\t\tweeks = 'ymw',\n\t\tdays = 'ymd',\n\t\thours = 'ymdh',\n\t},\n\tsep = {\n\t\tcomma = 'sep_comma',\n\t\t[','] = 'sep_comma',\n\t\tserialcomma = 'sep_serialcomma',\n\t\tspace = 'sep_space',\n\t},\n\tshow = {\n\t\thide = { id = 'hide' },\n\t\ty = { 'y', id = 'y' },\n\t\tym = { 'y', 'm', id = 'ym' },\n\t\tymd = { 'y', 'm', 'd', id = 'ymd' },\n\t\tymw = { 'y', 'm', 'w', id = 'ymw' },\n\t\tymwd = { 'y', 'm', 'w', 'd', id = 'ymwd' },\n\t\tyd = { 'y', 'd', id = 'yd', keepZero = true },\n\t\tm = { 'm', id = 'm' },\n\t\tmd = { 'm', 'd', id = 'md' },\n\t\tw = { 'w', id = 'w' },\n\t\twd = { 'w', 'd', id = 'wd' },\n\t\th = { 'H', id = 'h' },\n\t\thm = { 'H', 'M', id = 'hm' },\n\t\thms = { 'H', 'M', 'S', id = 'hms' },\n\t\td = { 'd', id = 'd' },\n\t\tdh = { 'd', 'H', id = 'dh' },\n\t\tdhm = { 'd', 'H', 'M', id = 'dhm' },\n\t\tdhms = { 'd', 'H', 'M', 'S', id = 'dhms' },\n\t\tymdh = { 'y', 'm', 'd', 'H', id = 'ymdh' },\n\t\tymdhm = { 'y', 'm', 'd', 'H', 'M', id = 'ymdhm' },\n\t\tymwdh = { 'y', 'm', 'w', 'd', 'H', id = 'ymwdh' },\n\t\tymwdhm = { 'y', 'm', 'w', 'd', 'H', 'M', id = 'ymwdhm' },\n\t},\n\tsortable = {\n\t\toff = false,\n\t\ton = 'sortable_on',\n\t\ttable = 'sortable_table',\n\t\tdebug = 'sortable_debug',\n\t},\n}\n\nlocal spellOptions = {\n\tcardinal = {},\n\tCardinal = { upper = true },\n\tcardinal_us = { us = true },\n\tCardinal_us = { us = true, upper = true },\n\tordinal = { ordinal = true },\n\tOrdinal = { ordinal = true, upper = true },\n\tordinal_us = { ordinal = true, us = true },\n\tOrdinal_us = { ordinal = true, us = true, upper = true },\n}\n\nlocal function dateExtract(frame)\n\t-- Return part of a date after performing an optional operation.\n\tlocal Date = getExports(frame)\n\tlocal args = frame:getParent().args\n\tlocal parms = {}\n\tfor i, v in ipairs(args) do\n\t\tparms[i] = v\n\tend\n\tif yes(args.fix) then\n\t\ttable.insert(parms, 'fix')\n\tend\n\tif yes(args.partial) then\n\t\ttable.insert(parms, 'partial')\n\tend\n\tlocal show = stripToNil(args.show) or 'dmy'\n\tlocal date = Date(unpack(parms))\n\tif not date then\n\t\tif show == 'format' then\n\t\t\treturn 'error'\n\t\tend\n\t\treturn message('\u9700\u8981\u6709\u6548\u7684\u65e5\u671f')\n\tend\n\tlocal add = stripToNil(args.add)\n\tif add then\n\t\tfor item in add:gmatch('%S+') do\n\t\t\tdate = date + item\n\t\t\tif not date then\n\t\t\t\treturn message('\u65e0\u6cd5\u6dfb\u52a0\u201c' .. item .. '\u201d')\n\t\t\tend\n\t\tend\n\tend\n\tlocal prefix, result\n\tlocal sortable = translateParameters.sortable[args.sortable]\n\tif sortable then\n\t\tlocal value = (date.partial and date.partial.first or date).jdz\n\t\tprefix = makeSort(value, sortable)\n\tend\n\tif show ~= 'hide' then\n\t\tresult = date[show]\n\t\tif result == nil then\n\t\t\tresult = date:text(show)\n\t\telseif type(result) == 'boolean' then\n\t\t\tresult = result and '1' or '0'\n\t\telse\n\t\t\tresult = tostring(result)\n\t\tend\n\tend\n\treturn (prefix or '') .. (result or '')\nend\n\nlocal function rangeJoin(range)\n\t-- Return text to be used between a range of ages.\n\treturn range == 'dash' and '\u2013' or '\u6216'\nend\n\nlocal function makeText(values, components, names, options, noUpper)\n\t-- Return wikitext representing an age or duration.\n\tlocal text = Collection.new()\n\tlocal count = #values\n\tlocal sep = names.sep or ''\n\tfor i, v in ipairs(values) do\n\t\t-- v is a number (say 4 for 4 years), or a table ({4,5} for 4 or 5 years).\n\t\tlocal islist = type(v) == 'table'\n\t\tif (islist or v > 0) or (text.n == 0 and i == count) or (text.n > 0 and components.keepZero) then\n\t\t\tlocal fmt, vstr\n\t\t\tif options.spell then\n\t\t\t\tfmt = function(number)\n\t\t\t\t\treturn spellNumber(number, options.spell, noUpper or i)\n\t\t\t\tend\n\t\t\telseif i == 1 and options.format == 'format_commas' then\n\t\t\t\t-- Numbers after the first should be small and not need formatting.\n\t\t\t\tfmt = formatNumber\n\t\t\telse\n\t\t\t\tfmt = tostring\n\t\t\tend\n\t\t\tif islist then\n\t\t\t\tvstr = fmt(v[1]) .. rangeJoin(options.range)\n\t\t\t\tnoUpper = true\n\t\t\t\tvstr = vstr .. fmt(v[2])\n\t\t\telse\n\t\t\t\tvstr = fmt(v)\n\t\t\tend\n\t\t\tlocal name = names[components[i]]\n\t\t\tif name then\n\t\t\t\tlocal plural = names.plural\n\t\t\t\tif not plural or (islist and v[2] or v) == 1 then\n\t\t\t\t\tplural = ''\n\t\t\t\tend\n\t\t\t\ttext:add(vstr .. sep .. name .. plural)\n\t\t\telse\n\t\t\t\ttext:add(vstr)\n\t\t\tend\n\t\tend\n\tend\n\tlocal first, last\n\t-- hh mm ss\n\tif options.join == 'sep_space' then\n\t\tfirst = ' '\n\t\tlast = ' '\n\t-- hh\u65f6\uff0cmm\u5206\uff0css\u79d2\n\telseif options.join == 'sep_comma' then\n\t\tfirst = '\uff0c'\n\t\tlast = '\uff0c'\n\t-- hh\u65f6\uff0cmm\u5206\u53c8ss\u79d2\n\telseif options.join == 'sep_serialcomma' then\n\t\tfirst = '\uff0c'\n\t\tlast = text.n > 2 and (names.y == '\u5e74' and '\u53c8' or '\u96f6') or '\uff0c'\n\t-- hh\u65f6mm\u5206ss\u79d2\n\telseif options.join == 'sep_none' then\n\t\tfirst = ''\n\t\tlast = ''\n\t-- hh\u65f6mm\u5206\u53c8ss\u79d2\n\telse  -- 'sep_serial'\n\t\tfirst = ''\n\t\tlast = text.n > 2 and (names.y == '\u5e74' and '\u53c8' or '\u96f6') or ''\n\tend\n\tif yes(options.range, true) and options.join ~= 'sep_space' and string.sub(last, 1, 1) ~= '\uff0c' then\n\t\tlast = '\uff0c' .. last\n\tend\n\tfor i, v in ipairs(text) do\n\t\tif i < text.n then\n\t\t\ttext[i] = v .. (i + 1 < text.n and first or last)\n\t\tend\n\tend\n\tlocal sign = ''\n\tif options.isnegative then\n\t\t-- Do not display negative zero.\n\t\tif text.n > 1 or (text.n == 1 and text[1]:sub(1, 1) ~= '0' ) then\n\t\t\tif options.format == 'format_raw' then\n\t\t\t\tsign = '-'  -- plain hyphen so result can be used in a calculation\n\t\t\telse\n\t\t\t\tsign = '\u2212'  -- Unicode U+2212 MINUS SIGN\n\t\t\tend\n\t\tend\n\tend\n\treturn\n\t\t(options.prefix or '') ..\n\t\t(options.extra or '') ..\n\t\tsign ..\n\t\ttext:join() ..\n\t\t(options.suffix or '')\nend\n\nlocal function dateDifference(parms)\n\t-- Return a formatted date difference using the given parameters\n\t-- which have been validated.\n\tlocal names = {\n\t\tabbr_off = {\n\t\t\tplural = '',\n\t\t\tsep = '',\n\t\t\ty = '\u5e74',\n\t\t\tm = '\u4e2a\u6708',\n\t\t\tw = '\u5468',\n\t\t\td = '\u5929',\n\t\t\tH = '\u5c0f\u65f6',\n\t\t\tM = '\u5206',\n\t\t\tS = '\u79d2',\n\t\t},\n\t\tabbr_on = {\n\t\t\ty = 'y',\n\t\t\tm = 'm',\n\t\t\tw = 'w',\n\t\t\td = 'd',\n\t\t\tH = 'h',\n\t\t\tM = 'm',\n\t\t\tS = 's',\n\t\t},\n\t\tabbr_age = {\n\t\t\tplural = '',\n\t\t\tsep = '',\n\t\t\ty = '\u5c81',\n\t\t\tm = '\u4e2a\u6708',\n\t\t\tw = '\u5468',\n\t\t\td = '\u5929',\n\t\t\tH = '\u5c0f\u65f6',\n\t\t\tM = '\u5206',\n\t\t\tS = '\u79d2',\n\t\t},\n\t\tabbr_raw = {},\n\t}\n\tlocal diff = parms.diff  -- must be a valid date difference\n\tlocal show = parms.show  -- may be nil; default is set below\n\tlocal abbr = parms.abbr or 'abbr_off'\n\tlocal defaultJoin  -- \u4e2d\u6587\u5e94\u8be5\u5168\u4e3anil\n\tif abbr ~= 'abbr_off' then\n\t\tdefaultJoin = nil\n\tend\n\tif not show then\n\t\tshow = 'ymd'\n\t\tif parms.disp == 'disp_age' then\n\t\t\tif diff.years < 3 then\n\t\t\t\tdefaultJoin = nil\n\t\t\t\tif diff.years >= 1 then\n\t\t\t\t\tshow = 'ym'\n\t\t\t\telse\n\t\t\t\t\tshow = 'md'\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tshow = 'y'\n\t\t\tend\n\t\tend\n\tend\n\tif type(show) ~= 'table' then\n\t\tshow = translateParameters.show[show]\n\tend\n\tif parms.disp == 'disp_raw' then\n\t\tdefaultJoin = 'sep_space'\n\t\tabbr = 'abbr_raw'\n\telseif parms.wantSc then\n\t\tdefaultJoin = 'sep_serialcomma'\n\tend\n\tlocal diffOptions = {\n\t\tround = parms.round,\n\t\tduration = parms.wantDuration,\n\t\trange = parms.range and true or nil,\n\t}\n\tlocal prefix\n\tif parms.sortable then\n\t\tlocal value = diff.age_days + (parms.wantDuration and 1 or 0)  -- days and fraction of a day\n\t\tif diff.isnegative then\n\t\t\tvalue = -value\n\t\tend\n\t\tprefix = makeSort(value, parms.sortable)\n\tend\n\tlocal textOptions = {\n\t\tprefix = prefix,\n\t\tsuffix = parms.suffix,  -- not currently used\n\t\textra = parms.extra,\n\t\tformat = parms.format,\n\t\tjoin = parms.sep or defaultJoin,\n\t\tisnegative = diff.isnegative,\n\t\trange = parms.range,\n\t\tspell = parms.spell,\n\t}\n\tif show.id == 'hide' then\n\t\treturn prefix or ''\n\tend\n\tlocal values = { diff:age(show.id, diffOptions) }\n\tif values[1] then\n\t\treturn makeText(values, show, names[abbr], textOptions)\n\tend\n\tif diff.partial then\n\t\t-- Handle a more complex range such as\n\t\t-- {{age_yd|20 Dec 2001|2003|range=yes}} \u2192 1 year, 12 days or 2 years, 11 days\n\t\tlocal opt = {\n\t\t\tformat = textOptions.format,\n\t\t\tjoin = textOptions.join,\n\t\t\tisnegative = textOptions.isnegative,\n\t\t\tspell = textOptions.spell,\n\t\t}\n\t\treturn\n\t\t\t(textOptions.prefix or '') ..\n\t\t\tmakeText({ diff.partial.mindiff:age(show.id, diffOptions) }, show, names[abbr], opt) ..\n\t\t\trangeJoin(textOptions.range) ..\n\t\t\tmakeText({ diff.partial.maxdiff:age(show.id, diffOptions) }, show, names[abbr], opt, true) ..\n\t\t\t(textOptions.suffix or '')\n\tend\n\treturn message('\u6b64\u5904\u4e0d\u652f\u6301\u53c2\u6570show=' .. show.id)\nend\n\nlocal function getDates(frame, getopt)\n\t-- Parse template parameters and return one of:\n\t-- * date         (a date table, if single)\n\t-- * date1, date2 (two date tables, if not single)\n\t-- * text         (a string error message)\n\t-- A missing date is optionally replaced with the current date.\n\t-- If wantMixture is true, a missing date component is replaced\n\t-- from the current date, so can get a bizarre mixture of\n\t-- specified/current y/m/d as has been done by some \"age\" templates.\n\t-- Some results may be placed in table getopt.\n\tlocal Date, currentDate = getExports(frame)\n\tgetopt = getopt or {}\n\tlocal function flagCurrent(text)\n\t\t-- This allows the calling template to detect if the current date has been used,\n\t\t-- that is, whether both dates have been entered in a template expecting two.\n\t\t-- For example, an infobox may want the age when an event occurred, not the current age.\n\t\t-- Don't bother detecting if wantMixture is used because not needed and it is a poor option.\n\t\tif not text then\n\t\t\ttext = 'currentdate'\n\t\t\tif getopt.flag == 'usesCurrent' then\n\t\t\t\tgetopt.usesCurrent = true\n\t\t\tend\n\t\tend\n\t\treturn text\n\tend\n\tlocal args = frame:getParent().args\n\tlocal fields = {}\n\tlocal isNamed = args.year or args.year1 or args.year2 or\n\t\targs.month or args.month1 or args.month2 or\n\t\targs.day or args.day1 or args.day2\n\tif isNamed then\n\t\tfields[1] = args.year1 or args.year\n\t\tfields[2] = args.month1 or args.month\n\t\tfields[3] = args.day1 or args.day\n\t\tfields[4] = args.year2\n\t\tfields[5] = args.month2\n\t\tfields[6] = args.day2\n\telse\n\t\tfor i = 1, 6 do\n\t\t\tfields[i] = args[i]\n\t\tend\n\tend\n\tlocal imax = 0\n\tfor i = 1, 6 do\n\t\tfields[i] = stripToNil(fields[i])\n\t\tif fields[i] then\n\t\t\timax = i\n\t\tend\n\t\tif getopt.omitZero and i % 3 ~= 1 then  -- omit zero months and days as unknown values but keep year 0 which is 1 BCE\n\t\t\tif tonumber(fields[i]) == 0 then\n\t\t\t\tfields[i] = nil\n\t\t\t\tgetopt.partial = true\n\t\t\tend\n\t\tend\n\tend\n\tlocal fix = getopt.fix and 'fix' or ''\n\tlocal noDefault = imax == 0 and getopt.noMissing\n\tlocal partialText = getopt.partial and 'partial' or ''\n\tlocal dates = {}\n\tif isNamed or imax >= 3 then\n\t\tlocal nrDates = getopt.single and 1 or 2\n\t\tif getopt.wantMixture then\n\t\t\t-- Cannot be partial since empty fields are set from current.\n\t\t\tlocal components = { 'year', 'month', 'day' }\n\t\t\tfor i = 1, nrDates * 3 do\n\t\t\t\tfields[i] = fields[i] or currentDate[components[i > 3 and i - 3 or i]]\n\t\t\tend\n\t\t\tfor i = 1, nrDates do\n\t\t\t\tlocal index = i == 1 and 1 or 4\n\t\t\t\tdates[i] = Date(fields[index], fields[index+1], fields[index+2])\n\t\t\tend\n\t\telse\n\t\t\t-- If partial dates are allowed, accept\n\t\t\t--     year only, or\n\t\t\t--     year and month only\n\t\t\t-- Do not accept year and day without a month because that makes no sense\n\t\t\t-- (and because, for example, Date('partial', 2001, nil, 12) sets day = nil, not 12).\n\t\t\tfor i = 1, nrDates do\n\t\t\t\tlocal index = i == 1 and 1 or 4\n\t\t\t\tlocal y, m, d = fields[index], fields[index+1], fields[index+2]\n\t\t\t\tif (getopt.partial and y and (m or not d)) or (y and m and d) then\n\t\t\t\t\tdates[i] = Date(fix, partialText, y, m, d)\n\t\t\t\telseif not y and not m and not d and not noDefault then\n\t\t\t\t\tdates[i] = Date(flagCurrent())\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\telseif not noDefault then\n\t\tgetopt.textdates = true  -- have parsed each date from a single text field\n\t\tdates[1] = Date(fix, partialText, flagCurrent(fields[1]))\n\t\tif not getopt.single then\n\t\t\tdates[2] = Date(fix, partialText, flagCurrent(fields[2]))\n\t\tend\n\tend\n\tif not dates[1] then\n\t\treturn message('\u9700\u8981\u6709\u6548\u7684\u5e74\u6708\u65e5')\n\tend\n\tif getopt.single then\n\t\treturn dates[1]\n\tend\n\tif not dates[2] then\n\t\treturn message('\u7b2c\u4e8c\u4e2a\u65e5\u671f\u5e94\u8be5\u662f\u5e74\u6708\u65e5')\n\tend\n\treturn dates[1], dates[2]\nend\n\nlocal function ageGeneric(frame)\n\t-- Return the result required by the specified template.\n\t-- Can use sortable=x where x = on/table/off/debug in any supported template.\n\t-- Some templates default to sortable=on but can be overridden.\n\tlocal name = frame.args.template\n\tif not name then\n\t\treturn message('\u8c03\u7528\u5b83\u7684\u6a21\u677f\u5fc5\u987b\u6709\u201c|template=x\u201d\u53c2\u6570\uff0c\u5176\u4e2dx\u662f\u6240\u9700\u7684\u64cd\u4f5c')\n\tend\n\tlocal args = frame:getParent().args\n\tlocal specs = {\n\t\t-- \u91cd\u70b9\uff01\u5207\u52ff\u968f\u610f\u66f4\u6539\uff01\n\t\tage_days = {                -- {{age in days}}\n\t\t\tshow = 'd',\n\t\t\tdisp = 'disp_raw',\n\t\t},\n\t\tage_days_nts = {            -- {{age in days nts}}\n\t\t\tshow = 'd',\n\t\t\tdisp = 'disp_raw',\n\t\t\tformat = 'format_commas',\n\t\t\tsortable = 'on',\n\t\t},\n\t\tduration_days = {           -- {{duration in days}}\n\t\t\tshow = 'd',\n\t\t\tdisp = 'disp_raw',\n\t\t\tduration = true,\n\t\t},\n\t\tduration_days_nts = {       -- {{duration in days nts}}\n\t\t\tshow = 'd',\n\t\t\tdisp = 'disp_raw',\n\t\t\tformat = 'format_commas',\n\t\t\tsortable = 'on',\n\t\t\tduration = true,\n\t\t},\n\t\tage_full_years = {          -- {{age}}\n\t\t\tshow = 'y',\n\t\t\tabbr = 'abbr_raw',\n\t\t\tflag = 'usesCurrent',\n\t\t\tomitZero = true,\n\t\t\trange = 'no',\n\t\t},\n\t\tage_full_years_nts = {      -- {{age nts}}\n\t\t\tshow = 'y',\n\t\t\tabbr = 'abbr_raw',\n\t\t\tformat = 'format_commas',\n\t\t\tsortable = 'on',\n\t\t},\n\t\tage_in_years = {            -- {{age in years}}\n\t\t\tshow = 'y',\n\t\t\tabbr = 'abbr_raw',\n\t\t\tnegative = 'error',\n\t\t\trange = 'dash',\n\t\t},\n\t\tage_in_years_nts = {        -- {{age in years nts}}\n\t\t\tshow = 'y',\n\t\t\tabbr = 'abbr_raw',\n\t\t\tnegative = 'error',\n\t\t\trange = 'dash',\n\t\t\tformat = 'format_commas',\n\t\t\tsortable = 'on',\n\t\t},\n\t\tage_infant = {              -- {{age for infant}}\n\t\t\t-- Do not set show because special processing is done later.\n\t\t\tabbr = 'abbr_off',\n\t\t\tdisp = 'disp_age',\n\t\t\tsortable = 'on',\n\t\t\tage = true,\n\t\t},\n\t\tage_m = {                   -- {{age in months}}\n\t\t\tshow = 'm',\n\t\t\tdisp = 'disp_raw',\n\t\t},\n\t\tage_w = {                   -- {{age in weeks}}\n\t\t\tshow = 'w',\n\t\t\tdisp = 'disp_raw',\n\t\t},\n\t\tage_wd = {                  -- {{age in weeks and days}}\n\t\t\tshow = 'wd',\n\t\t},\n\t\tage_yd = {                  -- {{age in years and days}}\n\t\t\tshow = 'yd',\n\t\t\tformat = 'format_commas',\n\t\t\tsep = args.sep == 'and' and 'sep_serialcomma' or nil,\n\t\t\tage = true,\n\t\t},\n\t\tage_yd_nts = {              -- {{age in years and days nts}}\n\t\t\tshow = 'yd',\n\t\t\tformat = 'format_commas',\n\t\t\tsep = args.sep == 'and' and 'sep_serialcomma' or nil,\n\t\t\tsortable = 'on',\n\t\t\tage = true,\n\t\t},\n\t\tage_ym = {                  -- {{age in years and months}}\n\t\t\tshow = 'ym',\n\t\t\tsep = args.sep == 'and' and 'sep_serialcomma' or nil,\n\t\t},\n\t\tage_ymd = {                 -- {{age in years, months and days}}\n\t\t\tshow = 'ymd',\n\t\t},\n\t\tage_ymwd = {                -- {{age in years, months, weeks and days}}\n\t\t\tshow = 'ymwd',\n\t\t\twantMixture = true,\n\t\t},\n\t}\n\tlocal spec = specs[name]\n\tif not spec then\n\t\treturn message('\u6307\u5b9a\u7684\u6a21\u677f\u540d\u79f0\u65e0\u6548')\n\tend\n\tif name == 'age_days' then\n\t\tlocal su = stripToNil(args['show unit'])\n\t\tif su then\n\t\t\tif su == 'abbr' or su == 'full' then\n\t\t\t\tspec.disp = nil\n\t\t\t\tspec.abbr = su == 'abbr' and 'abbr_on' or nil\n\t\t\tend\n\t\tend\n\tend\n\tlocal partial, autofill\n\tlocal range = stripToNil(args.range) or spec.range\n\tif range then\n\t\t-- Suppose partial dates are used and age could be 11 or 12 years.\n\t\t-- \"|range=\" (empty value) has no effect (spec is used).\n\t\t-- \"|range=yes\" or spec.range == true sets range = true (gives \"11 or 12\")\n\t\t-- \"|range=dash\" or spec.range == 'dash' sets range = 'dash' (gives \"11\u201312\").\n\t\t-- \"|range=no\" or spec.range == 'no' sets range = nil and fills each date in the diff (gives \"12\").\n\t\t--     (\"on\" is equivalent to \"yes\", and \"off\" is equivalent to \"no\").\n\t\t-- \"|range=OTHER\" sets range = nil and rejects partial dates.\n\t\trange = ({ dash = 'dash', off = 'no', no = 'no', [true] = true })[range] or yes(range)\n\t\tif range then\n\t\t\tpartial = true  -- accept partial dates with a possible age range for the result\n\t\t\tif range == 'no' then\n\t\t\t\tautofill = true  -- missing month/day in first or second date are filled from other date or 1\n\t\t\t\trange = nil\n\t\t\tend\n\t\tend\n\tend\n\tlocal getopt = {\n\t\tfix = yes(args.fix),\n\t\tflag = stripToNil(args.flag) or spec.flag,\n\t\tomitZero = spec.omitZero,\n\t\tpartial = partial,\n\t\twantMixture = spec.wantMixture,\n\t}\n\tlocal date1, date2 = getDates(frame, getopt)\n\tif type(date1) == 'string' then\n\t\treturn date1\n\tend\n\tlocal useAge = spec.age\n\tif args.age ~= nil then\n\t\tuseAge = yes(args.age, spec.age)\n\tend\n\tlocal format = stripToNil(args.format)\n\tlocal spell = spellOptions[format]\n\tif format then\n\t\tformat = 'format_' .. format\n\telseif name == 'age_days' and getopt.textdates then\n\t\tformat = 'format_commas'\n\tend\n\tlocal parms = {\n\t\tdiff = date2:subtract(date1, { fill = autofill }),\n\t\twantDuration = spec.duration or yes(args.duration),\n\t\trange = range,\n\t\twantSc = yes(args.sc),\n\t\tshow = args.show == 'hide' and 'hide' or spec.show,\n\t\tabbr = useAge and 'abbr_age' or spec.abbr,\n\t\tdisp = spec.disp,\n\t\textra = (getopt.usesCurrent and format ~= 'format_raw') and '<span class=\"currentage\"></span>' or nil,\n\t\tformat = format or spec.format,\n\t\tround = yes(args.round),\n\t\tsep = spec.sep,\n\t\tsortable = translateParameters.sortable[args.sortable or spec.sortable],\n\t\tspell = spell,\n\t}\n\tif (spec.negative or frame.args.negative) == 'error' and parms.diff.isnegative then\n\t\treturn message('\u7b2c\u4e8c\u4e2a\u65e5\u671f\u4e0d\u5e94\u8be5\u5728\u7b2c\u4e00\u4e2a\u65e5\u671f\u4e4b\u524d')\n\tend\n\treturn dateDifference(parms)\nend\n\nlocal function bda(frame)\n\t-- Implement [[Template:Birth date and age]].\n\tlocal args = frame:getParent().args\n\tlocal options = { noMissing=true, single=true }\n\tlocal date = getDates(frame, options)\n\tif type(date) == 'string' then\n\t\treturn date  -- error text\n\tend\n\tlocal Date = getExports(frame)\n\tlocal diff = Date('currentdate') - date\n\tif diff.isnegative or diff.years > 150 then\n\t\treturn message('\u8ba1\u7b97\u5e74\u9f84\u6240\u9700\u7684\u51fa\u751f\u65e5\u671f\u65e0\u6548')\n\tend\n\tlocal disp, show = 'disp_raw', 'y'\n\tif diff.years < 2 then\n\t\tdisp = 'disp_age'\n\t\tif diff.years == 0 and diff.months == 0 then\n\t\t\tshow = 'd'\n\t\telse\n\t\t\tshow = 'm'\n\t\tend\n\tend\n\tlocal result = '%-Y\u5e74%B\u6708%-d\u65e5'\n\tresult = '\uff08<span class=\"bday\">%-Y-%m-%d</span>) </span>' .. result\n\tresult = '<span style=\"display:none\"> ' ..\n\t\tdate:text(result) ..\n\t\t'<span class=\"noprint ForceAgeToShow\"> ' ..\n\t\t'\uff08' ..\n\t\tdateDifference({\n\t\t\tdiff = diff,\n\t\t\tshow = show,\n\t\t\tabbr = 'abbr_off',\n\t\t\tdisp = disp,\n\t\t\tsep = 'sep_space',\n\t\t}) ..\n\t\t'\uff09</span>'\n\tlocal warnings = tonumber(frame.args.warnings)\n\tif warnings and warnings > 0 then\n\t\tlocal good = {\n\t\t\tdf = true,\n\t\t\tmf = true,\n\t\t\tday = true,\n\t\t\tday1 = true,\n\t\t\tmonth = true,\n\t\t\tmonth1 = true,\n\t\t\tyear = true,\n\t\t\tyear1 = true,\n\t\t}\n\t\tlocal invalid\n\t\tlocal imax = options.textdates and 1 or 3\n\t\tfor k, _ in pairs(args) do\n\t\t\tif type(k) == 'number' then\n\t\t\t\tif k > imax then\n\t\t\t\t\tinvalid = tostring(k)\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tif not good[k] then\n\t\t\t\t\tinvalid = k\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif invalid then\n\t\t\tresult = result .. message(invalid .. '\u53c2\u6570\u65e0\u6548', 'warning')\n\t\tend\n\tend\n\treturn result\nend\n\nlocal function dateToGsd(frame)\n\t-- Implement [[Template:Gregorian serial date]].\n\t-- Return Gregorian serial date of the given date, or the current date.\n\t-- The returned value is negative for dates before 1 January 1 AD\n\t-- despite the fact that GSD is not defined for such dates.\n\tlocal date = getDates(frame, { wantMixture=true, single=true })\n\tif type(date) == 'string' then\n\t\treturn date\n\tend\n\treturn tostring(date.gsd)\nend\n\nlocal function jdToDate(frame)\n\t-- Return formatted date from a Julian date.\n\t-- The result includes a time if the input includes a fraction.\n\t-- The word 'Julian' is accepted for the Julian calendar.\n\tlocal Date = getExports(frame)\n\tlocal args = frame:getParent().args\n\tlocal date = Date('juliandate', args[1], args[2])\n\tif date then\n\t\treturn date:text()\n\tend\n\treturn message('\u9700\u8981\u6709\u6548\u7684\u5112\u7565\u5386\u65e5\u671f')\nend\n\nlocal function dateToJd(frame)\n\t-- Return Julian date (a number) from a date which may include a time,\n\t-- or the current date ('currentdate') or current date and time ('currentdatetime').\n\t-- The word 'Julian' is accepted for the Julian calendar.\n\tlocal Date = getExports(frame)\n\tlocal args = frame:getParent().args\n\tlocal date = Date(args[1], args[2], args[3], args[4], args[5], args[6], args[7])\n\tif date then\n\t\treturn tostring(date.jd)\n\tend\n\treturn message('\u9700\u8981\u6709\u6548\u7684\u5e74/\u6708/\u65e5\u6216\u201ccurrentdate\u201d\uff08\u5f53\u524d\uff09')\nend\n\nlocal function timeInterval(frame)\n\t-- Implement [[Template:Time interval]].\n\t-- There are two positional arguments: date1, date2.\n\t-- The default for each is the current date and time.\n\t-- Result is date2 - date1 formatted.\n\tlocal Date = getExports(frame)\n\tlocal args = frame:getParent().args\n\tlocal parms = {\n\t\twantDuration = yes(args.duration),\n\t\trange = yes(args.range) or (args.range == 'dash' and 'dash' or nil),\n\t\twantSc = yes(args.sc),\n\t}\n\tlocal fix = yes(args.fix) and 'fix' or ''\n\tlocal date1 = Date(fix, 'partial', stripToNil(args[1]) or 'currentdatetime')\n\tif not date1 then\n\t\treturn message('\u7b2c\u4e00\u4e2a\u53c2\u6570\u4e2d\u7684\u5f00\u59cb\u65e5\u671f\u65e0\u6548')\n\tend\n\tlocal date2 = Date(fix, 'partial', stripToNil(args[2]) or 'currentdatetime')\n\tif not date2 then\n\t\treturn message('\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4e2d\u7684\u7ed3\u675f\u65e5\u671f\u65e0\u6548')\n\tend\n\tparms.diff = date2 - date1\n\tfor argname, translate in pairs(translateParameters) do\n\t\tlocal parm = stripToNil(args[argname])\n\t\tif parm then\n\t\t\tparm = translate[parm]\n\t\t\tif parm == nil then  -- test for nil because false is a valid setting\n\t\t\t\treturn message('\u53c2\u6570' .. argname .. '=' .. args[argname] .. '\u65e0\u6548')\n\t\t\tend\n\t\t\tparms[argname] = parm\n\t\tend\n\tend\n\tif parms.round then\n\t\tlocal round = parms.round\n\t\tlocal show = parms.show\n\t\tif round ~= 'on' then\n\t\t\tif show then\n\t\t\t\tif show.id ~= round then\n\t\t\t\t\treturn message('\u53c2\u6570show=' .. args.show .. '\u4e0eround=' .. args.round .. '\u51b2\u7a81')\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tparms.show = translateParameters.show[round]\n\t\t\tend\n\t\tend\n\t\tparms.round = true\n\tend\n\treturn dateDifference(parms)\nend\n\nreturn {\n\tage_generic = ageGeneric,           -- can emulate several age templates\n\tbirth_date_and_age = bda,           -- Template:Birth_date_and_age\n\tgsd = dateToGsd,                    -- Template:Gregorian_serial_date\n\textract = dateExtract,              -- Template:Extract\n\tjd_to_date = jdToDate,              -- Template:?\n\tJULIANDAY = dateToJd,               -- Template:JULIANDAY\n\ttime_interval = timeInterval,       -- Template:Time_interval\n}"}}}