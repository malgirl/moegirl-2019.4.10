{"parse":{"title":"\u6a21\u5757:Arguments","pageid":142411,"wikitext":{"*":"-- This module provides easy processing of arguments passed to Scribunto from\n-- #invoke. \u8be5\u6a21\u5757\u65e8\u5728\u4e3a\u5176\u4ed6Lua\u6a21\u5757\u6240\u7528\uff0c\u5b83\u4e0d\u5e94\u8be5\u88ab#invoke\u76f4\u63a5\u8c03\u7528\u3002\n\nlocal libraryUtil = require('libraryUtil')\nlocal checkType = libraryUtil.checkType\n\nlocal arguments = {}\n\n\n-- Generate four different tidyVal functions, so that we don't have to check the\n-- options every time we call it.\n\nlocal function tidyValDefault(key, val)\n\tif type(val) == 'string' then\n\t\tval = val:match('^%s*(.-)%s*$')\n\t\tif val == '' then\n\t\t\treturn nil\n\t\telse\n\t\t\treturn val\n\t\tend\n\telse\n\t\treturn val\n\tend\nend\n\nlocal function tidyValTrimOnly(key, val)\n\tif type(val) == 'string' then\n\t\treturn val:match('^%s*(.-)%s*$')\n\telse\n\t\treturn val\n\tend\nend\n\nlocal function tidyValRemoveBlanksOnly(key, val)\n\tif type(val) == 'string' then\n\t\tif val:find('%S') then\n\t\t\treturn val\n\t\telse\n\t\t\treturn nil\n\t\tend\n\telse\n\t\treturn val\n\tend\nend\n\nlocal function tidyValNoChange(key, val)\n\treturn val\nend\n\nlocal function matchesTitle(given, title)\n\tlocal tp = type( given )\n\treturn (tp == 'string' or tp == 'number') and mw.title.new( given ).prefixedText == title\nend\n\nlocal translate_mt = { __index = function(t, k) return k end }\n\nfunction arguments.getArgs(frame, options)\n\tcheckType('getArgs', 1, frame, 'table', true)\n\tcheckType('getArgs', 2, options, 'table', true)\n\tframe = frame or {}\n\toptions = options or {}\n\n\t--[[\n\t-- Set up argument translation.\n\t--]]\n\toptions.translate = options.translate or {}\n\tif getmetatable(options.translate) == nil then\n\t\tsetmetatable(options.translate, translate_mt)\n\tend\n\tif options.backtranslate == nil then\n\t\toptions.backtranslate = {}\n\t\tfor k,v in pairs(options.translate) do\n\t\t\toptions.backtranslate[v] = k\n\t\tend\n\tend\n\tif options.backtranslate and getmetatable(options.backtranslate) == nil then\n\t\tsetmetatable(options.backtranslate, {\n\t\t\t__index = function(t, k)\n\t\t\t\tif options.translate[k] ~= k then\n\t\t\t\t\treturn nil\n\t\t\t\telse\n\t\t\t\t\treturn k\n\t\t\t\tend\n\t\t\tend\n\t\t})\n\tend\n\n\t--[[\n\t-- Get the argument tables. If we were passed a valid frame object, get the\n\t-- frame arguments (fargs) and the parent frame arguments (pargs), depending\n\t-- on the options set and on the parent frame's availability. If we weren't\n\t-- passed a valid frame object, we are being called from another Lua module\n\t-- or from the debug console, so assume that we were passed a table of args\n\t-- directly, and assign it to a new variable (luaArgs).\n\t--]]\n\tlocal fargs, pargs, luaArgs\n\tif type(frame.args) == 'table' and type(frame.getParent) == 'function' then\n\t\tif options.wrappers then\n\t\t\t--[[\n\t\t\t-- The wrappers option makes Module:Arguments look up arguments in\n\t\t\t-- either the frame argument table or the parent argument table, but\n\t\t\t-- not both. This means that users can use either the #invoke syntax\n\t\t\t-- or a wrapper template without the loss of performance associated\n\t\t\t-- with looking arguments up in both the frame and the parent frame.\n\t\t\t-- Module:Arguments will look up arguments in the parent frame\n\t\t\t-- if it finds the parent frame's title in options.wrapper;\n\t\t\t-- otherwise it will look up arguments in the frame object passed\n\t\t\t-- to getArgs.\n\t\t\t--]]\n\t\t\tlocal parent = frame:getParent()\n\t\t\tif not parent then\n\t\t\t\tfargs = frame.args\n\t\t\telse\n\t\t\t\tlocal title = parent:getTitle():gsub('/sandbox$', '')\n\t\t\t\tlocal found = false\n\t\t\t\tif matchesTitle(options.wrappers, title) then\n\t\t\t\t\tfound = true\n\t\t\t\telseif type(options.wrappers) == 'table' then\n\t\t\t\t\tfor _,v in pairs(options.wrappers) do\n\t\t\t\t\t\tif matchesTitle(v, title) then\n\t\t\t\t\t\t\tfound = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\t-- We test for false specifically here so that nil (the default) acts like true.\n\t\t\t\tif found or options.frameOnly == false then\n\t\t\t\t\tpargs = parent.args\n\t\t\t\tend\n\t\t\t\tif not found or options.parentOnly == false then\n\t\t\t\t\tfargs = frame.args\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\t-- options.wrapper isn't set, so check the other options.\n\t\t\tif not options.parentOnly then\n\t\t\t\tfargs = frame.args\n\t\t\tend\n\t\t\tif not options.frameOnly then\n\t\t\t\tlocal parent = frame:getParent()\n\t\t\t\tpargs = parent and parent.args or nil\n\t\t\tend\n\t\tend\n\t\tif options.parentFirst then\n\t\t\tfargs, pargs = pargs, fargs\n\t\tend\n\telse\n\t\tluaArgs = frame\n\tend\n\n\t-- Set the order of precedence of the argument tables. If the variables are\n\t-- nil, nothing will be added to the table, which is how we avoid clashes\n\t-- between the frame/parent args and the Lua args.\n\tlocal argTables = {fargs}\n\targTables[#argTables + 1] = pargs\n\targTables[#argTables + 1] = luaArgs\n\n\t--[[\n\t-- Generate the tidyVal function. If it has been specified by the user, we\n\t-- use that; if not, we choose one of four functions depending on the\n\t-- options chosen. This is so that we don't have to call the options table\n\t-- every time the function is called.\n\t--]]\n\tlocal tidyVal = options.valueFunc\n\tif tidyVal then\n\t\tif type(tidyVal) ~= 'function' then\n\t\t\terror(\n\t\t\t\t\"bad value assigned to option 'valueFunc'\"\n\t\t\t\t\t.. '(function expected, got '\n\t\t\t\t\t.. type(tidyVal)\n\t\t\t\t\t.. ')',\n\t\t\t\t2\n\t\t\t)\n\t\tend\n\telseif options.trim ~= false then\n\t\tif options.removeBlanks ~= false then\n\t\t\ttidyVal = tidyValDefault\n\t\telse\n\t\t\ttidyVal = tidyValTrimOnly\n\t\tend\n\telse\n\t\tif options.removeBlanks ~= false then\n\t\t\ttidyVal = tidyValRemoveBlanksOnly\n\t\telse\n\t\t\ttidyVal = tidyValNoChange\n\t\tend\n\tend\n\n\t--[[\n\t-- Set up the args, metaArgs and nilArgs tables. args will be the one\n\t-- accessed from functions, and metaArgs will hold the actual arguments. Nil\n\t-- arguments are memoized in nilArgs, and the metatable connects all of them\n\t-- together.\n\t--]]\n\tlocal args, metaArgs, nilArgs, metatable = {}, {}, {}, {}\n\tsetmetatable(args, metatable)\n\n\tlocal function mergeArgs(tables)\n\t\t--[[\n\t\t-- Accepts multiple tables as input and merges their keys and values\n\t\t-- into one table. If a value is already present it is not overwritten;\n\t\t-- tables listed earlier have precedence. We are also memoizing nil\n\t\t-- values, which can be overwritten if they are 's' (soft).\n\t\t--]]\n\t\tfor _, t in ipairs(tables) do\n\t\t\tfor key, val in pairs(t) do\n\t\t\t\tif metaArgs[key] == nil and nilArgs[key] ~= 'h' then\n\t\t\t\t\tlocal tidiedVal = tidyVal(key, val)\n\t\t\t\t\tif tidiedVal == nil then\n\t\t\t\t\t\tnilArgs[key] = 's'\n\t\t\t\t\telse\n\t\t\t\t\t\tmetaArgs[key] = tidiedVal\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\t--[[\n\t-- Define metatable behaviour. Arguments are memoized in the metaArgs table,\n\t-- and are only fetched from the argument tables once. Fetching arguments\n\t-- from the argument tables is the most resource-intensive step in this\n\t-- module, so we try and avoid it where possible. For this reason, nil\n\t-- arguments are also memoized, in the nilArgs table. Also, we keep a record\n\t-- in the metatable of when pairs and ipairs have been called, so we do not\n\t-- run pairs and ipairs on the argument tables more than once. We also do\n\t-- not run ipairs on fargs and pargs if pairs has already been run, as all\n\t-- the arguments will already have been copied over.\n\t--]]\n\n\tmetatable.__index = function (t, key)\n\t\t--[[\n\t\t-- Fetches an argument when the args table is indexed. First we check\n\t\t-- to see if the value is memoized, and if not we try and fetch it from\n\t\t-- the argument tables. When we check memoization, we need to check\n\t\t-- metaArgs before nilArgs, as both can be non-nil at the same time.\n\t\t-- If the argument is not present in metaArgs, we also check whether\n\t\t-- pairs has been run yet. If pairs has already been run, we return nil.\n\t\t-- This is because all the arguments will have already been copied into\n\t\t-- metaArgs by the mergeArgs function, meaning that any other arguments\n\t\t-- must be nil.\n\t\t--]]\n\t\tif type(key) == 'string' then\n\t\t\tkey = options.translate[key]\n\t\tend\n\t\tlocal val = metaArgs[key]\n\t\tif val ~= nil then\n\t\t\treturn val\n\t\telseif metatable.donePairs or nilArgs[key] then\n\t\t\treturn nil\n\t\tend\n\t\tfor _, argTable in ipairs(argTables) do\n\t\t\tlocal argTableVal = tidyVal(key, argTable[key])\n\t\t\tif argTableVal ~= nil then\n\t\t\t\tmetaArgs[key] = argTableVal\n\t\t\t\treturn argTableVal\n\t\t\tend\n\t\tend\n\t\tnilArgs[key] = 'h'\n\t\treturn nil\n\tend\n\n\tmetatable.__newindex = function (t, key, val)\n\t\t-- This function is called when a module tries to add a new value to the\n\t\t-- args table, or tries to change an existing value.\n\t\tif type(key) == 'string' then\n\t\t\tkey = options.translate[key]\n\t\tend\n\t\tif options.readOnly then\n\t\t\terror(\n\t\t\t\t'could not write to argument table key \"'\n\t\t\t\t\t.. tostring(key)\n\t\t\t\t\t.. '\"; the table is read-only',\n\t\t\t\t2\n\t\t\t)\n\t\telseif options.noOverwrite and args[key] ~= nil then\n\t\t\terror(\n\t\t\t\t'could not write to argument table key \"'\n\t\t\t\t\t.. tostring(key)\n\t\t\t\t\t.. '\"; overwriting existing arguments is not permitted',\n\t\t\t\t2\n\t\t\t)\n\t\telseif val == nil then\n\t\t\t--[[\n\t\t\t-- If the argument is to be overwritten with nil, we need to erase\n\t\t\t-- the value in metaArgs, so that __index, __pairs and __ipairs do\n\t\t\t-- not use a previous existing value, if present; and we also need\n\t\t\t-- to memoize the nil in nilArgs, so that the value isn't looked\n\t\t\t-- up in the argument tables if it is accessed again.\n\t\t\t--]]\n\t\t\tmetaArgs[key] = nil\n\t\t\tnilArgs[key] = 'h'\n\t\telse\n\t\t\tmetaArgs[key] = val\n\t\tend\n\tend\n\n\tlocal function translatenext(invariant)\n\t\tlocal k, v = next(invariant.t, invariant.k)\n\t\tinvariant.k = k\n\t\tif k == nil then\n\t\t\treturn nil\n\t\telseif type(k) ~= 'string' or not options.backtranslate then\n\t\t\treturn k, v\n\t\telse\n\t\t\tlocal backtranslate = options.backtranslate[k]\n\t\t\tif backtranslate == nil then\n\t\t\t\t-- Skip this one. This is a tail call, so this won't cause stack overflow\n\t\t\t\treturn translatenext(invariant)\n\t\t\telse\n\t\t\t\treturn backtranslate, v\n\t\t\tend\n\t\tend\n\tend\n\n\tmetatable.__pairs = function ()\n\t\t-- Called when pairs is run on the args table.\n\t\tif not metatable.donePairs then\n\t\t\tmergeArgs(argTables)\n\t\t\tmetatable.donePairs = true\n\t\tend\n\t\treturn translatenext, { t = metaArgs }\n\tend\n\n\tlocal function inext(t, i)\n\t\t-- This uses our __index metamethod\n\t\tlocal v = t[i + 1]\n\t\tif v ~= nil then\n\t\t\treturn i + 1, v\n\t\tend\n\tend\n\n\tmetatable.__ipairs = function (t)\n\t\t-- Called when ipairs is run on the args table.\n\t\treturn inext, t, 0\n\tend\n\n\treturn args\nend\n\nreturn arguments"}}}