{"parse":{"title":"\u6a21\u5757:Math","pageid":144147,"wikitext":{"*":"--[[\n\u5f15\u81ea\u7ef4\u57fa\u767e\u79d1\uff08enwiki:Module:Math\uff0coldid=613638641\uff09\n\nThis module provides a number of basic mathematical operations.\n\n]]\n\nlocal yesno, getArgs -- lazily initialized\n\nlocal p = {} -- Holds functions to be returned from #invoke, and functions to make available to other Lua modules.\nlocal wrap = {} -- Holds wrapper functions that process arguments from #invoke. These act as intemediary between functions meant for #invoke and functions meant for Lua.\n\n--[[\nHelper functions used to avoid redundant code.\n]]\n\nlocal function err(msg)\n\t-- Generates wikitext error messages.\n\treturn mw.ustring.format('<strong class=\"error\">Formatting error: %s</strong>', msg)\nend\n\nlocal function unpackNumberArgs(args)\n\t-- Returns an unpacked list of arguments specified with numerical keys.\n\tlocal ret = {}\n\tfor k, v in pairs(args) do\n\t\tif type(k) == 'number' then\n\t\t\ttable.insert(ret, v)\n\t\tend\n\tend\n\treturn unpack(ret)\nend\n\nlocal function makeArgArray(...)\n\t-- Makes an array of arguments from a list of arguments that might include nils.\n\tlocal args = {...} -- Table of arguments. It might contain nils or non-number values, so we can't use ipairs.\n\tlocal nums = {} -- Stores the numbers of valid numerical arguments.\n\tlocal ret = {}\n\tfor k, v in pairs(args) do\n\t\tv = p._cleanNumber(v)\n\t\tif v then\n\t\t\tnums[#nums + 1] = k\n\t\t\targs[k] = v\n\t\tend\n\tend\n\ttable.sort(nums)\n\tfor i, num in ipairs(nums) do\n\t\tret[#ret + 1] = args[num]\n\tend\n\treturn ret\nend\n\nlocal function applyFuncToArgs(func, ...)\n\t-- Use a function on all supplied arguments, and return the result. The function must accept two numbers as parameters,\n\t-- and must return a number as an output. This number is then supplied as input to the next function call.\n\tlocal vals = makeArgArray(...)\t\n\tlocal count = #vals -- The number of valid arguments\n\tif count == 0 then return\n\t\t-- Exit if we have no valid args, otherwise removing the first arg would cause an error.\n\t\tnil, 0\n\tend \n\tlocal ret = table.remove(vals, 1)\n\tfor _, val in ipairs(vals) do\n\t\tret = func(ret, val)\n\tend\n\treturn ret, count\nend\n\n--[[\nrandom\n\nGenerate a random number\n\nUsage:\n{{#invoke: Math | random }}\n{{#invoke: Math | random | maximum value }}\n{{#invoke: Math | random | minimum value | maximum value }}\n]]\n\nfunction wrap.random(args)\n\tlocal first = p._cleanNumber(args[1])\n\tlocal second = p._cleanNumber(args[2])\n\treturn p._random(first, second)\nend\n\nfunction p._random(first, second)\n\tmath.randomseed(mw.site.stats.edits + mw.site.stats.pages + os.time() + math.floor(os.clock() * 1000000000))\n\t-- math.random will throw an error if given an explicit nil parameter, so we need to use if statements to check the params.\n\tif first and second then\n\t\tif first <= second then -- math.random doesn't allow the first number to be greater than the second.\n\t\t\treturn math.random(first, second)\n\t\tend\n\telseif first then\n\t\treturn math.random(first)\n\telse\n\t\treturn math.random()\n\tend\nend\n\n--[[\norder\n\nDetermine order of magnitude of a number\n\nUsage:\n{{#invoke: Math | order | value }}\n]]\n\nfunction wrap.order(args)\n\tlocal input_string = (args[1] or args.x or '0');\n\tlocal input_number = p._cleanNumber(input_string);\n\tif input_number == nil then\n\t\treturn err('order of magnitude input appears non-numeric')\n\telse\n\t\treturn p._order(input_number)\n\tend    \nend\n\nfunction p._order(x)\n\tif x == 0 then return 0 end\n\treturn math.floor(math.log10(math.abs(x)))\nend\n\n--[[\nprecision\n\nDetemines the precision of a number using the string representation\n\nUsage:\n{{ #invoke: Math | precision | value }}\n]]\n\nfunction wrap.precision(args)\n\tlocal input_string = (args[1] or args.x or '0');\n\tlocal trap_fraction = args.check_fraction;\n\tlocal input_number;\n\n\tif not yesno then\n\t\tyesno = require('Module:Yesno')\n\tend\n\tif yesno(trap_fraction, true) then -- Returns true for all input except nil, false, \"no\", \"n\", \"0\" and a few others. See [[Module:Yesno]].\n\t\tlocal pos = string.find(input_string, '/', 1, true);\n\t\tif pos ~= nil then\n\t\t\tif string.find(input_string, '/', pos + 1, true) == nil then\n\t\t\t\tlocal denominator = string.sub(input_string, pos+1, -1);\n\t\t\t\tlocal denom_value = tonumber(denominator);\n\t\t\t\tif denom_value ~= nil then\n\t\t\t\t\treturn math.log10(denom_value);\n\t\t\t\tend\n\t\t\tend                        \n\t\tend\n\tend    \n\n\tinput_number, input_string = p._cleanNumber(input_string);\n\tif input_string == nil then\n\t\treturn err('precision input appears non-numeric')\n\telse\n\t\treturn p._precision(input_string)\n\tend    \nend\n\nfunction p._precision(x)\n\tif type(x) == 'number' then\n\t\tx = tostring(x)\n\tend\n\tx = string.upper(x)\n\n\tlocal decimal = x:find('%.')\n\tlocal exponent_pos = x:find('E')\n\tlocal result = 0;\n\n\tif exponent_pos ~= nil then\n\t\tlocal exponent = string.sub(x, exponent_pos + 1)\n\t\tx = string.sub(x, 1, exponent_pos - 1)\n\t\tresult = result - tonumber(exponent)\n\tend    \n\n\tif decimal ~= nil then\n\t\tresult = result + string.len(x) - decimal\n\t\treturn result\n\tend\n\n\tlocal pos = string.len(x);\n\twhile x:byte(pos) == string.byte('0') do\n\t\tpos = pos - 1\n\t\tresult = result - 1\n\t\tif pos <= 0 then\n\t\t\treturn 0\n\t\tend\n\tend\n\n\treturn result\nend\n\n--[[\nmax\n\nFinds the maximum argument\n\nUsage:\n{{#invoke:Math| max | value1 | value2 | ... }}\n\nNote, any values that do not evaluate to numbers are ignored.\n]]\n\nfunction wrap.max(args)\n\treturn p._max(unpackNumberArgs(args))\nend\n\nfunction p._max(...)\n\tlocal function maxOfTwo(a, b)\n\t\tif a > b then\n\t\t\treturn a\n\t\telse\n\t\t\treturn b\n\t\tend\n\tend\n\tlocal max_value = applyFuncToArgs(maxOfTwo, ...)\n\tif max_value then\n\t\treturn max_value\n\tend\nend\n\n--[[\nmin \n\nFinds the minimum argument\n\nUsage:\n{{#invoke:Math| min | value1 | value2 | ... }}\nOR\n{{#invoke:Math| min }}\n\nWhen used with no arguments, it takes its input from the parent\nframe.  Note, any values that do not evaluate to numbers are ignored.\n]]\n\nfunction wrap.min(args)\n\treturn p._min(unpackNumberArgs(args))\nend\n\nfunction p._min(...)\n\tlocal function minOfTwo(a, b)\n\t\tif a < b then\n\t\t\treturn a\n\t\telse\n\t\t\treturn b\n\t\tend\n\tend\n\tlocal min_value = applyFuncToArgs(minOfTwo, ...)\n\tif min_value then\n\t\treturn min_value\n\tend\nend\n\n--[[\naverage \n\nFinds the average\n\nUsage:\n{{#invoke:Math| average | value1 | value2 | ... }}\nOR\n{{#invoke:Math| average }}\n\nNote, any values that do not evaluate to numbers are ignored.\n]]\n\nfunction wrap.average(args)\n\treturn p._average(unpackNumberArgs(args))\nend\n\nfunction p._average(...)\n\tlocal function getSum(a, b)\n\t\treturn a + b\n\tend\n\tlocal sum, count = applyFuncToArgs(getSum, ...)\n\tif not sum then\n\t\treturn 0\n\telse\n\t\treturn sum / count\n\tend\nend\n\n--[[\nround\n\nRounds a number to specified precision\n\nUsage:\n{{#invoke:Math | round | value | precision }}\n\n--]]\n\nfunction wrap.round(args)\n\tlocal value = p._cleanNumber(args[1] or args.value or 0)\n\tlocal precision = p._cleanNumber(args[2] or args.precision or 0)\n\tif value == nil or precision == nil then\n\t\treturn err('round input appears non-numeric')\n\telse\n\t\treturn p._round(value, precision)\n\tend    \nend\n\nfunction p._round(value, precision)\n\tlocal rescale = math.pow(10, precision or 0);\n\treturn math.floor(value * rescale + 0.5) / rescale;\nend\n\n--[[\nmod\n\nImplements the modulo operator\n\nUsage:\n{{#invoke:Math | mod | x | y }}\n\n--]]\n\nfunction wrap.mod(args)\n\tlocal x = p._cleanNumber(args[1])\n\tlocal y = p._cleanNumber(args[2])\n\tif not x then\n\t\treturn err('first argument to mod appears non-numeric')\n\telseif not y then\n\t\treturn err('second argument to mod appears non-numeric')\n\telse\n\t\treturn p._mod(x, y)\n\tend    \nend\n\nfunction p._mod(x, y)\n\tlocal ret = x % y\n\tif not (0 <= ret and ret < y) then\n\t\tret = 0\n\tend\n\treturn ret\nend\n\n--[[\ngcd\n\nCalculates the greatest common divisor of multiple numbers\n\nUsage:\n{{#invoke:Math | gcd | value 1 | value 2 | value 3 | ... }}\n--]]\n\nfunction wrap.gcd(args)\n\treturn p._gcd(unpackNumberArgs(args))\nend\n\nfunction p._gcd(...)\n\tlocal function findGcd(a, b)\n\t\tlocal r = b\n\t\tlocal oldr = a\n\t\twhile r ~= 0 do\n\t\t\tlocal quotient = math.floor(oldr / r)\n\t\t\toldr, r = r, oldr - quotient * r\n\t\tend\n\t\tif oldr < 0 then\n\t\t\toldr = oldr * -1\n\t\tend\n\t\treturn oldr\n\tend\n\tlocal result, count = applyFuncToArgs(findGcd, ...)\n\treturn result\nend\n\n--[[\nprecision_format\n\nRounds a number to the specified precision and formats according to rules \noriginally used for {{template:Rnd}}.  Output is a string.\n\nUsage:\n{{#invoke: Math | precision_format | number | precision }}\n]]\n\nfunction wrap.precision_format(args)\n\tlocal value_string = args[1] or 0\n\tlocal precision = args[2] or 0\n\treturn p._precision_format(value_string, precision)\nend\n\nfunction p._precision_format(value_string, precision)\n\t-- For access to Mediawiki built-in formatter.\n\tlocal lang = mw.getContentLanguage();\n\n\tlocal value\n\tvalue, value_string = p._cleanNumber(value_string)\n\tprecision = p._cleanNumber(precision)\n\n\t-- Check for non-numeric input\n\tif value == nil or precision == nil then\n\t\treturn err('invalid input when rounding')\n\tend\n\n\tlocal current_precision = p._precision(value)\n\tlocal order = p._order(value)\n\n\t-- Due to round-off effects it is neccesary to limit the returned precision under\n\t-- some circumstances because the terminal digits will be inaccurately reported.\n\tif order + precision >= 14 then\n\t\torig_precision = p._precision(value_string)\n\t\tif order + orig_precision >= 14 then\n\t\t\tprecision = 13 - order;        \n\t\tend        \n\tend\n\n\t-- If rounding off, truncate extra digits\n\tif precision < current_precision then\n\t\tvalue = p._round(value, precision)\n\t\tcurrent_precision = p._precision(value)\n\tend    \n\n\tlocal formatted_num = lang:formatNum(math.abs(value))\n\tlocal sign\n\n\t-- Use proper unary minus sign rather than ASCII default\n\tif value < 0 then\n\t\tsign = '\u2212'\n\telse\n\t\tsign = ''\n\tend    \n\n\t-- Handle cases requiring scientific notation\n\tif string.find(formatted_num, 'E', 1, true) ~= nil or math.abs(order) >= 9 then\n\t\tvalue = value * math.pow(10, -order)\n\t\tcurrent_precision = current_precision + order\n\t\tprecision = precision + order\n\t\tformatted_num = lang:formatNum(math.abs(value))\n\telse\n\t\torder = 0;        \n\tend\n\tformatted_num = sign .. formatted_num\n\n\t-- Pad with zeros, if needed    \n\tif current_precision < precision then\n\t\tlocal padding\n\t\tif current_precision <= 0 then\n\t\t\tif precision > 0 then\n\t\t\t\tlocal zero_sep = lang:formatNum(1.1)\n\t\t\t\tformatted_num = formatted_num .. zero_sep:sub(2,2)\n\n\t\t\t\tpadding = precision\n\t\t\t\tif padding > 20 then\n\t\t\t\t\tpadding = 20\n\t\t\t\tend\n\n\t\t\t\tformatted_num = formatted_num .. string.rep('0', padding)\n\t\t\tend            \n\t\telse                   \n\t\t\tpadding = precision - current_precision\n\t\t\tif padding > 20 then\n\t\t\t\tpadding = 20\n\t\t\tend\n\t\t\tformatted_num = formatted_num .. string.rep('0', padding)\n\t\tend\n\tend\n\n\t-- Add exponential notation, if necessary.\n\tif order ~= 0 then\n\t\t-- Use proper unary minus sign rather than ASCII default\n\t\tif order < 0 then\n\t\t\torder = '\u2212' .. lang:formatNum(math.abs(order))\n\t\telse\n\t\t\torder = lang:formatNum(order)\n\t\tend    \n\n\t\tformatted_num = formatted_num .. '<span style=\"margin:0 .15em 0 .25em\">\u00d7</span>10<sup>' .. order .. '</sup>'\n\tend\n\n\treturn formatted_num\nend\n\n--[[\nHelper function that interprets the input numerically.  If the \ninput does not appear to be a number, attempts evaluating it as\na parser functions expression.\n]]\n\nfunction p._cleanNumber(number_string)\n\tif type(number_string) == 'number' then\n\t\t-- We were passed a number, so we don't need to do any processing.\n\t\treturn number_string, tostring(number_string)\n\telseif type(number_string) ~= 'string' or not number_string:find('%S') then\n\t\t-- We were passed a non-string or a blank string, so exit.\n\t\treturn nil, nil;\n\tend\n\n\t-- Attempt basic conversion\n\tlocal number = tonumber(number_string)\n\n\t-- If failed, attempt to evaluate input as an expression\n\tif number == nil then\n\t\tlocal success, result = pcall(mw.ext.ParserFunctions.expr, number_string)\n\t\tif success then\n\t\t\tnumber = tonumber(result)\n\t\t\tnumber_string = tostring(number)\n\t\telse\n\t\t\tnumber = nil\n\t\t\tnumber_string = nil\n\t\tend\n\telse\n\t\tnumber_string = number_string:match(\"^%s*(.-)%s*$\") -- String is valid but may contain padding, clean it.\n\t\tnumber_string = number_string:match(\"^%+(.*)$\") or number_string -- Trim any leading + signs.\n\t\tif number_string:find('^%-?0[xX]') then\n\t\t\t-- Number is using 0xnnn notation to indicate base 16; use the number that Lua detected instead.\n\t\t\tnumber_string = tostring(number)\n\t\tend\n\tend\n\n\treturn number, number_string\nend\n\n--[[\nWrapper function that does basic argument processing. This ensures that all functions from #invoke can use either the current\nframe or the parent frame, and it also trims whitespace for all arguments and removes blank arguments.\n]]\n\nlocal mt = { __index = function(t, k)\n\treturn function(frame)\n\t\tif not getArgs then\n\t\t\tgetArgs = require('Module:Arguments').getArgs\n\t\tend\n\t\treturn wrap[k](getArgs(frame))  -- Argument processing is left to Module:Arguments. Whitespace is trimmed and blank arguments are removed.\n\tend\nend }\n\nreturn setmetatable(p, mt)"}}}