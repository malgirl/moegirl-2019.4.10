{"parse":{"title":"\u6a21\u5757:Multiple image","pageid":230761,"wikitext":{"*":"-- implements [[template:multiple image]]\nlocal p = {}\n\nlocal autoscaledimages\nlocal nonautoscaledimages\n\nlocal function isnotempty(s)\n\treturn s and s:match( '^%s*(.-)%s*$' ) ~= ''\nend\n\nlocal function getdimensions(s, w, h)\n\tif tonumber(w) and tonumber(h) then\n\t\tnonautoscaledimages = true\n\t\treturn tonumber(w), tonumber(h)\n\tend\n\tlocal file = s and mw.title.new('File:' .. mw.uri.decode(mw.ustring.gsub(s,'%|.*$',''), 'WIKI'))\n\tfile = file and file.file or {width = 0, height = 0}\n\tw = tonumber(file.width) or 0\n\th = tonumber(file.height) or 0\n\tautoscaledimages = true\n\treturn w, h\nend\n\nlocal function renderImageCell(image, width, height, link, alt, thumbtime, caption, textalign, istyle)\n\tlocal root = mw.html.create('')\n\n\tlocal altstr = '|alt=' .. (alt or '')\n\tlocal linkstr = link and ('|link=' .. link) or ''\n\tlocal widthstr = '|' .. tostring(width) .. 'px'\n\tlocal thumbtimestr = ''\n\n\tif isnotempty( thumbtime ) then\n\t\tthumbtimestr = '|thumbtime=' .. thumbtime\n\tend\n\n\tlocal imagediv = root:tag('div')\n\timagediv:addClass('thumbimage')\n\timagediv:cssText(istyle)\n\tif( height ) then\n\t\timagediv:css('height', tostring(height) .. 'px')\n\t\timagediv:css('overflow', 'hidden')\n\tend\n\timagediv:wikitext('[[file:' .. image .. widthstr .. linkstr .. altstr .. thumbtimestr .. ']]')\n\tif isnotempty(caption) then\n\t\tlocal captiondiv = root:tag('div')\n\t\tcaptiondiv:addClass('thumbcaption')\n\t\tif isnotempty(textalign) then\n\t\t\tcaptiondiv:addClass('text-align-' .. textalign)\n\t\tend\n\t\tcaptiondiv:wikitext(caption)\n\tend\n\treturn tostring(root)\nend\n\nlocal function getWidth(w1, w2)\n\tlocal w\n\tif isnotempty(w1) then\n\t\tw = tonumber(w1)\n\telseif isnotempty(w2) then\n\t\tw = tonumber(w2)\n\tend\n\treturn w or 200\nend\n\nlocal function getPerRow(pstr, ic)\n\t-- split string into array using any non-digit as a dilimiter\n\tlocal pr = mw.text.split(pstr or '', '[^%d][^%d]*')\n\t-- if split failed, assume a single row\n\tif (#pr < 1) then\n\t\tpr = {tostring(ic)}\n\tend\n\t-- convert the array of strings to an array of numbers,\n\t-- adding any implied/missing numbers at the end of the array\n\tlocal r = 1\n\tlocal thisrow = tonumber(pr[1] or ic) or ic\n\tlocal prownum = {}\n\twhile( ic > 0 ) do\n\t\tprownum[r] = thisrow\n\t\tic = ic - thisrow\n\t\tr = r + 1\n\t\t-- use the previous if the next is missing and\n\t\t-- make sure we don't overstep the number of images\n\t\tthisrow = math.min(tonumber(pr[r] or thisrow) or ic, ic)\n\tend\n\treturn prownum\nend\n\nlocal function renderMultipleImages(frame)\n\tlocal pargs = frame:getParent().args\n\tlocal args = frame.args\n\tlocal width = pargs['width'] or ''\n\tlocal dir = pargs['direction'] or ''\n\tlocal border = pargs['border'] or args['border'] or ''\n\tlocal align = pargs['align'] or args['align'] or (border == 'infobox' and 'center' or '')\n\tlocal capalign = pargs['caption_align'] or args['caption_align'] or ''\n\tlocal totalwidth = pargs['total_width'] or args['total_width'] or ''\n\tlocal imgstyle = pargs['image_style'] or args['image_style']\n\tlocal header = pargs['header'] or pargs['title'] or ''\n\tlocal footer = pargs['footer'] or ''\n\tlocal imagegap = tonumber(pargs['image_gap'] or '1') or 1\n\tlocal perrow = nil\n\tlocal thumbclass = {\n\t\t[\"left\"] = 'tleft',\n\t\t[\"none\"] = 'tnone',\n\t\t[\"center\"] = 'tnone',\n\t\t[\"centre\"] = 'tnone',\n\t\t[\"right\"] = 'tright'\n\t\t}\n\n\t-- find all the nonempty images\n\tlocal imagenumbers = {}\n\tlocal imagecount = 0\n\tfor k, v in pairs( pargs ) do\n\t\tlocal i = tonumber(tostring(k):match( '^%s*image([%d]+)%s*$' ) or '0')\n\t\tif( i > 0 and isnotempty(v) ) then\n\t\t\ttable.insert( imagenumbers, i)\n\t\t\timagecount = imagecount + 1\n\t\tend\n\tend\n\n\t-- sort the imagenumbers\n\ttable.sort(imagenumbers)\n\n\t-- create an array with the number of images per row\n\tperrow = getPerRow(dir == 'vertical' and '1' or pargs['perrow'], imagecount)\n\n\t-- compute the number of rows\n\tlocal rowcount = #perrow\n\n\t-- store the image widths and compute row widths and maximum row width\n\tlocal heights = {}\n\tlocal widths = {}\n\tlocal widthmax = 0\n\tlocal widthsum = {}\n\tlocal k = 0\n\tfor r=1,rowcount do\n\t\twidthsum[r] = 0\n\t\tfor c=1,perrow[r] do\n\t\t\tk = k + 1\n\t\t\tif( k <= imagecount ) then\n\t\t\t\tlocal i = imagenumbers[k]\n\t\t\t\tif( isnotempty(totalwidth) ) then\n\t\t\t\t\twidths[k], heights[k] = getdimensions(pargs['image' .. i], pargs['width' .. i], pargs['height' .. i])\n\t\t\t\telse\n\t\t\t\t\twidths[k] = getWidth(width, pargs['width' .. i])\n\t\t\t\tend\n\t\t\t\twidthsum[r] = widthsum[r] + widths[k]\n\t\t\tend\n\t\tend\n\t\twidthmax = math.max(widthmax, widthsum[r])\n\tend\n\n\t-- make sure the gap is non-negative\n\tif imagegap < 0 then imagegap = 0 end\n\n\t-- if total_width has been specified, rescale the image widths\n\tif( isnotempty(totalwidth) ) then\n\t\ttotalwidth = tonumber(totalwidth)\n\t\twidthmax = 0\n\t\tlocal k = 0\n\t\tfor r=1,rowcount do\n\t\t\tlocal koffset = k\n\t\t\tlocal tw = totalwidth - (3 + imagegap) * (perrow[r] - 1) - 12\n\t\t\tlocal ar = {}\n\t\t\tlocal arsum = 0\n\t\t\tfor j=1,perrow[r] do\n\t\t\t\tk = k + 1\n\t\t\t\tif( k<= imagecount ) then\n\t\t\t\t\tlocal i = imagenumbers[k]\n\t\t\t\t\tlocal h = heights[k] or 0\n\t\t\t\t\tif (h > 0) then\n\t\t\t\t\t\tar[j] = widths[k]/h\n\t\t\t\t\t\theights[k] = h\n\t\t\t\t\telse\n\t\t\t\t\t\tar[j] = widths[k]/100\n\t\t\t\t\tend\n\t\t\t\t\tarsum = arsum + ar[j]\n\t\t\t\tend\n\t\t\tend\n\t\t\tlocal ht = tw/arsum\n\t\t\tlocal ws = 0\n\t\t\tk = koffset\n\t\t\tfor j=1,perrow[r] do\n\t\t\t\tk = k + 1\n\t\t\t\tif( k<= imagecount ) then\n\t\t\t\t\tlocal i = imagenumbers[k]\n\t\t\t\t\twidths[k] = math.floor(ar[j]*ht + 0.5)\n\t\t\t\t\tws = ws + widths[k]\n\t\t\t\t\tif heights[k] then\n\t\t\t\t\t\theights[k] = math.floor(ht)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\twidthsum[r] = ws\n\t\t\twidthmax = math.max(widthmax, widthsum[r])\n\t\tend\n\tend\n\n\t-- start building the array of images, if there are images\n\tif( imagecount > 0 ) then\n\t\t-- compute width of outer div\n\t\tlocal bodywidth = 0\n\t\tfor r=1,rowcount do\n\t\t\tif( widthmax == widthsum[r] ) then\n\t\t\t\tbodywidth = widthmax + (3 + imagegap) * (perrow[r] - 1) + 12\n\t\t\tend\n\t\tend\n\t\t-- The body has a min-width of 100, which needs to be taken into account on specific widths\n\t\tbodywidth = math.max( 100, bodywidth - 8);\n\n\t\tlocal bg = pargs['background color'] or ''\n\t\t-- create the array of images\n\t\tlocal root = mw.html.create('div')\n\t\troot:addClass('thumb')\n\t\troot:addClass('tmulti')\n\t\troot:addClass(thumbclass[align] or 'tright')\n\n\t\tif( align == 'center' or align == 'centre' ) then\n\t\t\troot:addClass('center')\n\t\tend\n\t\tif( bg ~= '' ) then\n\t\t\troot:css('background-color', bg)\n\t\tend\n\n\t\tlocal div = root:tag('div')\n\t\tdiv:addClass('thumbinner')\n\t\tdiv:css('width', tostring(bodywidth) .. 'px')\n\t\t\t:css('max-width', tostring(bodywidth) .. 'px')\n\t\tif( bg ~= '' ) then\n\t\t\tdiv:css('background-color', bg)\n\t\tend\n\t\tif( border == 'infobox' or border == 'none') then\n\t\t\tdiv:css('border', 'none')\n\t\tend\n\t\t-- add the header\n\t\tif( isnotempty(header) ) then\n\t\t\tdiv:tag('div')\n\t\t\t\t:addClass('trow')\n\t\t\t\t:tag('div')\n\t\t\t\t\t:addClass('theader')\n\t\t\t\t\t:css('text-align', pargs['header_align'] or 'center')\n\t\t\t\t\t:css('background-color', pargs['header_background'] or 'transparent')\n\t\t\t\t\t:wikitext(header)\n\t\tend\n\t\t-- loop through the images\n\t\tlocal k = 0\n\t\tfor r=1,rowcount do\n\t\t\tlocal rowdiv = div:tag('div'):addClass('trow');\n\t\t\tfor j=1,perrow[r] do\n\t\t\t\tk = k + 1\n\t\t\t\tif( k <= imagecount ) then\n\t\t\t\t\tlocal imagediv = rowdiv:tag('div')\n\t\t\t\t\timagediv:addClass('tsingle')\n\t\t\t\t\tif bg ~= '' then\n\t\t\t\t\t\timagediv:css('background-color', bg);\n\t\t\t\t\tend\n\t\t\t\t\tif ((imagegap > 1) and (j < perrow[r])) then\n\t\t\t\t\t\timagediv:css('margin-right', tostring(imagegap) .. 'px')\n\t\t\t\t\tend\n\t\t\t\t\tlocal i = imagenumbers[k]\n\t\t\t\t\tlocal img = pargs['image' .. i]\n\t\t\t\t\tlocal w = widths[k]\n\t\t\t\t\timagediv:css('width', tostring(2 + w) .. 'px')\n\t\t\t\t\t\t:css('max-width', tostring(2 + w) .. 'px')\n\t\t\t\t\timagediv:wikitext(renderImageCell(img, w, heights[k],\n\t\t\t\t\t\tpargs['link' .. i], pargs['alt' .. i],\n\t\t\t\t\t\tpargs['thumbtime' .. i], pargs['caption' .. i], capalign, imgstyle))\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t-- add the footer\n\t\tif( isnotempty(footer) ) then\n\t\t\tdiv:tag('div')\n\t\t\t\t:addClass('trow')\n\t\t\t\t:tag('div')\n\t\t\t\t\t:addClass('thumbcaption')\n\t\t\t\t\t:css('text-align', pargs['footer_align'] or args['footer_align'] or 'left')\n\t\t\t\t\t:css('background-color', pargs['footer_background'] or 'transparent')\n\t\t\t\t\t:wikitext(footer)\n\t\tend\n\t\treturn tostring(root)\n\tend\n\treturn ''\nend\n\nfunction p.render( frame )\n\tautoscaledimages = false\n\tnonautoscaledimages = false\n\n\treturn frame:extensionTag {name = 'templatestyles', args = {src = 'Multiple image/styles.css', wrapper = \".tmulti\"}}\n\t\t.. renderMultipleImages( frame )\nend\n\nreturn p"}}}