{"parse":{"title":"\u6a21\u5757:Mw","pageid":264596,"wikitext":{"*":"local extensiontags = {\n    nowiki = true,\n    ref = true,\n    gallery = true,\n    pre = true,\n    source = true,\n    categorytree = true,\n    charinsert = true,\n    hiero = true,\n    imagemap = true,\n    inputbox = true,\n    math = true,\n    poem = true,\n    ref = true,\n    references = true,\n    syntaxhighlight = true,\n    timeline = true,\n}\n\nlocal text = {\n    -- This returns a string with HTML character entities for wikitext markup characters.\n    -- FIXME: Space at the start of a line isn't handled.\n    escape = function (text)\n        text = text:gsub( '[&\\'%[%]{|}]', {    \n                ['&'] = '&#38;',    \n                [\"'\"] = '&#39;',\t\n                ['['] = '&#91;',\t\n                [']'] = '&#93;',\t\n                ['{'] = '&#123;',\t\n                ['|'] = '&#124;',\t\n                ['}'] = '&#125;' } );\n        return text;\n    end,\n}\n\ntext.tag = function (t, frame)\n    local name = t.name or \"!-- --\"\n    local content = t.contents or \"\"\n    if ( extensiontags[name] ) then\n        -- We have to preprocess these, so that they are properly turned into so-called \"strip markers\" in the generated wikitext.\n        if ( not frame ) then error (\"\u8bf7\u63d0\u4f9b\u4e00\u4e2a\u989d\u5916\u7684\u6846\u67b6\u53c2\u6570\u4ee5\u6267\u884c mw.text.tag() \u529f\u80fd\u3002\") end\n        local params = {}\n        for n,v in pairs(t.params) do\n            table.insert(params, \"|\" .. n .. \"=\" .. v)\n        end\n        return frame:preprocess(\"{{#tag:\" .. name .. \"|\" .. content .. table.concat(params) .. \"}}\")\n    else\n        -- Everything else we can just generate directly, without calling the preprocessor.\n        local attrs = {}\n        for n,v in pairs(t.params) do\n            if (v) then\n                table.insert(attrs, n .. \"=\\\"\" .. text.escape(v) .. \"\\\"\")\n            else\n                table.insert(attrs, n)\n            end\n        end\n        if (\"\" == content) then\n            return \"<\" .. name .. \" \" .. table.concat(attrs, \" \") .. \"/>\"\n        else\n            return \"<\" .. name .. \" \" .. table.concat(attrs, \" \") .. \">\" .. content .. \"</\" .. name .. \">\"\n        end\n    end\nend\n\n-- FIXME: How much of the below is obsolete now that we have the mw.uri module?\nlocal url = {\n    server = \"zh.wikipedia.org\",\n    -- Return a string encoded for use in a URL, equivalent to the parser function {{urlencode:}}.\n    --   0-9A-Za-z --> no change\n    --   -._       --> no change\n    --   ' ' --> '+'\n    --   '*' --> '%XX' where XX is hex value of character '*' other than those above\n    encode = function (t)\n        return mw.uri.encode( t );\n    end,\n    -- This returns a string encoded for use in a URL, equivalent to the parser function {{anchorencode:}}.\n    encodeAnchor = function (t)\n        return mw.uri.anchorEncode( t );\n    end,\n}\n\nurl[\"local\"] = function (title, query)\n    return \"/index.php?title=\" .. url.encode(title) .. \"&\" .. query\nend\nurl.full = function (title, query)\n    return \"//\" .. url.server .. \"/index.php?title=\" .. url.encode(title) .. \"&\" .. query\nend\n\n-- Insert as the global functions if they haven't been supplied by Scribunto.\n-- FIXME: I'm told this doesn't work. If not, take it out.\nif ( nil == mw ) then mw = {} end\nif ( nil == mw.text ) then mw.text = text end\nif ( nil == mw.url ) then mw.url = url end\n\n-- Return our replacement functions as this module's own exported function table.\nreturn { url = url, text = text }"}}}