{"parse":{"title":"User:\u7dad\u57fa\u6417\u86cb\u9b3c/editor.js","pageid":207967,"wikitext":{"*":"//<pre>\n\n/**\n * \u539f\u59cb\u51fa\u5904\uff1a[[User:Nbdd0121/tools/wikihighlight.js]]\n *\n * \u53d1\u73b0\u597d\u4e1c\u897f\uff0c\u5f53\u7136\u8981\u611f\u8c22[[User:Nbdd0121]]\u4e86\u3002\u800c\u4e14\uff0c\u6211\u8981\u51c6\u5907\u62ff\u7ed9\u7ef4\u57fa\u5a18\u7528\u4e00\u7528\u4e86\u2026\u2026\n *\n * \u5f85\u5904\u7406\u95ee\u9898\uff1a\n * 1. \u4e09\u4e2a\u82b1\u62ec\u53f7\u4f8b\u5982{{{1|}}}\n * 2. \uff08\u80e1\u6539\u4e00\u4e0b\u7ed3\u679c\u610f\u5916\u4fee\u597d\u4e86orz\uff09\u5728\u840c\u5a18\u767e\u79d1\u5c31\u80fd\u586b\u7f16\u8f91\u6458\u8981\uff0c\u800c\u5230\u4e86\u7ef4\u57fa\u767e\u79d1\u70b9\u51fb\u201c\u6458\u8981\u201d\u65f6\u4f1a\u81ea\u52a8\u8df3\u5230\u7f16\u8f91\u5668\u4e0a\u9762\n * 3. \u6536\u62fe<math>\u7b49\u7279\u6b8a\u6807\u7b7e\n * 4. \u5f88\u660e\u663e\uff0clink-ts\u548cfixlinkstyle\u8dea\u4e86\u2026\u2026\n *\n * \u5176\u4ed6\uff1a\n * \u8981\u4e0d\u8981\u7ed9Wikiplus\u4e5f\u52a0\u4e2a\u7279\u6280\u5462\uff1f\n */\n\n(function() {\nvar next = function () {\n\nCodeMirror.defineMode('mediawiki', function() {\n    function arrayRemove(array, object) {\n        var index = array.indexOf(object);\n        if (index !== -1) array.splice(index, 1);\n    }\n\n    var module = {};\n    var config = {\n        protocols: [\n            'bitcoin:', 'ftp://', 'ftps://', 'geo:', 'git://', 'gopher://', 'http://',\n            'https://', 'irc://', 'ircs://', 'magnet:', 'mailto:', 'mms://', 'news:',\n            'nntp://', 'redis://', 'sftp://', 'sip:', 'sips:', 'sms:', 'ssh://',\n            'svn://', 'tel:', 'telnet://', 'urn:', 'worldwind://', 'xmpp:',\n            // Note '//'' should not be included here\n        ],\n        linktrail: false\n    };\n\n    var EXT_LINK_ADDR = /(?:[0-9.]+|\\[[0-9a-fA-F:.]+\\]|[^\\]\\[<>\"\\s])/; // Match host name, include IPv4, IPv6 and Domain name\n    var EXT_LINK_PROTOCOL_NOREL = new RegExp(config.protocols.join('|'));\n    var EXT_LINK_PROTOCOL = new RegExp(config.protocols.join('|') + '|//');\n    var EXT_LINK_URL = /(?:[0-9.]+|\\[[0-9a-fA-F:.]+\\]|[^\\]\\[<>\"\\s])[^\\]\\[<>\"\\s]*/;\n\n    var ALLOWED_TAGS = {\n        bdi: true,\n        ins: true,\n        u: true,\n        font: true,\n        big: true,\n        small: true,\n        sub: true,\n        sup: true,\n        h1: true,\n        h2: true,\n        h3: true,\n        h4: true,\n        h5: true,\n        h6: true,\n        cite: true,\n        code: true,\n        strike: true,\n        tt: true,\n        var: true,\n        div: true,\n        center: true,\n        blockquote: true,\n        ol: true,\n        ul: true,\n        dl: true,\n        table: true,\n        caption: true,\n        pre: true,\n        ruby: true,\n        rb: true,\n        rp: true,\n        rt: true,\n        rtc: true,\n        p: true,\n        span: true,\n        abbr: true,\n        dfn: true,\n        kbd: true,\n        samp: true,\n        data: true,\n        time: true,\n        mark: true,\n        br: false,\n        wbr: false,\n        hr: false,\n        li: true,\n        dt: true,\n        dd: true,\n        td: true,\n        th: true,\n        tr: true,\n        // These tags are added here but they are not html\n        noinclude: true,\n        includeonly: true,\n        onlyinclude: true\n    };\n\n    function generateStyleMixinTagHandler(style) {\n        return {\n            open: function(stream, state) {\n                state.mixinStyle.push(style);\n            },\n            close: function(stream, state) {\n                var index = state.mixinStyle.indexOf(style);\n                if (index !== -1) state.mixinStyle.splice(index, 1);\n            }\n        };\n    }\n\n    ALLOWED_TAGS.s = ALLOWED_TAGS.strike = ALLOWED_TAGS.del = generateStyleMixinTagHandler('strikethrough'); // Alias\n    ALLOWED_TAGS.b = ALLOWED_TAGS.strong = generateStyleMixinTagHandler('strong'); // Alias\n    ALLOWED_TAGS.i = ALLOWED_TAGS.em = generateStyleMixinTagHandler('em'); // Alias\n\n    ALLOWED_TAGS.nowiki = {\n        open: function(stream, state) {\n            state.unclosedTags.pop();\n            state.handler = parseNowikiTag;\n        },\n        canSelfClose: true\n            // close never reached\n    };\n\n    ALLOWED_TAGS.pre = {\n        open: function(stream, state) {\n            state.mixinStyle.push('mw-pre');\n            state.unclosedTags.pop();\n            state.handler = parsePreTag;\n        },\n        canSelfClose: true\n            // close never reached\n    };\n\n    // Extension:Cite\n    ALLOWED_TAGS.ref = true;\n    ALLOWED_TAGS.references = false;\n\n    // Other extensions\n    ALLOWED_TAGS.categorytree = true;\n    ALLOWED_TAGS.ce = true;\n    ALLOWED_TAGS.charinsert = true;\n    ALLOWED_TAGS.gallery = true;\n    ALLOWED_TAGS.graph = true;\n    ALLOWED_TAGS.hiero = true;\n    ALLOWED_TAGS.imagemap = true;\n    ALLOWED_TAGS.indicator = true;\n    ALLOWED_TAGS.inputbox = true;\n    ALLOWED_TAGS.maplink = true;\n    ALLOWED_TAGS.poem = true;\n\n    // \u5148\u6309 nowiki \u5904\u7406\n    ALLOWED_TAGS.math = ALLOWED_TAGS.nowiki;            // \u5e94\u6309\u7167LaTeX\u5904\u7406\n    ALLOWED_TAGS.quiz = ALLOWED_TAGS.score = ALLOWED_TAGS.source = ALLOWED_TAGS.syntaxhighlight = ALLOWED_TAGS.nowiki;\n    ALLOWED_TAGS.templatedata = ALLOWED_TAGS.nowiki;    // \u5e94\u6309\u7167JSON\u5904\u7406\n    ALLOWED_TAGS.timeline = ALLOWED_TAGS.nowiki;        // \u4e2d\u6587\u7ef4\u57fa\u4e0d\u5e38\u7528\n\n    // Utility\n    function tagCanSelfClose(tagname) {\n        var tag = ALLOWED_TAGS[tagname];\n        if (tag === false) {\n            return true;\n        }\n        if (typeof tag !== 'object') {\n            return false;\n        }\n        if ('canSelfClose' in tag) {\n            return tag.canSelfClose;\n        }\n        return false;\n    }\n\n    function makeStyle(style, state) {\n        if (state.bold) {\n            style += ' strong';\n        }\n        if (state.italic) {\n            style += ' em';\n        }\n        style += ' ' + state.mixinStyle.join(' ');\n        return style;\n    }\n\n    function parseWikitext(stream, state) {\n        var sol = stream.sol();\n\n        var match = stream.match(EXT_LINK_PROTOCOL_NOREL);\n        if (match) {\n            if (stream.match(EXT_LINK_ADDR, false)) {\n                // The URL must looks like a URL\n                state.stack.push(state.handler);\n                state.handler = parseFreeExternalLink;\n                return 'mw-extlink';\n            } else {\n                // Does not look like URL, backUp\n                stream.backUp(match[0].length);\n            }\n        }\n\n        stream.backUp(1);\n        var sow = !/\\w/.exec(stream.next());\n\n        if (sow) {\n            match = stream.match(/(?:ISBN|RFC|PMID)\\s+/);\n            if (match) {\n                if (match[0].startsWith('ISBN')) {\n                    var match2 = stream.match(/(?:97[89][- ]?)?(?:[0-9][- ]?){9}[0-9Xx]\\b/);\n                    if (match2) {\n                        return 'mw-isbn';\n                    }\n                } else {\n                    var match2 = stream.match(/[0-9]+\\b/);\n                    if (match2) {\n                        if (match[0].startsWith('RFC')) {\n                            return 'mw-rfc';\n                        } else {\n                            return 'mw-pmid';\n                        }\n                    }\n                }\n                stream.backUp(match[0].length);\n            }\n        }\n\n        if (sol) {\n            // Table\n            if (stream.match(/\\s*(:*)\\s*(?=\\{\\|)/)) {\n                state.stack.push(state.handler);\n                state.handler = parseTableStart;\n                return 'mw-ident';\n            }\n            switch (stream.peek()) {\n                case '-':\n                    if (stream.match(/-{4,}/)) {\n                        return 'mw-hr';\n                    }\n                    break;\n                case '#': // TODO #REDIRECT\n                case '*':\n                case ';':\n                case ':':\n                    stream.match(/[*#;:]*/);\n                    return 'mw-ident';\n                case ' ':\n                    stream.next();\n                    return 'line-cm-mw-pre';\n                case '=':\n                    match = stream.match(/(={1,6})(?=.+?\\1\\s*$)/);\n                    if (match) {\n                        state.handler = makeParseSectionHeader(match[1].length);\n                        return 'mw-section line-cm-mw-section-' + match[1].length;\n                    }\n                    break;\n            }\n        }\n\n        switch (stream.peek()) {\n            case '\\'':\n                if (stream.match(/'+(?=''''')/)) { // more than 5 apostrophes, only last five are considered\n                    return makeStyle('', state);\n                }\n                if (stream.match(/'(?='''(?!'))/)) { // 4 apostrophes, only last three are considered\n                    return makeStyle('', state);\n                }\n                if (stream.match(\"'''\")) {\n                    if (!state.bold) {\n                        state.bold = true;\n                        return 'mw-bold-start';\n                    } else {\n                        state.bold = false;\n                        return 'mw-bold-end';\n                    }\n                } else if (stream.match(\"''\")) {\n                    if (!state.italic) {\n                        state.italic = true;\n                        return 'mw-italic-start';\n                    } else {\n                        state.italic = false;\n                        return 'mw-italic-end';\n                    }\n                }\n                // TODO Mismatch Recovery\n                break;\n            case '~':\n                var match = stream.match(/~{3,5}/);\n                if (match) {\n                    return 'mw-signature';\n                }\n                break;\n            case '_':\n                if (sow) {\n                    var match = stream.match(/\\b__[A-Z_]+?__/);\n                    if (match) {\n                        return 'mw-magic-word';\n                    }\n                }\n                break;\n            case '{':\n                if (stream.match('{{')) {\n                    state.stack.push(state.handler);\n                    state.handler = parseTemplateName;\n                    return 'mw-template-start';\n                }\n                break;\n            case '[':\n                if (stream.match('[[')) {\n                    if (!stream.match(/[^\\|\\[\\]]+(?:\\|.*?)?\\]\\]/, false)) { // Not a link\n                        return makeStyle('', state);\n                    }\n                    state.stack.push(state.handler);\n                    state.handler = parseLinkTarget;\n                    return 'mw-link-start';\n                } else {\n                    stream.next();\n                    var match = stream.match(EXT_LINK_PROTOCOL);\n                    if (match) {\n                        if (stream.match(EXT_LINK_ADDR, false) && stream.match(/.+?]/, false)) {\n                            // The URL must looks like a URL\n                            state.stack.push(state.handler);\n                            state.handler = parseExternalLink;\n                            // Still have to back up the URL, rendered differently\n                            stream.backUp(match[0].length);\n                            return 'mw-extlink-start';\n                        } else {\n                            // Does not look like URL, backUp\n                            stream.backUp(match[0].length);\n                        }\n                    }\n                    // Bug reported by AnnAngela\n                    // [{{}} does not render correctly\n                    return makeStyle('', state);\n                }\n                break;\n            case '&':\n                return parseEntityOnly(stream, state);\n            case '<':\n                if (stream.match('<!--')) {\n                    state.stack.push(state.handler);\n                    state.handler = parseComment;\n                    return 'mw-comment';\n                }\n                stream.next(); // eat <\n                var closing = !!stream.eat('/');\n                var tagname = stream.match(/\\w+/);\n                if (!tagname || !(tagname[0] in ALLOWED_TAGS)) {\n                    // The eaten ones are treated as plain text if this is not a tag or not allowed\n                    return makeStyle('', state);\n                }\n                tagname = tagname[0];\n                var match = stream.match(/[^<]*?(\\/)?>/, false);\n                if (!match) {\n                    // No closing >, treat as text\n                    return makeStyle('', state);\n                }\n                var selfClose = false;\n                if (match[1]) {\n                    // Self-closing tag processing\n                    if (!closing && !tagCanSelfClose(tagname)) {\n                        // Not self-closing tag, treat as text\n                        return makeStyle('', state);\n                    }\n                    selfClose = true;\n                }\n\n                if (closing) {\n                    var uc = state.unclosedTags.slice();\n                    while (uc.length) {\n                        if (uc.pop() === tagname) {\n                            break;\n                        }\n                    }\n                    // If closing tag\n                    if (state.unclosedTags[uc.length] === tagname) {\n                        state.unclosedTags = uc;\n                        if (stream.match(/[^<]*?>/)) {\n                            if (typeof(ALLOWED_TAGS[tagname]) === 'object')\n                                ALLOWED_TAGS[tagname].close(stream, state);\n\n                            state.handler = state.stack.pop();\n                            return 'mw-tag-close';\n                        }\n                    }\n                    // Otherwise, treat as text\n                    return makeStyle('', state);\n                } else {\n                    if (ALLOWED_TAGS[tagname] && !selfClose) { // If not self-closing\n                        state.unclosedTags.push(tagname);\n                    }\n                    state.stack.push(state.handler);\n                    state.handler = makeParseOpenTag(tagname, selfClose);\n                    return 'mw-tag-open';\n                }\n                break;\n        }\n\n        stream.next();\n        return makeStyle('', state);\n    }\n\n    function parseFreeExternalLink(stream, state) {\n        var match = stream.match(EXT_LINK_URL);\n        var text = match[0];\n\n        // {{, ~~~, '' will start their effect, so detect and correct\n        var match = /\\{\\{|~~~|''/.exec(text);\n        if (match) {\n            // Pushback the wrongly included part\n            stream.backUp(text.length - match.index);\n            text = text.substring(0, match.index);\n        }\n\n        // There are some symbols common in English, they are\n        // not treated as part of URL if they are trailing.\n        // If there is no left parenthesis,\n        // we assume that right parenthese will then not be part of URL\n        var regex = text.indexOf('(') !== -1 ? /[,;\\\\.:!?]+$/ : /[,;\\\\.:!?)]+$/;\n        var match = regex.exec(text);\n        var detLength = match ? match[0].length : 0;\n        if (detLength !== 0) {\n            stream.backUp(detLength);\n        }\n\n        state.handler = state.stack.pop();\n        return 'mw-extlink';\n    }\n\n    function makeParseSectionHeader(count) {\n        var regExp = new RegExp('={' + count + '}\\\\s*$');\n        return function(stream, state) {\n            if (stream.match(regExp)) {\n                return 'mw-section';\n            }\n            return parseWikitext(stream, state);\n        }\n    }\n\n    function parseComment(stream, state) {\n        if (stream.match('-->')) {\n            state.handler = state.stack.pop();\n        } else {\n            stream.next();\n        }\n        return 'mw-comment';\n    }\n\n    function parseTableStart(stream, state) {\n        stream.match('{|');\n        state.handler = state.stack.pop();\n        return 'mw-table-start';\n    }\n\n    function makeParseOpenTag(tagname, selfClose) {\n        return function(stream, state) {\n            if (stream.match(/\\/?>/)) {\n                if (!selfClose) {\n                    state.handler = parseWikitext;\n                    if (typeof(ALLOWED_TAGS[tagname]) === 'object') {\n                        ALLOWED_TAGS[tagname].open(stream, state);\n                    }\n                } else {\n                    state.handler = state.stack.pop();\n                }\n                return 'mw-tag-open';\n            } else {\n                stream.next();\n                return 'mw-tag-attr';\n            }\n        };\n    }\n\n    function parseEntityOnly(stream, state) {\n        if (stream.next() === '&') {\n            var success;\n            if (stream.eat('#')) {\n                if (stream.eat('x')) {\n                    success = stream.eatWhile(/[a-fA-F\\d]/);\n                } else {\n                    success = stream.eatWhile(/[\\d]/);\n                }\n            } else {\n                success = stream.eatWhile(/[\\w\\.\\-:]/);\n            }\n            if (success) {\n                success = stream.eat(';');\n            }\n            if (success) {\n                return makeStyle('mw-entity', state);\n            }\n        }\n        return makeStyle('', state);\n    }\n\n    /* Internal link parsing */\n\n    function parseLinkTarget(stream, state) {\n        stream.match(/.+?(?=\\||\\]\\])/);\n        if (stream.peek() === '|') {\n            state.handler = parseLinkPipe;\n        } else {\n            state.handler = parseLinkEnd;\n        }\n        return 'mw-link-target';\n    }\n\n    function parseLinkEnd(stream, state) {\n        stream.match(']]');\n        if (config.linktrail) {\n            state.handler = parseLinkTrail;\n        } else {\n            state.handler = state.stack.pop();\n        }\n        return 'mw-link-end';\n    }\n\n    function parseLinkTrail(stream, state) {\n        stream.match(/\\w*/);\n        state.handler = state.stack.pop();\n        return 'mw-link-trail';\n    }\n\n    function parseLinkPipe(stream, state) {\n        stream.match('|');\n        state.handler = parseLinkText;\n        return 'mw-link-pipe';\n    }\n\n    function parseLinkText(stream, state) {\n        if (stream.match(']]', false)) {\n            // Maybe just return directly?\n            state.handler = parseLinkEnd;\n            return '';\n        }\n        var ret = parseWikitext(stream, state);\n        return ret + ' mw-link-text';\n    }\n\n    // External link parsing\n    function parseExternalLink(stream, state) {\n        var match = stream.match(EXT_LINK_URL);\n        var text = match[0];\n\n        // {{, ~~~, '' will start their effect, so detect and correct\n        var match = new RegExp(\"\\\\{\\\\{|~~~|''\").exec(text);\n        if (match) {\n            // Pushback the wrongly included part\n            stream.backUp(text.length - match.index);\n            text = text.substring(0, match.index);\n        }\n\n        state.handler = parseExternalLinkText;\n        return 'mw-extlink-target';\n    }\n\n    function parseExternalLinkText(stream, state) {\n        if (stream.eat(']')) {\n            state.handler = state.stack.pop();\n            return 'mw-extlink-end';\n        }\n        var ret = parseWikitext(stream, state);\n        return ret + ' mw-link-text';\n    }\n\n    // Template\n\n    function parseTemplateName(stream, state) {\n        if (stream.eat('|')) {\n            if (stream.match(/[^\\|\\{\\}]*=/, false)) {\n                state.handler = parseTemplateArgName;\n            } else {\n                state.handler = parseTemplateArg;\n            }\n            return 'mw-template-pipe';\n        }\n        if (stream.match('}}')) {\n            state.handler = state.stack.pop();\n            return 'mw-template-end';\n        }\n        stream.next();\n        return 'mw-template-name';\n    }\n\n    function parseTemplateArg(stream, state) {\n        if (stream.eat('|')) {\n            if (stream.match(/[^\\|\\{\\}]*=/, false)) {\n                state.handler = parseTemplateArgName;\n            }\n            return 'mw-template-pipe';\n        }\n        if (stream.match('}}')) {\n            state.handler = state.stack.pop();\n            return 'mw-template-end';\n        }\n        var ret = parseWikitext(stream, state);\n        return ret + ' mw-template-arg';\n    }\n\n    function parseTemplateArgName(stream, state) {\n        if (stream.eat('=')) {\n            state.handler = parseTemplateArg;\n            return 'mw-template-assign';\n        }\n        // The below two cases are rare cases, where simple regex for detecting = fails\n        if (stream.eat('|')) {\n            if (!stream.match(/[^\\|\\{\\}]*=/, false)) {\n                state.handler = parseTemplateArg;\n            }\n            return 'mw-template-pipe';\n        }\n        if (stream.match('}}')) {\n            state.handler = state.stack.pop();\n            return 'mw-template-end';\n        }\n        var ret = parseWikitext(stream, state);\n        return ret + ' mw-template-argname';\n    }\n\n    // Tag handlers\n\n    function parseNowikiTag(stream, state) {\n        if (stream.match(/<\\/nowiki\\s*>/)) {\n            state.handler = state.stack.pop();\n            return 'mw-tag-close';\n        }\n        return parseEntityOnly(stream, state);\n    }\n\n    function parsePreTag(stream, state) {\n        if (stream.match(/<\\/pre\\s*>/)) {\n            state.handler = state.stack.pop();\n            arrayRemove(state.mixinStyle, 'mw-pre');\n            return 'mw-tag-close';\n        }\n        return parseEntityOnly(stream, state);\n    }\n\n    module.startState = function() {\n        return {\n            handler: parseWikitext,\n            bold: false,\n            italic: false,\n            mixinStyle: [],\n            unclosedTags: [],\n            stack: []\n        };\n    };\n\n    module.copyState = function(state) {\n        return {\n            handler: state.handler,\n            bold: state.bold,\n            italic: state.italic,\n            mixinStyle: state.mixinStyle.slice(),\n            unclosedTags: state.unclosedTags.slice(),\n            stack: state.stack.slice()\n        }\n    };\n\n    module.token = function(stream, state) {\n        if (stream.sol()) {\n            state.bold = false;\n            state.italic = false;\n        }\n        try {\n            return state.handler(stream, state);\n        } catch (e) {\n            stream.next();\n            state.handler = parseWikitext;\n            console.error('Error in WikiHighlight', e.stack || e);\n            return null;\n        }\n    }\n\n    return module;\n});\n\n};\n\n\n\nvar done = function () {\n\n$(function() {\n    var target = $('#wpTextbox1');\n    if(target.length) {\n        // \u4e0e\u6587\u672c\u6846\u540c\u6b65\u6837\u5f0f\n        document.styleSheets[0].insertRule('.CodeMirror {' +\n            'font-family:' + target.css('font-family') + ' !important;' +\n            'font-size:' + target.css('font-size') + ' !important;' +\n            'height:' + target.css('height') + ' !important;' +\n        '}', 0);\n\n        var cm = CodeMirror.fromTextArea(target[0], {\n            lineNumbers: true,\n            lineWrapping: true,\n            mode: 'mediawiki'\n        });\n\n        cm.on('change', function () {\n            target.trigger('input');\n        });\n        $.valHooks.textarea = {\n            get: function(elem){ if(elem === target[0]) return cm.getValue(); else return elem.value; },\n            set: function(elem, value){ if(elem === target[0]) cm.setValue(value); else elem.value = value; }\n        };\n        var origTextSelection = $.fn.textSelection;\n        $.fn.textSelection = function(command, options) {\n            if (cm.getTextArea() !== this[0]) {\n                return origTextSelection.call(this, command, options);\n            }\n            var fn, retval;\n\n            fn = {\n                /**\n                 * Get the contents of the textarea\n                 */\n                getContents: function() {\n                    return cm.doc.getValue();\n                },\n\n                setContents: function(newContents) {\n                    cm.doc.setValue(newContents);\n                },\n\n                /**\n                 * Get the currently selected text in this textarea. Will focus the textarea\n                 * in some browsers (IE/Opera)\n                 */\n                getSelection: function() {\n                    return cm.doc.getSelection();\n                },\n\n                /**\n                 * Inserts text at the beginning and end of a text selection, optionally\n                 * inserting text at the caret when selection is empty.\n                 */\n                encapsulateSelection: function(options) {\n                    return this.each(function() {\n                        var insertText,\n                            selText,\n                            selectPeri = options.selectPeri,\n                            pre = options.pre,\n                            post = options.post,\n                            startCursor = cm.doc.getCursor(true),\n                            endCursor = cm.doc.getCursor(false);\n\n                        if (options.selectionStart !== undefined) {\n                            // fn[command].call( this, options );\n                            fn.setSelection({\n                                start: options.selectionStart,\n                                end: options.selectionEnd\n                            }); // not tested\n                        }\n\n                        selText = cm.doc.getSelection();\n                        if (!selText) {\n                            selText = options.peri;\n                        } else if (options.replace) {\n                            selectPeri = false;\n                            selText = options.peri;\n                        } else {\n                            selectPeri = false;\n                            while (selText.charAt(selText.length - 1) === ' ') {\n                                // Exclude ending space char\n                                selText = selText.substring(0, selText.length - 1);\n                                post += ' ';\n                            }\n                            while (selText.charAt(0) === ' ') {\n                                // Exclude prepending space char\n                                selText = selText.substring(1, selText.length);\n                                pre = ' ' + pre;\n                            }\n                        }\n\n                        /**\n                         * Do the splitlines stuff.\n                         *\n                         * Wrap each line of the selected text with pre and post\n                         */\n                        function doSplitLines(selText, pre, post) {\n                            var i,\n                                insertText = '',\n                                selTextArr = selText.split('\\n');\n\n                            for (i = 0; i < selTextArr.length; i++) {\n                                insertText += pre + selTextArr[i] + post;\n                                if (i !== selTextArr.length - 1) {\n                                    insertText += '\\n';\n                                }\n                            }\n                            return insertText;\n                        }\n\n                        if (options.splitlines) {\n                            selectPeri = false;\n                            insertText = doSplitLines(selText, pre, post);\n                        } else {\n                            insertText = pre + selText + post;\n                        }\n\n                        if (options.ownline) {\n                            if (startCursor.ch !== 0) {\n                                insertText = '\\n' + insertText;\n                                pre += '\\n';\n                            }\n\n                            if (cm.doc.getLine(endCursor.line).length !== endCursor.ch) {\n                                insertText += '\\n';\n                                post += '\\n';\n                            }\n                        }\n\n                        cm.doc.replaceSelection(insertText);\n\n                        if (selectPeri) {\n                            cm.doc.setSelection(\n                                cm.doc.posFromIndex(cm.doc.indexFromPos(startCursor) + pre.length),\n                                cm.doc.posFromIndex(cm.doc.indexFromPos(startCursor) + pre.length + selText.length)\n                            );\n                        }\n                    });\n                },\n\n                /**\n                 * Get the position (in resolution of bytes not necessarily characters)\n                 * in a textarea\n                 */\n                getCaretPosition: function(options) {\n                    var caretPos = cm.doc.indexFromPos(cm.doc.getCursor(true)),\n                        endPos = cm.doc.indexFromPos(cm.doc.getCursor(false));\n                    if (options.startAndEnd) {\n                        return [caretPos, endPos];\n                    }\n                    return caretPos;\n                },\n\n                setSelection: function(options) {\n                    return this.each(function() {\n                        cm.doc.setSelection(cm.doc.posFromIndex(options.start), cm.doc.posFromIndex(options.end));\n                    });\n                },\n\n                /**\n                 * Scroll a textarea to the current cursor position. You can set the cursor\n                 * position with setSelection()\n                 */\n                scrollToCaretPosition: function() {\n                    return this.each(function() {\n                        cm.scrollIntoView(null);\n                    });\n                }\n            };\n\n            switch (command) {\n                // case 'getContents': // no params\n                // case 'setContents': // no params with defaults\n                // case 'getSelection': // no params\n                case 'encapsulateSelection':\n                    options = $.extend({\n                        pre: '', // Text to insert before the cursor/selection\n                        peri: '', // Text to insert between pre and post and select afterwards\n                        post: '', // Text to insert after the cursor/selection\n                        ownline: false, // Put the inserted text on a line of its own\n                        replace: false, // If there is a selection, replace it with peri instead of leaving it alone\n                        selectPeri: true, // Select the peri text if it was inserted (but not if there was a selection and replace==false, or if splitlines==true)\n                        splitlines: false, // If multiple lines are selected, encapsulate each line individually\n                        selectionStart: undefined, // Position to start selection at\n                        selectionEnd: undefined // Position to end selection at. Defaults to start\n                    }, options);\n                    break;\n                case 'getCaretPosition':\n                    options = $.extend({\n                        // Return [start, end] instead of just start\n                        startAndEnd: false\n                    }, options);\n                    // FIXME: We may not need character position-based functions if we insert markers in the right places\n                    break;\n                case 'setSelection':\n                    options = $.extend({\n                        // Position to start selection at\n                        start: undefined,\n                        // Position to end selection at. Defaults to start\n                        end: undefined,\n                        // Element to start selection in (iframe only)\n                        startContainer: undefined,\n                        // Element to end selection in (iframe only). Defaults to startContainer\n                        endContainer: undefined\n                    }, options);\n\n                    if (options.end === undefined) {\n                        options.end = options.start;\n                    }\n                    if (options.endContainer === undefined) {\n                        options.endContainer = options.startContainer;\n                    }\n                    // FIXME: We may not need character position-based functions if we insert markers in the right places\n                    break;\n                case 'scrollToCaretPosition':\n                    options = $.extend({\n                        force: false // Force a scroll even if the caret position is already visible\n                    }, options);\n                    break;\n            }\n\n            retval = fn[command].call(this, options);\n            // cm.focus();\n\n            return retval;\n        };\n    };\n});\n\n};\n\n\n\nif (typeof CodeMirror === 'undefined' && ['edit', 'submit'].indexOf(mw.config.get('wgAction')) !== -1 && mw.config.get(\"wgPageContentModel\") === 'wikitext') {\n    mw.loader.load('//zh.moegirl.org/index.php?title=User:Nbdd0121/tools/codemirror.js&action=raw&ctype=text/javascript');\n    mw.loader.load('//zh.moegirl.org/index.php?title=User:Nbdd0121/tools/codemirror.css&action=raw&ctype=text/css', 'text/css');\n\n    var check = function () {\n        if(typeof CodeMirror !== 'undefined') {\n            mw.loader.load('//zh.moegirl.org/index.php?title=User:\u7dad\u57fa\u6417\u86cb\u9b3c/editor.css&action=raw&ctype=text/css', 'text/css');\n            next();\n            done();\n        } else {\n            setTimeout(check, 100);\n        }\n    }\n\n    setTimeout(check, 100);\n}\n\n})();\n//</pre>"}}}