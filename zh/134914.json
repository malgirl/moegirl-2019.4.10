{"parse":{"title":"\u6a21\u5757:Arguments/doc","pageid":142418,"wikitext":{"*":"\u8be5\u6a21\u5757\u6765\u81ea\u4e8e\u82f1\u8bed\u7ef4\u57fa\u767e\u79d1\u7684[[:enwiki:Module:Arguments|\u540c\u540d\u6a21\u5757]]\n\nThis module provides easy processing of arguments passed from #invoke. It is a meta-module, meant for use by other modules, and should not be called from #invoke directly. Its features include:\n* Easy trimming of arguments and removal of blank arguments.\n* Arguments can be passed by both the current frame and by the parent frame at the same time. (More details below.)\n* Arguments can be passed in directly from another Lua module or from the debug console.\n* Arguments are fetched as needed, which can help avoid (some) problems with <nowiki><ref>...</ref></nowiki> tags.\n* Most features can be customized.\n\n== Basic use ==\n\nFirst, you need to load the module. It contains one function, named <code>getArgs</code>.\n\n<pre>\nlocal getArgs = require('Module:Arguments').getArgs\n</pre>\n\nIn the most basic scenario, you can use getArgs inside your main function. The variable <code>args</code> is a table containing the arguments from #invoke. (See below for details.)\n\n<pre>\nlocal getArgs = require('Module:Arguments').getArgs\nlocal p = {}\n\nfunction p.main(frame)\n\tlocal args = getArgs(frame)\n\t-- Main module code goes here.\nend\n\nreturn p\n</pre>\n\nHowever, the recommended practice is to use a function just for processing arguments from #invoke. This means that if someone calls your module from another Lua module you don't have to have a frame object available, which improves performance.\n\n<pre>\nlocal getArgs = require('Module:Arguments').getArgs\nlocal p = {}\n\nfunction p.main(frame)\n\tlocal args = getArgs(frame)\n\treturn p._main(args)\nend\n\nfunction p._main(args)\n\t-- Main module code goes here.\nend\n\nreturn p\n</pre>\n\nIf you want multiple functions to use the arguments, and you also want them to be accessible from #invoke, you can use a wrapper function.\n\n<pre>\nlocal getArgs = require('Module:Arguments').getArgs\n\nlocal function makeInvokeFunc(funcName)\n\treturn function (frame)\n\t\tlocal args = getArgs(frame)\n\t\treturn p[funcName](args)\n\tend\nend\n\nlocal p = {}\n\np.func1 = makeInvokeFunc('_func1')\n\nfunction p._func1(args)\n\t-- Code for the first function goes here.\nend\n\np.func2 = makeInvokeFunc('_func2')\n\nfunction p._func2(args)\n\t-- Code for the second function goes here.\nend\n\nreturn p\n</pre>\n\n=== Options ===\n\nThe following options are available. They are explained in the sections below.\n\n<pre>\nlocal args = getArgs(frame, {\n\ttrim = false,\n\tremoveBlanks = false,\n\tvalueFunc = function (key, value)\n\t\t-- Code for processing one argument\n\tend,\n\tframeOnly = true,\n\tparentOnly = true,\n\tparentFirst = true,\n\twrappers = {\n\t\t'Template:A wrapper template',\n\t\t'Template:Another wrapper template'\n\t},\n\treadOnly = true,\n\tnoOverwrite = true\n})\n</pre>\n\n=== Trimming and removing blanks ===\n\nBlank arguments often trip up coders new to converting MediaWiki templates to Lua. In template syntax, blank strings and strings consisting only of whitespace are considered false. However, in Lua, blank strings and strings consisting of whitespace are considered true. This means that if you don't pay attention to such arguments when you write your Lua modules, you might treat something as true that should actually be treated as false. To avoid this, by default this module removes all blank arguments.\n\nSimilarly, whitespace can cause problems when dealing with positional arguments. Although whitespace is trimmed for named arguments coming from #invoke, it is preserved for positional arguments. Most of the time this additional whitespace is not desired, so this module trims it off by default.\n\nHowever, sometimes you want to use blank arguments as input, and sometimes you want to keep additional whitespace. This can be necessary to convert some templates exactly as they were written. If you want to do this, you can set the <code>trim</code> and <code>removeBlanks</code> arguments to <code>false</code>.\n\n<pre>\nlocal args = getArgs(frame, {\n\ttrim = false,\n\tremoveBlanks = false\n})\n</pre>\n\n=== Custom formatting of arguments ===\n\nSometimes you want to remove some blank arguments but not others, or perhaps you might want to put all of the positional arguments in lower case. To do things like this you can use the <code>valueFunc</code> option. The input to this option must be a function that takes two parameters, <code>key</code> and <code>value</code>, and returns a single value. This value is what you will get when you access the field <code>key</code> in the <code>args</code> table.\n\nExample 1: this function preserves whitespace for the first positional argument, but trims all other arguments and removes all other blank arguments.\n<pre>\nlocal args = getArgs(frame, {\n\tvalueFunc = function (key, value)\n\t\tif key == 1 then\n\t\t\treturn value\n\t\telseif value then\n\t\t\tvalue = mw.text.trim(value)\n\t\t\tif value ~= '' then\n\t\t\t\treturn value\n\t\t\tend\n\t\tend\n\t\treturn nil\n\tend\n})\n</pre>\n\nExample 2: this function removes blank arguments and converts all arguments to lower case, but doesn't trim whitespace from positional parameters.\n<pre>\nlocal args = getArgs(frame, {\n\tvalueFunc = function (key, value)\n\t\tif not value then\n\t\t\treturn nil\n\t\tend\n\t\tvalue = mw.ustring.lower(value)\n\t\tif mw.ustring.find(value, '%S') then\n\t\t\treturn value\n\t\tend\n\t\treturn nil\n\tend\n})\n</pre>\n\nNote: the above functions will fail if passed input that is not of type <code>string</code> or <code>nil</code>. This might be the case if you use the <code>getArgs</code> function in the main function of your module, and that function is called by another Lua module. In this case, you will need to check the type of your input. This is not a problem if you are using a function specially for arguments from #invoke (i.e. you have <code>p.main</code> and <code>p._main</code> functions, or something similar).\n\n{{Hide|\u6807\u9898=Examples 1 and 2 with type checking|\u5185\u5bb9=\nExample 1:\n<pre>\nlocal args = getArgs(frame, {\n\tvalueFunc = function (key, value)\n\t\tif key == 1 then\n\t\t\treturn value\n\t\telseif type(value) == 'string' then\n\t\t\tvalue = mw.text.trim(value)\n\t\t\tif value ~= '' then\n\t\t\t\treturn value\n\t\t\telse\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\treturn value\n\t\tend\n\tend\n})\n</pre>\n\nExample 2:\n<pre>\nlocal args = getArgs(frame, {\n\tvalueFunc = function (key, value)\n\t\tif type(value) == 'string' then\n\t\t\tvalue = mw.ustring.lower(value)\n\t\t\tif mw.ustring.find(value, '%S') then\n\t\t\t\treturn value\n\t\t\telse\n\t\t\t\treturn nil\n\t\t\tend\n\t\telse\n\t\t\treturn value\n\t\tend\n\tend\n})\n</pre>\n}}\n\nAlso, please note that the <code>valueFunc</code> function is called more or less every time an argument is requested from the <code>args</code> table, so if you care about performance you should make sure you aren't doing anything inefficient with your code.\n\n=== Frames and parent frames ===\n\nArguments in the <code>args</code> table can be passed from the current frame or from its parent frame at the same time. To understand what this means, it is easiest to give an example. Let's say that we have a module called <code>Module:ExampleArgs</code>. This module prints the first two positional arguments that it is passed.\n\n{{Hide|\u6807\u9898=Module:ExampleArgs code|\u5185\u5bb9=\n<pre>\nlocal getArgs = require('Module:Arguments').getArgs\nlocal p = {}\n\nfunction p.main(frame)\n\tlocal args = getArgs(frame)\n\treturn p._main(args)\nend\n\nfunction p._main(args)\n\tlocal first = args[1] or ''\n\tlocal second = args[2] or ''\n\treturn first .. ' ' .. second\nend\n\nreturn p\n</pre>\n}}\n\n<code>Module:ExampleArgs</code> is then called by <code>Template:ExampleArgs</code>, which contains the code <code><nowiki>{{#invoke:ExampleArgs|main|firstInvokeArg}}</nowiki></code>. This produces the result \"firstInvokeArg\".\n\nNow if we were to call <code>Template:ExampleArgs</code>, the following would happen:\n\n{| class=\"wikitable\" style=\"width: 50em; max-width: 100%;\"\n|-\n! style=\"width: 60%;\" | Code\n! style=\"width: 40%;\" | Result\n|-\n| <code><nowiki>{{ExampleArgs}}</nowiki></code>\n| firstInvokeArg\n|-\n| <code><nowiki>{{ExampleArgs|firstTemplateArg}}</nowiki></code>\n| firstInvokeArg\n|-\n| <code><nowiki>{{ExampleArgs|firstTemplateArg|secondTemplateArg}}</nowiki></code>\n| firstInvokeArg secondTemplateArg\n|}\n\nThere are three options you can set to change this behaviour: <code>frameOnly</code>, <code>parentOnly</code> and <code>parentFirst</code>. If you set <code>frameOnly</code> then only arguments passed from the current frame will be accepted; if you set <code>parentOnly</code> then only arguments passed from the parent frame will be accepted; and if you set <code>parentFirst</code> then arguments will be passed from both the current and parent frames, but the parent frame will have priority over the current frame. Here are the results in terms of <code>Template:ExampleArgs</code>:\n\n; frameOnly\n{| class=\"wikitable\" style=\"width: 50em; max-width: 100%;\"\n|-\n! style=\"width: 60%;\" | Code\n! style=\"width: 40%;\" | Result\n|-\n| <code><nowiki>{{ExampleArgs}}</nowiki></code>\n| firstInvokeArg\n|-\n| <code><nowiki>{{ExampleArgs|firstTemplateArg}}</nowiki></code>\n| firstInvokeArg\n|-\n| <code><nowiki>{{ExampleArgs|firstTemplateArg|secondTemplateArg}}</nowiki></code>\n| firstInvokeArg\n|}\n\n; parentOnly\n{| class=\"wikitable\" style=\"width: 50em; max-width: 100%;\"\n|-\n! style=\"width: 60%;\" | Code\n! style=\"width: 40%;\" | Result\n|-\n| <code><nowiki>{{ExampleArgs}}</nowiki></code>\n| \n|-\n| <code><nowiki>{{ExampleArgs|firstTemplateArg}}</nowiki></code>\n| firstTemplateArg\n|-\n| <code><nowiki>{{ExampleArgs|firstTemplateArg|secondTemplateArg}}</nowiki></code>\n| firstTemplateArg secondTemplateArg\n|}\n\n; parentFirst\n{| class=\"wikitable\" style=\"width: 50em; max-width: 100%;\"\n|-\n! style=\"width: 60%;\" | Code\n! style=\"width: 40%;\" | Result\n|-\n| <code><nowiki>{{ExampleArgs}}</nowiki></code>\n| firstInvokeArg\n|-\n| <code><nowiki>{{ExampleArgs|firstTemplateArg}}</nowiki></code>\n| firstTemplateArg\n|-\n| <code><nowiki>{{ExampleArgs|firstTemplateArg|secondTemplateArg}}</nowiki></code>\n| firstTemplateArg secondTemplateArg\n|}\n\nNotes:\n# If you set both the <code>frameOnly</code> and <code>parentOnly</code> options, the module won't fetch any arguments at all from #invoke. This is probably not what you want.\n# In some situations a parent frame may not be available, e.g. if getArgs is passed the parent frame rather than the current frame. In this case, only the frame arguments will be used (unless parentOnly is set, in which case no arguments will be used) and the <code>parentFirst</code> and <code>frameOnly</code> options will have no effect.\n\n=== Wrappers ===\n\nThe ''wrappers'' option is used to specify a limited number of templates as ''wrapper templates'', that is, templates whose only purpose is to call a module. If the module detects that it is being called from a wrapper template, it will only check for arguments in the parent frame; otherwise it will only check for arguments in the frame passed to getArgs. This allows modules to be called by either #invoke or through a wrapper template without the loss of performance associated with having to check both the frame and the parent frame for each argument lookup.\n\nFor example, the only content of [[Template:Side box]] (excluding content in <nowiki><noinclude>...</noinclude></nowiki> tags) is <code><nowiki>{{#invoke:Side box|main}}</nowiki></code>. There is no point in checking the arguments passed directly to the #invoke statement for this template, as no arguments will ever be specified there. We can avoid checking arguments passed to #invoke by using the ''parentOnly'' option, but if we do this then #invoke will not work from other pages either. If this were the case, the {{para|text|Some text}} in the code <code><nowiki>{{#invoke:Side box|main|text=Some text}}</nowiki></code> would be ignored completely, no matter what page it was used from. By using the <code>wrappers</code> option to specify 'Template:Side box' as a wrapper, we can make <code><nowiki>{{#invoke:Side box|main|text=Some text}}</nowiki></code> work from most pages, while still not requiring that the module check for arguments on the [[Template:Side box]] page itself.\n\nWrappers can be specified either as a string, or as an array of strings.\n\n<pre>\nlocal args = getArgs(frame, {\n\twrappers = 'Template:Wrapper template'\n})\n</pre>\n\n\n<pre>\nlocal args = getArgs(frame, {\n\twrappers = {\n\t\t'Template:Wrapper 1',\n\t\t'Template:Wrapper 2',\n\t\t-- Any number of wrapper templates can be added here.\n\t}\n})\n</pre>\n\nNotes:\n# The module will automatically detect if it is being called from a wrapper template's /sandbox subpage, so there is no need to specify sandbox pages explicitly.\n# The ''wrappers'' option effectively changes the default of the ''frameOnly'' and ''parentOnly'' options. If, for example, ''parentOnly'' were explicitly set to false with ''wrappers'' set, calls via wrapper templates would result in both frame and parent arguments being loaded, though calls not via wrapper templates would result in only frame arguments being loaded.\n# If the ''wrappers'' option is set and no parent frame is available, the module will always get the arguments from the frame passed to <code>getArgs</code>.\n\n=== Writing to the args table ===\n\nSometimes it can be useful to write new values to the args table. This is possible with the default settings of this module. (However, bear in mind that it is usually better coding style to create a new table with your new values and copy arguments from the args table as needed.)\n\n<pre>\nargs.foo = 'some value'\n</pre>\n\nIt is possible to alter this behaviour with the <code>readOnly</code> and <code>noOverwrite</code> options. If <code>readOnly</code> is set then it is not possible to write any values to the args table at all. If <code>noOverwrite</code> is set, then it is possible to add new values to the table, but it is not possible to add a value if it would overwrite any arguments that are passed from #invoke.\n\n=== Ref tags ===\n\nThis module uses [[mw:Extension:Scribunto/Lua reference manual#Metatables|metatables]] to fetch arguments from #invoke. This allows access to both the frame arguments and the parent frame arguments without using the <code>pairs()</code> function. This can help if your module might be passed <nowiki><ref>...</ref></nowiki> tags as input.\n\nAs soon as <nowiki><ref>...</ref></nowiki> tags are accessed from Lua, they are processed by the MediaWiki software and the reference will appear in the reference list at the bottom of the article. If your module proceeds to omit the reference tag from the output, you will end up with a phantom reference - a reference that appears in the reference list, but no number that links to it. This has been a problem with modules that use <code>pairs()</code> to detect whether to use the arguments from the frame or the parent frame, as those modules automatically process every available argument.\n\nThis module solves this problem by allowing access to both frame and parent frame arguments, while still only fetching those arguments when it is necessary. The problem will still occur if you use <code>pairs(args)</code> elsewhere in your module, however.\n\n=== Known limitations ===\n\nThe use of metatables also has its downsides. Most of the normal Lua table tools won't work properly on the args table, including the <code>#</code> operator, the <code>next()</code> function, and the functions in the table library. If using these is important for your module, you should use your own argument processing function instead of this module.<includeonly>{{#ifeq:{{SUBPAGENAME}}|sandbox||\n[[Category:Lua metamodules]]\n}}</includeonly>"}}}