{"parse":{"title":"\u6a21\u5757:Sandbox/\u4e5d\u6c5f\u6708/test","pageid":278688,"wikitext":{"*":"local Core={\n\tiFlow={index=1,level=0},\n\tCard={\n\t\tMeta={originalcode={\"originalcode\",0},code={\"code\",0},originalcoderule={\"code\",0}}\n\t},\n\tEffect={\n\t\tMeta={description={\"description\",0},category={\"category\",0},type={\"type\",0},code={\"code\",0},property={\"property\",0},\n\t\t\tcountLimit={\"countLimit\",0,0},range={\"range\",0,0},targetrange={\"targetrange\",0,0},value={\"value\",0,0},\n\t\t\tcondition={\"condition\",0},cost={\"cost\",0},target={\"target\",0},operation={\"operation\",0}}\n\t}\n}\n--split\nlocal function split( str,reps )\n    local resultStrList = {}\n    string.gsub(str,'[^'..reps..']+',function ( w )\n        table.insert(resultStrList,w)\n    end)\n    return resultStrList\nend\n--return\nfunction Core.Return(frame,index,args) return args[2] end\n--callback\nfunction Core.Callback(frame,index,args)\n\treturn  ((args[1]~=0 and Core[frame.args[index+1]]~=nil) and {Core[frame.args[index+1]](frame,index+2,args)} or {Core.Return(frame,index,args)})[1]\nend\n--flowcontrol\nfunction Core.If(frame,index,args)\n\tCore.iFlow.level = Core.iFlow.level + 1\n\treturn Core.Callback(frame,index,args)\nend\nfunction Core.Then(frame,index,args)\n\treturn Core.Callback(frame,index-1,args)\nend\nfunction Core.Else(frame,index,args)\n\tCore.iFlow.index = Core.iFlow.index * -1\n\treturn Core.Callback(frame,index-1,args)\nend\nfunction Core.End(frame,index,args)\n\tCore.iFlow.level = (Core.iFlow.level == 0 and {0} or {Core.iFlow.level - 1})[1]\n\treturn Core.Callback(frame,index-1,args)\nend\n--bool\nfunction Core.Bool(frame,index,args,b,op)\n\tif not args then args={} end\n\tif not index then index = 1 end\n\targs[3] = args[2]\n\targs[2] = b\n\tif op == \"and\" then args[2] = (args[3] and args[2]) end\n\tif op == \"or\" then args[2] = (args[3] or args[2]) end\n\tif op == \"not\" then args[2] = (not args[2]) end\n\tif op == \"and not\" then args[2] = (args[3] and not args[2]) end\n\tif op == \"or not\" then args[2] = (args[3] or not args[2]) end\n    return Core.Callback(frame,index,args)\nend\n--bool logic\nfunction Core.True(frame,index,args)\n\tif not args then args={} end\n\tif not index then index = 1 end\n\treturn Core.Bool(frame,index-1,args,true,args[1])\nend\nfunction Core.False(frame,index,args) \n\tif not args then args={} end\n\tif not index then index = 1 end\n\treturn Core.Bool(frame,index-1,args,false,args[1])\nend\nfunction Core.And(frame,index,args)\n\targs[1] = \"and\"\n\treturn Core.Bool(frame,index-1,args,args[2])\nend\nfunction Core.Or(frame,index,args)\n\targs[1] = \"or\"\n\treturn Core.Bool(frame,index-1,args,args[2])\nend\nfunction Core.Not(frame,index,args)\n\tif not args then args={} end\n\tif not index then index = 1 end\n\tlocal sw = {\n\t\t[\"and\"] = function(name) args[2] = args[3] return \"and not\" end,\n\t\t[\"or\"] = function(name) args[2] = args[3] return \"or not\" end,\n\t\t[\"#default\"] = function(name) return (name==\"not\" and {\"\"} or {\"not\"})[1] end\n\t}\n\tlocal f =(sw[args[1]] and {sw[args[1]]} or {sw[\"#default\"]})[1]\n\targs[1] = f(args[1])\n\treturn Core.Bool(frame,index-1,args,args[2])\nend\n--init\nfunction Core.CardInit(frame)\n\tlocal index = 1\n\tlocal str = string.gsub(frame.args[index], \"%%;\", \"%%3B\") \n\tlocal args = split(str,';')\n\tlocal switch={\n        [\"#default\"]=function(text) \n            local strbegin = -1\n            local strend = string.find(text,\":\",strbegin + 1)  \n            local tpara = (strend and {string.sub(text, strbegin+1,strend-1)} or {\"#query\"})[1] \n            local tvalue = (strend and {string.sub(text,strend+1)} or {string.sub(text, strbegin+1)})[1] \n            if tpara~=\"#query\" then\n        \t\tCore.Card.Meta[tpara]={tostring(tpara),tvalue}\n        \tend\n        end\n    }\n\tfor k,v in pairs(args) do\n    \tv = string.gsub(v, \"%%3B\", \";\") \n        local f = switch[\"#default\"]\n        if(f) then\n            f(v)  \n        end\n    end\n    return Core.Callback(frame,index,{1})\nend\nfunction Core.CardGetMeta(frame,index,args)\n\tlocal ret = \"\"\n\tfor k,v in pairs(Core.Card.Meta) do\n\t\tret = ret..v[1]..\":\"..v[2]..\";\"\n\tend\n\treturn  Core.Callback(frame,index,{0,ret})\nend\n--set\nfunction Core.CardSetCode(frame,index,args)\n\tindex = (index==nil and {1} or {index})[1]\n\tCore.Card.Meta.code[2] = frame.args[index]\n\treturn Core.Callback(frame,index,{1})\nend\nfunction Core.CardSetOriginalCode(frame,index,args)\n\tindex = (index==nil and {1} or {index})[1]\n\tCore.Card.Meta.originalcode[2] = frame.args[index]\n\treturn Core.Callback(frame,index,{1})\nend\nfunction Core.CardSetOriginalCodeRule(frame,index,args)\n\tindex = (index==nil and {1} or {index})[1]\n\tCore.Card.Meta.originalcoderule[2] = frame.args[index]\n\treturn Core.Callback(frame,index,{1})\nend\nfunction Core.CardSetFusionCode(frame,index,args)\n\tindex = (index==nil and {1} or {index})[1]\n\tCore.Card.Meta.fusioncode[2] = frame.args[index]\n\treturn Core.Callback(frame,index,{1})\nend\n--get\nfunction Core.CardGetCode(frame,index,args) \n\tlocal ret = Core.Card.Meta.code[2] or 'nil value'\n\treturn Core.Callback(frame,index,{0,ret})\nend\nfunction Core.CardGetOriginalCode(frame,index,args) \n\tlocal ret = Core.Card.Meta.originalcode[2] or 'nil value'\n\treturn Core.Callback(frame,index,{0,ret})\nend\nfunction Core.CardGetOriginalCodeRule(frame,index,args) \n\tlocal ret = Core.Card.Meta.originalcoderule[2] or 'nil value'\n\treturn Core.Callback(frame,index,{0,ret})\nend\nfunction Core.CardGetFusionCode(frame,index,args) \n\tlocal ret = Core.Card.Meta.fusioncode[2] or 'nil value'\n\treturn Core.Callback(frame,index,{0,ret})\nend\n--ifget\nfunction Core.CardIsCode(frame,index,args) \n\tlocal ret = ((tostring(Core.Card.Meta.code[2]) == frame.args[index]) and {true} or {false})[1]\n\treturn Core.Bool(frame,index,args,ret,args[1])\nend\n\nreturn Core"}}}