{"parse":{"title":"\u6a21\u5757:Citation/CS1/Date validation","pageid":264540,"wikitext":{"*":"\nlocal p = {}\n\n--[[--------------------------< I S _ V A L I D _ A C C E S S D A T E >----------------------------------------\n\nreturns true if:\n\tWikipedia start date <= accessdate < today + 2 days\n\nWikipedia start date is 2001-01-15T00:00:00 UTC which is 979516800 seconds after 1970-01-01T00:00:00 UTC (the start of Unix time)\naccessdate is the date provided in |accessdate= at time 00:00:00 UTC\ntoday is the current date at time 00:00:00 UTC plus 48 hours\n\tif today is 2015-01-01T00:00:00 then\n\t\tadding 24 hours gives 2015-01-02T00:00:00 \u2013 one second more than today\n\t\tadding 24 hours gives 2015-01-03T00:00:00 \u2013 one second more than tomorrow\n\n]]\n\nlocal function is_valid_accessdate (accessdate)\n\tlocal lang = mw.getContentLanguage();\n\tlocal good1, good2;\n\tlocal access_ts, tomorrow_ts;\t\t\t\t\t\t\t\t\t\t\t\t-- to hold unix time stamps representing the dates\n\t\t\n\taccessdate = accessdate:gsub(\"\u5e74\", \"-\");\n\taccessdate = accessdate:gsub(\"\u6708\", \"-\");\n\taccessdate = accessdate:gsub(\"\u65e5\", \"-\");\n\taccessdate = accessdate:gsub(\"-$\", \"\");\n\tgood1, access_ts = pcall( lang.formatDate, lang, 'U', accessdate );\t\t\t-- convert accessdate value to unix timesatmp \n\tgood2, tomorrow_ts = pcall( lang.formatDate, lang, 'U', 'today + 2 days' );\t-- today midnight + 2 days is one second more than all day tomorrow\n\t\n\tif good1 and good2 then\n\t\taccess_ts = tonumber (access_ts);\t\t\t\t\t\t\t\t\t\t-- convert to numbers for the comparison\n\t\ttomorrow_ts = tonumber (tomorrow_ts);\n\telse\n\t\treturn false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- one or both failed to convert to unix time stamp\n\tend\n\t\n\tif 979516800 <= access_ts and access_ts < tomorrow_ts then\t\t\t\t\t-- Wikipedia start date <= accessdate < tomorrow's date\n\t\treturn true;\n\telse\n\t\treturn false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- accessdate out of range\n\tend\nend\n\n--[[--------------------------< G E T _ M O N T H _ N U M B E R >----------------------------------------------\n\nreturns a number according to the month in a date: 1 for January, etc.  Capitalization and spelling must be correct. If not a valid month, returns 0\n\n]]\n\nlocal function get_month_number (month)\nlocal long_months = {['January']=1, ['February']=2, ['March']=3, ['April']=4, ['May']=5, ['June']=6, ['July']=7, ['August']=8, ['September']=9, ['October']=10, ['November']=11, ['December']=12};\nlocal short_months = {['Jan']=1, ['Feb']=2, ['Mar']=3, ['Apr']=4, ['May']=5, ['Jun']=6, ['Jul']=7, ['Aug']=8, ['Sep']=9, ['Oct']=10, ['Nov']=11, ['Dec']=12};\nlocal zh_months = {['1\u6708']=1, ['2\u6708']=2, ['3\u6708']=3, ['4\u6708']=4, ['5\u6708']=5, ['6\u6708']=6, ['7\u6708']=7, ['8\u6708']=8, ['9\u6708']=9, ['10\u6708']=10, ['11\u6708']=11, ['12\u6708']=12}; -- LOCAL\nlocal temp;\n\ttemp=long_months[month];\n\tif temp then return temp; end\t\t\t\t-- if month is the long-form name\n\ttemp=short_months[month];\n\tif temp then return temp; end\t\t\t\t-- if month is the short-form name\n\ttemp=zh_months[month]; -- LOCAL\n\tif temp then return temp; end\t\t\t\t-- if month is in Chinese -- LOCAL\n\treturn 0;\t\t\t\t\t\t\t\t\t-- misspelled, improper case, or not a month name\nend\n\n--[[--------------------------< G E T _ S E A S O N _ N U M B E R >--------------------------------------------\n\nreturns a number according to the sequence of seasons in a year: 1 for Winter, etc.  Capitalization and spelling must be correct. If not a valid season, returns 0\n\n]]\n\nlocal function get_season_number (season)\nlocal season_list = {['Winter']=21, ['Spring']=22, ['Summer']=23, ['Fall']=24, ['Autumn']=24};\t-- make sure these numbers do not overlap month numbers\nlocal temp;\n\ttemp=season_list[season];\n\tif temp then return temp; end\t\t\t\t\t\t\t\t\t\t\t\t-- if season is a valid name return its number\n\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- misspelled, improper case, or not a season name\nend\n\n--[[--------------------------< I S _ P R O P E R _ N A M E >--------------------------------------------------\n\nreturns a non-zero number if date contains a recognized proper name.  Capitalization and spelling must be correct.\n\n]]\n\nlocal function is_proper_name (name)\nlocal name_list = {['Christmas']=31}\nlocal temp;\n\ttemp=name_list[name];\n\tif temp then return temp; end\t\t\t\t-- if name is a valid name return its number\n\treturn 0;\t\t\t\t\t\t\t\t\t-- misspelled, improper case, or not a proper name\nend\n\n--[[--------------------------< I S _ V A L I D _ M O N T H _ O R _ S E A S O N >------------------------------\n\n--returns true if month or season is valid (properly spelled, capitalized, abbreviated)\n\n]]\n\nlocal function is_valid_month_or_season (month_season)\n\tif 0 == get_month_number (month_season) then\t\t-- if month text isn't one of the twelve months, might be a season\n\t\tif 0 == get_season_number (month_season) then\t-- not a month, is it a season?\n\t\t\treturn false;\t\t\t\t\t\t\t\t-- return false not a month or one of the five seasons\n\t\tend\n\tend\n\treturn true;\nend\n\n--[[--------------------------< I S _ V A L I D _ Y E A R >----------------------------------------------------\n\nFunction gets current year from the server and compares it to year from a citation parameter.  Years more than one year in the future are not acceptable.\n\n]]\n\nlocal function is_valid_year(year)\n\tif not is_set(year_limit) then\n\t\tyear_limit = tonumber(os.date(\"%Y\"))+1;\t\t\t-- global variable so we only have to fetch it once\n\tend\n\treturn tonumber(year) <= year_limit;\t\t\t\t-- false if year is in the future more than one year\nend\n\n--[[--------------------------< I S _ V A L I D _ D A T E >----------------------------------------------------\nReturns true if day is less than or equal to the number of days in month and year is no farther into the future\nthan next year; else returns false.\n\nAssumes Julian calendar prior to year 1582 and Gregorian calendar thereafter. Accounts for Julian calendar leap\nyears before 1582 and Gregorian leap years after 1582. Where the two calendars overlap (1582 to approximately\n1923) dates are assumed to be Gregorian.\n\n]]\n\nlocal function is_valid_date (year, month, day)\nlocal days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nlocal month_length;\n\tif not is_valid_year(year) then\t\t\t\t\t\t\t\t\t\t\t\t-- no farther into the future than next year\n\t\treturn false;\n\tend\n\t\n\tmonth = tonumber(month);\t\t\t\t\t\t\t\t\t\t\t\t\t-- required for YYYY-MM-DD dates\n\t\n\tif (2==month) then\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if February\n\t\tmonth_length = 28;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- then 28 days unless\n\t\tif 1582 > tonumber(year) then\t\t\t\t\t\t\t\t\t\t\t-- Julian calendar\n\t\t\tif 0==(year%4) then\n\t\t\t\tmonth_length = 29;\n\t\t\tend\n\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- Gregorian calendar\n\t\t\tif (0==(year%4) and (0~=(year%100) or 0==(year%400))) then\t\t\t-- is a leap year?\n\t\t\t\tmonth_length = 29;\t\t\t\t\t\t\t\t\t\t\t\t-- if leap year then 29 days in February\n\t\t\tend\n\t\tend\n\telse\n\t\tmonth_length=days_in_month[month];\n\tend\n\n\tif tonumber (day) > month_length then\n\t\treturn false;\n\tend\n\treturn true;\nend\n\n--[[--------------------------< I S _ V A L I D _ M O N T H _ R A N G E _ S T Y L E >--------------------------\n\nMonths in a range are expected to have the same style: Jan\u2013Mar or October\u2013December but not February\u2013Mar or Jul\u2013August. \nThere is a special test for May because it can be either short or long form.\n\nReturns true when style for both months is the same\n\n]]\n\nlocal function is_valid_month_range_style (month1, month2)\nlocal len1 = month1:len();\nlocal len2 = month2:len();\n\tif len1 == len2 then\n\t\treturn true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- both months are short form so return true\n\telseif 'May' == month1 or 'May'== month2 then\n\t\treturn true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- both months are long form so return true\n\telseif 3 == len1 or 3 == len2 then\n\t\treturn false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- months are mixed form so return false\n\telse\n\t\treturn true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- both months are long form so return true\n\tend\nend\n\n\n--[[--------------------------< I S _ V A L I D _ M O N T H _ S E A S O N _ R A N G E >------------------------\n\nCheck a pair of months or seasons to see if both are valid members of a month or season pair.\n\nMonth pairs are expected to be left to right, earliest to latest in time.\n\nSimilarly, seasons are also left to right, earliest to latest in time.  There is an oddity with seasons: winter is assigned a value of 1, spring 2, ...,\nfall and autumn 4.  Because winter can follow fall/autumn at the end of a calender year, a special test is made to see if |date=Fall-Winter yyyy (4-1) is the date.\n\n]]\n\nlocal function is_valid_month_season_range(range_start, range_end)\n\tlocal range_start_number = get_month_number (range_start);\n\t\n\tif 0 == range_start_number then\t\t\t\t\t\t\t\t\t\t\t\t-- is this a month range?\n\t\tlocal range_start_number = get_season_number (range_start);\t\t\t\t-- not a month; is it a season? get start season number\n\t\tlocal range_end_number = get_season_number (range_end);\t\t\t\t\t-- get end season number\n\n\t\tif 0 ~= range_start_number then\t\t\t\t\t\t\t\t\t\t\t-- is start of range a season?\n\t\t\tif range_start_number < range_end_number then\t\t\t\t\t\t-- range_start is a season\n\t\t\t\treturn true;\t\t\t\t\t\t\t\t\t\t\t\t\t-- return true when range_end is also a season and follows start season; else false\n\t\t\tend\n\t\t\tif 24 == range_start_number and 21 == range_end_number then\t\t\t-- special case when season range is Fall-Winter or Autumn-Winter\n\t\t\t\treturn true;\n\t\t\tend\n\t\tend\n\t\treturn false;\t\t-- range_start is not a month or a season; or range_start is a season and range_end is not; or improper season sequence\n\tend\n\n\tlocal range_end_number = get_month_number (range_end);\t\t\t\t\t\t-- get end month number\n\tif range_start_number < range_end_number then\t\t\t\t\t\t\t\t-- range_start is a month; does range_start precede range_end?\n\t\tif is_valid_month_range_style (range_start, range_end) then\t\t\t\t-- do months have the same style?\n\t\t\treturn true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- proper order and same style\n\t\tend\n\tend\n\treturn false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- range_start month number is greater than or equal to range end number; or range end isn't a month\nend\n\n\n--[[--------------------------< M A K E _ C O I N S _ D A T E >------------------------------------------------\n\nThis function receives a table of date parts for one or two dates and an empty table reference declared in\nModule:Citation/CS1.  The function is called only for |date= parameters and only if the |date=<value> is \ndetermined to be a valid date format.  The question of what to do with invalid date formats is not answered here.\n\nThe date parts in the input table are converted to an ISO 8601 conforming date string:\n\tsingle whole dates:\t\tyyyy-mm-dd\n\tmonth and year dates:\tyyyy-mm\n\tyear dates:\t\t\t\tyyyy\n\tranges:\t\t\t\t\tyyyy-mm-dd/yyyy-mm-dd\n\t\t\t\t\t\t\tyyyy-mm/yyyy-mm\n\t\t\t\t\t\t\tyyyy/yyyy\n\nDates in the Julian calendar are reduced to year or year/year so that we don't have to do calendar conversion from\nJulian to Proleptic Gregorian.\n\nThe input table has:\n\tyear, year2 \u2013 always present; if before 1582, ignore months and days if present\n\tmonth, month2 \u2013 0 if not provided, 1-12 for months, 21-24 for seasons; 31\u2013 proper name dates\n\tday, day2 \u2013  0 if not provided, 1-31 for days\n\t\nthe output table receives:\n\trftdate:\tan IS8601 formatted date\n\trftchron:\ta free-form version of the date, usually without year which is in rftdate (season ranges and propername dates)\n\trftssn:\t\tone of four season keywords: winter, spring, summer, fall (lowercase)\n\n]]\n\nlocal function make_COinS_date (input, tCOinS_date)\n\tlocal date;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- one date or first date in a range\n\tlocal date2 = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- end of range date\n\t\n\tif 1582 > tonumber(input.year) or 20 < tonumber(input.month) then\t\t\t-- Julian calendar or season so &rft.date gets year only\n\t\tdate = input.year;\n\t\tif 0 ~= input.year2 and input.year ~= input.year2 then\t\t\t\t\t-- if a range, only the second year portion when not the same as range start year\n\t\t\tdate = string.format ('%.4d/%.4d', tonumber(input.year), tonumber(input.year2))\t\t-- assemble the date range\n\t\tend\n\t\tif 20 < tonumber(input.month) then\t\t\t\t\t\t\t\t\t\t-- if season or propername date\n\t\t\tlocal season = {[21]='winter', [22]='spring', [23]='summer', [24]='fall', [31]='Christmas'};\t-- seasons lowercase, no autumn; proper names use title case\n\t\t\tif 0 == input.month2 then\t\t\t\t\t\t\t\t\t\t\t-- single season date\n\t\t\t\tif 30 <tonumber(input.month) then\n\t\t\t\t\ttCOinS_date.rftchron = season[input.month];\t\t\t\t\t-- proper name dates\n\t\t\t\telse\n\t\t\t\t\ttCOinS_date.rftssn = season[input.month];\t\t\t\t\t-- seasons\n\t\t\t\tend\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- season range with a second season specified\n\t\t\t\tif input.year ~= input.year2 then\t\t\t\t\t\t\t\t-- season year \u2013 season year range or season year\u2013year\n\t\t\t\t\ttCOinS_date.rftssn = season[input.month];\t\t\t\t\t-- start of range season; keep this?\n\t\t\t\t\tif 0~= month2 then\n\t\t\t\t\t\ttCOinS_date.rftchron = string.format ('%s %s \u2013 %s %s', season[input.month], input.year, season[input.month2], input.year2);\n\t\t\t\t\tend\n\t\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- season\u2013season year range\n\t\t\t\t\ttCOinS_date.rftssn = season[input.month];\t\t\t\t\t-- start of range season; keep this?\n\t\t\t\t\ttCOinS_date.rftchron = season[input.month] .. '\u2013' .. season[input.month2];\t-- season\u2013season year range\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\ttCOinS_date.rftdate = date;\n\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- done\n\tend\n\t\n\tif 0 ~= input.day then\n\t\tdate = string.format ('%s-%.2d-%.2d', input.year, tonumber(input.month), tonumber(input.day));\t-- whole date\n\telseif 0 ~= input.month then\n\t\tdate = string.format ('%s-%.2d', input.year, tonumber(input.month));\t-- year and month\n\telse\n\t\tdate = string.format ('%s', input.year);\t\t\t\t\t\t\t\t-- just year\n\tend\n\n\tif 0 ~= input.year2 then\n\t\tif 0 ~= input.day2 then\n\t\t\tdate2 = string.format ('/%s-%.2d-%.2d', input.year2, tonumber(input.month2), tonumber(input.day2));\t\t-- whole date\n\t\telseif 0 ~= input.month2 then\n\t\t\tdate2 = string.format ('/%s-%.2d', input.year2, tonumber(input.month2));\t-- year and month\n\t\telse\n\t\t\tdate2 = string.format ('/%s', input.year2);\t\t\t\t\t\t\t-- just year\n\t\tend\n\tend\n\t\n\ttCOinS_date.rftdate = date .. date2;\t\t\t\t\t\t\t\t\t\t-- date2 has the '/' separator\n\treturn;\nend\n\n\n--[[--------------------------< C H E C K _ D A T E >----------------------------------------------------------\n\nCheck date format to see that it is one of the formats approved by WP:DATESNO or WP:DATERANGE. Exception: only\nallowed range separator is endash.  Additionally, check the date to see that it is a real date: no 31 in 30-day\nmonths; no 29 February when not a leap year.  Months, both long-form and three character abbreviations, and seasons\nmust be spelled correctly.  Future years beyond next year are not allowed.\n\nIf the date fails the format tests, this function returns false and does not return values for anchor_year and\nCOinS_date.  When this happens, the date parameter is used in the COinS metadata and the CITEREF identifier gets\nits year from the year parameter if present otherwise CITEREF does not get a date value.\n\nInputs:\n\tdate_string - date string from date-holding parameters (date, year, accessdate, embargo, archivedate, etc.)\n\nReturns:\n\tfalse if date string is not a real date; else\n\ttrue, anchor_year, COinS_date\n\t\tanchor_year can be used in CITEREF anchors\n\t\tCOinS_date is ISO 8601 format date; see make_COInS_date()\n\n]]\n\nlocal function check_date (date_string, tCOinS_date)\n\tlocal year;\t\t\t-- assume that year2, months, and days are not used;\n\tlocal year2=0;\t\t-- second year in a year range\n\tlocal month=0;\n\tlocal month2=0;\t\t-- second month in a month range\n\tlocal day=0;\n\tlocal day2=0;\t\t-- second day in a day range\n\tlocal anchor_year;\n\tlocal coins_date;\n\n\tif date_string:match(\"^%d%d%d%d%-%d%d%-%d%d$\") then\t\t\t\t\t\t\t\t\t\t-- year-initial numerical year month day format\n\t\tyear, month, day=string.match(date_string, \"(%d%d%d%d)%-(%d%d)%-(%d%d)\");\n\t\tif 12 < tonumber(month) or 1 > tonumber(month) or 1583 > tonumber(year) then return false; end\t\t\t-- month number not valid or not Gregorian calendar\n\t\tanchor_year = year;\n\n\telseif date_string:match(\"^%a+ +[1-9]%d?, +[1-9]%d%d%d%a?$\") then\t\t\t\t\t\t-- month-initial: month day, year\n\t\tmonth, day, anchor_year, year=string.match(date_string, \"(%a+)%s*(%d%d?),%s*((%d%d%d%d)%a?)\");\n\t\tmonth = get_month_number (month);\n\t\tif 0 == month then return false; end\t\t\t\t\t\t\t\t\t\t\t\t-- return false if month text isn't one of the twelve months\n\t\t\t\t\n\telseif date_string:match(\"^%a+ +[1-9]%d?\u2013[1-9]%d?, +[1-9]%d%d%d%a?$\") then\t\t\t\t-- month-initial day range: month day\u2013day, year; days are separated by endash\n\t\tmonth, day, day2, anchor_year, year=string.match(date_string, \"(%a+) +(%d%d?)\u2013(%d%d?), +((%d%d%d%d)%a?)\");\n\t\tif tonumber(day) >= tonumber(day2) then return false; end\t\t\t\t\t\t\t-- date range order is left to right: earlier to later; dates may not be the same;\n\t\tmonth = get_month_number (month);\n\t\tif 0 == month then return false; end\t\t\t\t\t\t\t\t\t\t\t\t-- return false if month text isn't one of the twelve months\n\t\tmonth2=month;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- for metadata\n\t\tyear2=year;\n\n\telseif date_string:match(\"^[1-9]%d? +%a+ +[1-9]%d%d%d%a?$\") then\t\t\t\t\t\t-- day-initial: day month year\n\t\tday, month, anchor_year, year=string.match(date_string, \"(%d%d*)%s*(%a+)%s*((%d%d%d%d)%a?)\");\n\t\tmonth = get_month_number (month);\n\t\tif 0 == month then return false; end\t\t\t\t\t\t\t\t\t\t\t\t-- return false if month text isn't one of the twelve months\n\n\telseif date_string:match(\"^[1-9]%d?\u2013[1-9]%d? +%a+ +[1-9]%d%d%d%a?$\") then\t\t\t\t-- day-range-initial: day\u2013day month year; days are separated by endash\n\t\tday, day2, month, anchor_year, year=string.match(date_string, \"(%d%d?)\u2013(%d%d?) +(%a+) +((%d%d%d%d)%a?)\");\n\t\tif tonumber(day) >= tonumber(day2) then return false; end\t\t\t\t\t\t\t-- date range order is left to right: earlier to later; dates may not be the same;\n\t\tmonth = get_month_number (month);\n\t\tif 0 == month then return false; end\t\t\t\t\t\t\t\t\t\t\t\t-- return false if month text isn't one of the twelve months\n\t\tmonth2=month;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- for metadata\n\t\tyear2=year;\n\n\telseif date_string:match(\"^[1-9]%d? +%a+ \u2013 [1-9]%d? +%a+ +[1-9]%d%d%d%a?$\") then\t\t-- day initial month-day-range: day month - day month year; uses spaced endash\n\t\tday, month, day2, month2, anchor_year, year=date_string:match(\"(%d%d?) +(%a+) \u2013 (%d%d?) +(%a+) +((%d%d%d%d)%a?)\");\n\t\tif (not is_valid_month_season_range(month, month2)) or not is_valid_year(year) then return false; end\t-- date range order is left to right: earlier to later;\n\t\tmonth = get_month_number (month);\t\t\t\t\t\t\t\t\t\t\t\t\t-- for metadata\n\t\tmonth2 = get_month_number (month2);\n\t\tyear2=year;\n\n\telseif date_string:match(\"^%a+ +[1-9]%d? \u2013 %a+ +[1-9]%d?, +[1-9]%d%d%d?%a?$\") then\t\t-- month initial month-day-range: month day \u2013 month day, year;  uses spaced endash\n\t\tmonth, day, month2, day2, anchor_year, year=date_string:match(\"(%a+) +(%d%d?) \u2013 (%a+) +(%d%d?), +((%d%d%d%d)%a?)\");\n\t\tif (not is_valid_month_season_range(month, month2)) or not is_valid_year(year) then return false; end\n\t\tmonth = get_month_number (month);\t\t\t\t\t\t\t\t\t\t\t\t\t-- for metadata\n\t\tmonth2 = get_month_number (month2);\n\t\tyear2=year;\n\n\telseif date_string:match(\"^[1-9]%d? +%a+ +[1-9]%d%d%d \u2013 [1-9]%d? +%a+ +[1-9]%d%d%d%a?$\") then\t\t-- day initial month-day-year-range: day month year - day month year; uses spaced endash\n\t\tday, month, year, day2, month2, anchor_year, year2=date_string:match(\"(%d%d?) +(%a+) +(%d%d%d%d?) \u2013 (%d%d?) +(%a+) +((%d%d%d%d?)%a?)\");\n\t\tif tonumber(year2) <= tonumber(year) then return false; end\t\t\t\t\t\t\t\t\t\t\t\t-- must be sequential years, left to right, earlier to later\n\t\tif not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end\t\t-- year2 no more than one year in the future; months same style\n\t\tmonth = get_month_number (month);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- for metadata\n\t\tmonth2 = get_month_number (month2);\n\n\telseif date_string:match(\"^%a+ +[1-9]%d?, +[1-9]%d%d%d \u2013 %a+ +[1-9]%d?, +[1-9]%d%d%d%a?$\") then\t\t-- month initial month-day-year-range: month day, year \u2013 month day, year;  uses spaced endash\n\t\tmonth, day, year, month2, day2, anchor_year, year2=date_string:match(\"(%a+) +(%d%d?), +(%d%d%d%d) \u2013 (%a+) +(%d%d?), +((%d%d%d%d)%a?)\");\n\t\tif tonumber(year2) <= tonumber(year) then return false; end\t\t\t\t\t\t\t\t\t\t\t\t-- must be sequential years, left to right, earlier to later\n\t\tif not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end\t\t-- year2 no more than one year in the future; months same style\n\t\tmonth = get_month_number (month);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- for metadata\n\t\tmonth2 = get_month_number (month2);\n\n\telseif date_string:match(\"^%a+ +[1-9]%d%d%d\u2013%d%d%a?$\") then\t\t\t\t\t\t\t\t-- special case Winter/Summer year-year (YYYY-YY); year separated with unspaced endash\n\t\tlocal century;\n\t\tmonth, year, century, anchor_year, year2=date_string:match(\"(%a+) +((%d%d)%d%d)\u2013((%d%d)%a?)\");\n\t\tif 'Winter' ~= month and 'Summer' ~= month then return false end;\t\t\t\t\t-- 'month' can only be Winter or Summer\n\t\tanchor_year=year..'\u2013'..anchor_year;\t\t\t\t\t\t\t\t\t\t\t\t\t-- assemble anchor_year from both years\n\t\tyear2 = century..year2;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- add the century to year2 for comparisons\n\t\tif 1 ~= tonumber(year2) - tonumber(year) then return false; end\t\t\t\t\t\t-- must be sequential years, left to right, earlier to later\n\t\tif not is_valid_year(year2) then return false; end\t\t\t\t\t\t\t\t\t-- no year farther in the future than next year\n\t\tmonth = get_season_number (month);\n\n\telseif date_string:match(\"^%a+ +[1-9]%d%d%d\u2013[1-9]%d%d%d%a?$\") then\t\t\t\t\t\t-- special case Winter/Summer year-year; year separated with unspaced endash\n\t\tmonth, year, anchor_year, year2=date_string:match(\"(%a+) +(%d%d%d%d)\u2013((%d%d%d%d)%a?)\");\n\t\tif 'Winter' ~= month and 'Summer' ~= month then return false end;\t\t\t\t\t-- 'month' can only be Winter or Summer\n\t\tanchor_year=year..'\u2013'..anchor_year;\t\t\t\t\t\t\t\t\t\t\t\t\t-- assemble anchor_year from both years\n\t\tif 1 ~= tonumber(year2) - tonumber(year) then return false; end\t\t\t\t\t\t-- must be sequential years, left to right, earlier to later\n\t\tif not is_valid_year(year2) then return false; end\t\t\t\t\t\t\t\t\t-- no year farther in the future than next year\n\t\tmonth = get_season_number (month);\t\t\t\t\t\t\t\t\t\t\t\t\t-- for metadata\n\n\telseif date_string:match(\"^%a+ +[1-9]%d%d%d% \u2013 %a+ +[1-9]%d%d%d%a?$\") then\t\t\t\t-- month/season year - month/season year; separated by spaced endash\n\t\tmonth, year, month2, anchor_year, year2=date_string:match(\"(%a+) +(%d%d%d%d) \u2013 (%a+) +((%d%d%d%d)%a?)\");\n\t\tanchor_year=year..'\u2013'..anchor_year;\t\t\t\t\t\t\t\t\t\t\t\t\t-- assemble anchor_year from both years\n\t\tif tonumber(year) >= tonumber(year2) then return false; end\t\t\t\t\t\t\t-- left to right, earlier to later, not the same\n\t\tif not is_valid_year(year2) then return false; end\t\t\t\t\t\t\t\t\t-- no year farther in the future than next year\n\t\tif 0 ~= get_month_number(month) and 0 ~= get_month_number(month2) and is_valid_month_range_style(month, month2) then \t-- both must be month year, same month style\n\t\t\tmonth = get_month_number(month);\n\t\t\tmonth2 = get_month_number(month2);\n\t\telseif 0 ~= get_season_number(month) and 0 ~= get_season_number(month2) then\t\t-- both must be or season year, not mixed\n\t\t\tmonth = get_season_number(month);\n\t\t\tmonth2 = get_season_number(month2);\n\t\telse\n\t\t\t return false;\n\t\tend\n\n\telseif date_string:match (\"^%a+\u2013%a+ +[1-9]%d%d%d%a?$\") then\t\t\t\t\t-- month/season range year; months separated by endash \n\t\tmonth, month2, anchor_year, year=date_string:match (\"(%a+)\u2013(%a+)%s*((%d%d%d%d)%a?)\");\n\t\tif (not is_valid_month_season_range(month, month2)) or (not is_valid_year(year)) then return false; end\n\t\tif 0 ~= get_month_number(month) then\t\t\t\t\t\t\t\t\t-- determined to be a valid range so just check this one to know if month or season\n\t\t\tmonth = get_month_number(month);\n\t\t\tmonth2 = get_month_number(month2);\n\t\telse\n\t\t\tmonth = get_season_number(month);\n\t\t\tmonth2 = get_season_number(month2);\n\t\tend\n\t\tyear2=year;\n\t\t\n\telseif date_string:match(\"^%a+ +%d%d%d%d%a?$\") then\t\t\t\t\t\t\t-- month/season year or proper-name year\n\t\tmonth, anchor_year, year=date_string:match(\"(%a+)%s*((%d%d%d%d)%a?)\");\n\t\tif not is_valid_year(year) then return false; end\n\t\tif not is_valid_month_or_season (month) and 0 == is_proper_name (month) then return false; end\n\t\tif 0 ~= get_month_number(month) then\t\t\t\t\t\t\t\t\t-- determined to be a valid range so just check this one to know if month or season\n\t\t\tmonth = get_month_number(month);\n\t\telseif 0 ~= get_season_number(month) then\n\t\t\tmonth = get_season_number(month);\n\t\telse\n\t\t\tmonth = is_proper_name (month);\t\t\t\t\t\t\t\t\t\t-- must be proper name; not supported in COinS\n\t\tend\n\n\telseif date_string:match(\"^[1-9]%d%d%d?\u2013[1-9]%d%d%d?%a?$\") then\t\t\t\t-- Year range: YYY-YYY or YYY-YYYY or YYYY\u2013YYYY; separated by unspaced endash; 100-9999\n\t\tyear, anchor_year, year2=date_string:match(\"(%d%d%d%d?)\u2013((%d%d%d%d?)%a?)\");\n\t\tanchor_year=year..'\u2013'..anchor_year;\t\t\t\t\t\t\t\t\t\t-- assemble anchor year from both years\n\t\tif tonumber(year) >= tonumber(year2) then return false; end\t\t\t\t-- left to right, earlier to later, not the same\n\t\tif not is_valid_year(year2) then return false; end\t\t\t\t\t\t-- no year farther in the future than next year\n\n\telseif date_string:match(\"^[1-9]%d%d%d\u2013%d%d%a?$\") then\t\t\t\t\t\t-- Year range: YYYY\u2013YY; separated by unspaced endash\n\t\tlocal century;\n\t\tyear, century, anchor_year, year2=date_string:match(\"((%d%d)%d%d)\u2013((%d%d)%a?)\");\n\t\tanchor_year=year..'\u2013'..anchor_year;\t\t\t\t\t\t\t\t\t\t-- assemble anchor year from both years\n\t\tif 13 > tonumber(year2) then return false; end\t\t\t\t\t\t\t-- don't allow 2003-05 which might be May 2003\n\t\tyear2 = century..year2;\t\t\t\t\t\t\t\t\t\t\t\t\t-- add the century to year2 for comparisons\n\t\tif tonumber(year) >= tonumber(year2) then return false; end\t\t\t\t-- left to right, earlier to later, not the same\n\t\tif not is_valid_year(year2) then return false; end\t\t\t\t\t\t-- no year farther in the future than next year\n\n\telseif date_string:match(\"^[1-9]%d%d%d?%a?$\") then\t\t\t\t\t\t\t-- year; here accept either YYY or YYYY\n\t\tanchor_year, year=date_string:match(\"((%d%d%d%d?)%a?)\");\n\t\tif false == is_valid_year(year) then\n\t\t\treturn false;\n\t\tend\n\n\t-- LOCAL: do not use mw.ustring: it allows full-width characters for %d.\n\telseif date_string:match(\"^[1-9]%d%d%d\u5e74[1-9]%d?\u6708[1-9]%d?\u65e5$\") then\t\t\t\t\t\t-- zh: year month day\n\t\tyear, month, day=date_string:match(\"(%d%d%d%d)\u5e74(%d%d*\u6708)(%d%d*)\u65e5\");\n\t\tmonth = get_month_number (month);\n\t\tif 0 == month then return false; end\n\t\tanchor_year = year;\n\n\telseif date_string:match(\"^[1-9]%d%d%d\u5e74[1-9]%d?\u6708$\") then\t\t\t\t\t\t\t-- zh: year month\n\t\tyear, month=date_string:match(\"(%d%d%d%d)\u5e74(%d%d*\u6708)\");\n\t\tmonth = get_month_number (month);\n\t\tif 0 == month then return false; end\n\t\tanchor_year = year;\n\n\telseif date_string:match(\"^[1-9]%d%d%d?\u5e74$\") then\t\t\t\t\t\t\t-- zh: year; here accept either YYY or YYYY\n\t\tyear=date_string:match(\"(%d%d%d%d?)\u5e74\");\n\t\tif false == is_valid_year(year) then\n\t\t\treturn false;\n\t\tend\n\t\tanchor_year = year;\n\n\telseif date_string:match(\"^%d%d%d%d%-%d%d$\") then\t\t\t\t\t\t\t-- numerical year month format\n\t\tyear, month=date_string:match(\"(%d%d%d%d)%-(%d%d)\");\n\t\tmonth=tonumber(month);\n\t\tif 12 < month or 1 > month or 1583 > tonumber(year) then return false; end\t\t\t-- month number not valid or not Gregorian calendar\n\t\tanchor_year = year;\n\t-- END LOCAL\n\n\telse\n\t\treturn false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- date format not one of the MOS:DATE approved formats\n\tend\n\n\tlocal result=true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- check whole dates for validity; assume true because not all dates will go through this test\n\tif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 == day2 then\t\t-- YMD (simple whole date)\n\t\tresult=is_valid_date(year,month,day);\n\n\telseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 ~= day2 then\t-- YMD-d (day range)\n\t\tresult=is_valid_date(year,month,day);\n\t\tresult=result and is_valid_date(year,month,day2);\n\n\telseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 ~= month2 and 0 ~= day2 then\t-- YMD-md (day month range)\n\t\tresult=is_valid_date(year,month,day);\n\t\tresult=result and is_valid_date(year,month2,day2);\n\n\telseif 0 ~= year and 0 ~= month and 0 ~= day and 0 ~= year2 and 0 ~= month2 and 0 ~= day2 then\t-- YMD-ymd (day month year range)\n\t\tresult=is_valid_date(year,month,day);\n\t\tresult=result and is_valid_date(year2,month2,day2);\n\tend\n\t\n\tif false == result then return false; end\n\n\tif nil ~= tCOinS_date then\t\t\t\t\t\t\t\t\t\t\t\t\t-- this table only passed into this function when testing |date= parameter values\n\t\tmake_COinS_date ({year=year, month=month, day=day, year2=year2, month2=month2, day2=day2}, tCOinS_date);\t-- make an ISO 8601 date string for COinS\n\tend\n\t\n\treturn true, anchor_year;\t\t\t\t\t\t\t\t\t\t\t\t\t-- format is good and date string represents a real date\nend\t\n\n\n--[[--------------------------< D A T E S >--------------------------------------------------------------------\n\nCycle the date-holding parameters in passed table date_parameters_list through check_date() to check compliance with MOS:DATE. For all valid dates, check_date() returns\ntrue. The |date= parameter test is unique, it is the only date holding parameter from which values for anchor_year (used in CITEREF identifiers) and COinS_date (used in\nthe COinS metadata) are derived.  The |date= parameter is the only date-holding parameter that is allowed to contain the no-date keywords \"n.d.\" or \"nd\" (without quotes).\n\nUnlike most error messages created in this module, only one error message is created by this function. Because all of the date holding parameters are processed serially,\na single error message is created as the dates are tested.\n\n]]\n\nlocal function dates(date_parameters_list, tCOinS_date)\n\tlocal anchor_year;\t\t-- will return as nil if the date being tested is not |date=\n\tlocal COinS_date;\t\t-- will return as nil if the date being tested is not |date=\n\tlocal error_message = \"\";\n\tlocal good_date = false;\n\t\n\tfor k, v in pairs(date_parameters_list) do\t\t\t\t\t\t\t\t\t-- for each date-holding parameter in the list\n\t\tif is_set(v) then\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if the parameter has a value\n\t\t\tif v:match(\"^c%. [1-9]%d%d%d?%a?$\") then\t\t\t\t\t\t\t-- special case for c. year or with or without CITEREF disambiguator - only |date= and |year=\n\t\t\t\tlocal year = v:match(\"c%. ([1-9]%d%d%d?)%a?\");\t\t\t\t\t-- get the year portion so it can be tested\n\t\t\t\tif 'date'==k then\n\t\t\t\t\tanchor_year, COinS_date = v:match(\"((c%. [1-9]%d%d%d?)%a?)\");\t-- anchor year and COinS_date only from |date= parameter\n\t\t\t\t\tgood_date = is_valid_year(year);\n\t\t\t\telseif 'year'==k then\n\t\t\t\t\tgood_date = is_valid_year(year);\n\t\t\t\tend\n\t\t\telseif 'date'==k then\t\t\t\t\t\t\t\t\t\t\t\t-- if the parameter is |date=\n\t\t\t\tif v:match(\"^n%.d%.%a?\") then\t\t\t\t\t\t\t\t\t-- if |date=n.d. with or without a CITEREF disambiguator\n\t\t\t\t\tgood_date, anchor_year, COinS_date = true, v:match(\"((n%.d%.)%a?)\");\t--\"n.d.\"; no error when date parameter is set to no date\n\t\t\t\telseif v:match(\"^nd%a?$\") then\t\t\t\t\t\t\t\t\t-- if |date=nd with or without a CITEREF disambiguator\n\t\t\t\t\tgood_date, anchor_year, COinS_date = true, v:match(\"((nd)%a?)\");\t--\"nd\";\tno error when date parameter is set to no date\n\t\t\t\telse\n\t\t\t\t\tgood_date, anchor_year, COinS_date = check_date (v, tCOinS_date);\t-- go test the date\n\t\t\t\tend\n\t\t\telseif 'access-date'==k then\t\t\t\t\t\t\t\t\t\t-- if the parameter is |date=\n\t\t\t\tgood_date = check_date (v);\t\t\t\t\t\t\t\t\t\t-- go test the date\n\t\t\t\tif true == good_date then\t\t\t\t\t\t\t\t\t\t-- if the date is a valid date\n\t\t\t\t\tgood_date = is_valid_accessdate (v);\t\t\t\t\t\t-- is Wikipedia start date < accessdate < tomorrow's date?\n\t\t\t\tend\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- any other date-holding parameter\n\t\t\t\tgood_date = check_date (v);\t\t\t\t\t\t\t\t\t\t-- go test the date\n\t\t\tend\n\t\t\tif false==good_date then\t\t\t\t\t\t\t\t\t\t\t-- assemble one error message so we don't add the tracking category multiple times\n\t\t\t\tif is_set(error_message) then\t\t\t\t\t\t\t\t\t-- once we've added the first portion of the error message ...\n\t\t\t\t\terror_message=error_message .. \", \";\t\t\t\t\t\t-- ... add a comma space separator\n\t\t\t\tend\n\t\t\t\terror_message=error_message .. \"&#124;\" .. k .. \"=\";\t\t\t-- add the failed parameter\n\t\t\tend\n\t\tend\n\tend\n\treturn anchor_year, error_message;\t\t\t\t\t\t\t\t\t\t\t-- and done\nend\n\n\n--[[--------------------------< Y E A R _ D A T E _ C H E C K >------------------------------------------------\n\nCompare the value provided in |year= with the year value(s) provided in |date=.  This function returns a numeric value:\n\t0 - year value does not match the year value in date\n\t1 - (default) year value matches the year value in date or one of the year values when date contains two years\n\t2 - year value matches the year value in date when date is in the form YYYY-MM-DD and year is disambiguated (|year=YYYYx)\n\n]]\n\nlocal function year_date_check (year_string, date_string)\n\tlocal year;\n\tlocal date1;\n\tlocal date2;\n\tlocal result = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- result of the test; assume that the test passes\n\t\n\tyear = year_string:match ('(%d%d%d%d?)');\n\n\tif date_string:match ('%d%d%d%d%-%d%d%-%d%d') and year_string:match ('%d%d%d%d%a') then\t--special case where date and year required YYYY-MM-DD and YYYYx\n\t\tdate1 = date_string:match ('(%d%d%d%d)');\n\t\tyear = year_string:match ('(%d%d%d%d)');\n\t\tif year ~= date1 then\n\t\t\tresult = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- years don't match\n\t\telse\n\t\t\tresult = 2;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- years match; but because disambiguated, don't add to maint cat\n\t\tend\n\t\t\n\telseif date_string:match (\"%d%d%d%d?.-%d%d%d%d?\") then\t\t\t\t\t\t-- any of the standard formats of date with two three- or four-digit years\n\t\tdate1, date2 = date_string:match (\"(%d%d%d%d?).-(%d%d%d%d?)\");\n\t\tif year ~= date1 and year ~= date2 then\n\t\t\tresult = 0;\n\t\tend\n\n\telseif date_string:match (\"%d%d%d%d[%s%-\u2013]+%d%d\") then\t\t\t\t\t\t-- YYYY-YY date ranges\n\t\tlocal century;\n\t\tdate1, century, date2 = date_string:match (\"((%d%d)%d%d)[%s%-\u2013]+(%d%d)\");\n\t\tdate2 = century..date2;\t\t\t\t\t\t\t\t\t\t\t\t\t-- convert YY to YYYY\n\t\tif year ~= date1 and year ~= date2 then\n\t\t\tresult = 0;\n\t\tend\n\n\telseif date_string:match (\"%d%d%d%d?\") then\t\t\t\t\t\t\t\t\t-- any of the standard formats of date with one year\n\t\tdate1 = date_string:match (\"(%d%d%d%d?)\");\n\t\tif year ~= date1 then\n\t\t\tresult = 0;\n\t\tend\n\tend\n\treturn result;\nend\n\nreturn {dates = dates, year_date_check = year_date_check}\t\t\t\t\t\t-- return exported functions"}}}