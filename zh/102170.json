{"parse":{"title":"MediaWiki:Gadget-code-prettify-core.js","pageid":103583,"wikitext":{"*":"//\u4f7f\u7528\u672cjs\u53ea\u662f\u4e3a\u4e86\u65b9\u4fbf\u65e0\u6cd5\u83b7\u5f97Google\u7684js\u7684\u7528\u6237\u4f7f\u7528\uff0c\u672c\u6587\u4ef6\u5404\u9879\u6743\u5229\u6309\u4e0b\u5217\u58f0\u660e\u5f52\u5404\u81ea\u6240\u6709\u8005\u6240\u6709\n\n/* https://github.com/google/code-prettify/blob/master/src/prettify.js */\n/**\n * @license\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar DecorationsT;\n\nvar JobT;\n\nvar SourceSpansT;\n\nvar IN_GLOBAL_SCOPE = true;\n\nvar PR;\n\nvar PR_SHOULD_USE_CONTINUATION = true;\n\nif (typeof window !== \"undefined\") {\n    window.PR_SHOULD_USE_CONTINUATION = PR_SHOULD_USE_CONTINUATION;\n}\n\nvar prettyPrintOne;\n\nvar prettyPrint;\n\n(function() {\n    var win = typeof window !== \"undefined\" ? window : {};\n    var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n    var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"auto,case,char,const,default,\" + \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" + \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n    var COMMON_KEYWORDS = [C_KEYWORDS, \"catch,class,delete,false,import,\" + \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n    var CPP_KEYWORDS = [COMMON_KEYWORDS, \"alignas,alignof,align_union,asm,axiom,bool,\" + \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" + \"dynamic_cast,explicit,export,friend,generic,late_check,\" + \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" + \"static_cast,template,typeid,typename,using,virtual,where\"];\n    var JAVA_KEYWORDS = [COMMON_KEYWORDS, \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" + \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" + \"throws,transient\"];\n    var CSHARP_KEYWORDS = [COMMON_KEYWORDS, \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" + \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" + \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" + \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" + \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\n    var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" + \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" + \"throw,true,try,unless,until,when,while,yes\";\n    var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS, \"abstract,async,await,constructor,debugger,enum,eval,export,from,function,\" + \"get,import,implements,instanceof,interface,let,null,of,set,undefined,\" + \"var,with,yield,Infinity,NaN\"];\n    var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" + \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" + \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n    var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" + \"elif,except,exec,finally,from,global,import,in,is,lambda,\" + \"nonlocal,not,or,pass,print,raise,try,with,yield,\" + \"False,True,None\"];\n    var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" + \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" + \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" + \"BEGIN,END\"];\n    var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" + \"function,in,local,set,then,until\"];\n    var ALL_KEYWORDS = [CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n    var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n    var PR_STRING = \"str\";\n    var PR_KEYWORD = \"kwd\";\n    var PR_COMMENT = \"com\";\n    var PR_TYPE = \"typ\";\n    var PR_LITERAL = \"lit\";\n    var PR_PUNCTUATION = \"pun\";\n    var PR_PLAIN = \"pln\";\n    var PR_TAG = \"tag\";\n    var PR_DECLARATION = \"dec\";\n    var PR_SOURCE = \"src\";\n    var PR_ATTRIB_NAME = \"atn\";\n    var PR_ATTRIB_VALUE = \"atv\";\n    var PR_NOCODE = \"nocode\";\n    var REGEXP_PRECEDER_PATTERN = \"(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*\";\n\n    function combinePrefixPatterns(regexs) {\n        var capturedGroupIndex = 0;\n        var needToFoldCase = false;\n        var ignoreCase = false;\n        for (var i = 0, n = regexs.length; i < n; ++i) {\n            var regex = regexs[i];\n            if (regex.ignoreCase) {\n                ignoreCase = true;\n            } else if (/[a-z]/i.test(regex.source.replace(/\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, \"\"))) {\n                needToFoldCase = true;\n                ignoreCase = false;\n                break;\n            }\n        }\n        var escapeCharToCodeUnit = {\n            b: 8,\n            t: 9,\n            n: 10,\n            v: 11,\n            f: 12,\n            r: 13\n        };\n\n        function decodeEscape(charsetPart) {\n            var cc0 = charsetPart.charCodeAt(0);\n            if (cc0 !== 92) {\n                return cc0;\n            }\n            var c1 = charsetPart.charAt(1);\n            cc0 = escapeCharToCodeUnit[c1];\n            if (cc0) {\n                return cc0;\n            } else if (\"0\" <= c1 && c1 <= \"7\") {\n                return parseInt(charsetPart.substring(1), 8);\n            } else if (c1 === \"u\" || c1 === \"x\") {\n                return parseInt(charsetPart.substring(2), 16);\n            } else {\n                return charsetPart.charCodeAt(1);\n            }\n        }\n\n        function encodeEscape(charCode) {\n            if (charCode < 32) {\n                return (charCode < 16 ? \"\\\\x0\" : \"\\\\x\") + charCode.toString(16);\n            }\n            var ch = String.fromCharCode(charCode);\n            return ch === \"\\\\\" || ch === \"-\" || ch === \"]\" || ch === \"^\" ? \"\\\\\" + ch : ch;\n        }\n\n        function caseFoldCharset(charSet) {\n            var charsetParts = charSet.substring(1, charSet.length - 1).match(new RegExp(\"\\\\\\\\u[0-9A-Fa-f]{4}\" + \"|\\\\\\\\x[0-9A-Fa-f]{2}\" + \"|\\\\\\\\[0-3][0-7]{0,2}\" + \"|\\\\\\\\[0-7]{1,2}\" + \"|\\\\\\\\[\\\\s\\\\S]\" + \"|-\" + \"|[^-\\\\\\\\]\", \"g\"));\n            var ranges = [];\n            var inverse = charsetParts[0] === \"^\";\n            var out = [\"[\"];\n            if (inverse) {\n                out.push(\"^\");\n            }\n            for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n                var p = charsetParts[i];\n                if (/\\\\[bdsw]/i.test(p)) {\n                    out.push(p);\n                } else {\n                    var start = decodeEscape(p);\n                    var end;\n                    if (i + 2 < n && \"-\" === charsetParts[i + 1]) {\n                        end = decodeEscape(charsetParts[i + 2]);\n                        i += 2;\n                    } else {\n                        end = start;\n                    }\n                    ranges.push([start, end]);\n                    if (!(end < 65 || start > 122)) {\n                        if (!(end < 65 || start > 90)) {\n                            ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n                        }\n                        if (!(end < 97 || start > 122)) {\n                            ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n                        }\n                    }\n                }\n            }\n            ranges.sort(function(a, b) {\n                return a[0] - b[0] || b[1] - a[1];\n            });\n            var consolidatedRanges = [];\n            var lastRange = [];\n            for (var i = 0; i < ranges.length; ++i) {\n                var range = ranges[i];\n                if (range[0] <= lastRange[1] + 1) {\n                    lastRange[1] = Math.max(lastRange[1], range[1]);\n                } else {\n                    consolidatedRanges.push(lastRange = range);\n                }\n            }\n            for (var i = 0; i < consolidatedRanges.length; ++i) {\n                var range = consolidatedRanges[i];\n                out.push(encodeEscape(range[0]));\n                if (range[1] > range[0]) {\n                    if (range[1] + 1 > range[0]) {\n                        out.push(\"-\");\n                    }\n                    out.push(encodeEscape(range[1]));\n                }\n            }\n            out.push(\"]\");\n            return out.join(\"\");\n        }\n\n        function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n            var parts = regex.source.match(new RegExp(\"(?:\" + \"\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]\" + \"|\\\\\\\\u[A-Fa-f0-9]{4}\" + \"|\\\\\\\\x[A-Fa-f0-9]{2}\" + \"|\\\\\\\\[0-9]+\" + \"|\\\\\\\\[^ux0-9]\" + \"|\\\\(\\\\?[:!=]\" + \"|[\\\\(\\\\)\\\\^]\" + \"|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+\" + \")\", \"g\"));\n            var n = parts.length;\n            var capturedGroups = [];\n            for (var i = 0, groupIndex = 0; i < n; ++i) {\n                var p = parts[i];\n                if (p === \"(\") {\n                    ++groupIndex;\n                } else if (\"\\\\\" === p.charAt(0)) {\n                    var decimalValue = +p.substring(1);\n                    if (decimalValue) {\n                        if (decimalValue <= groupIndex) {\n                            capturedGroups[decimalValue] = -1;\n                        } else {\n                            parts[i] = encodeEscape(decimalValue);\n                        }\n                    }\n                }\n            }\n            for (var i = 1; i < capturedGroups.length; ++i) {\n                if (-1 === capturedGroups[i]) {\n                    capturedGroups[i] = ++capturedGroupIndex;\n                }\n            }\n            for (var i = 0, groupIndex = 0; i < n; ++i) {\n                var p = parts[i];\n                if (p === \"(\") {\n                    ++groupIndex;\n                    if (!capturedGroups[groupIndex]) {\n                        parts[i] = \"(?:\";\n                    }\n                } else if (\"\\\\\" === p.charAt(0)) {\n                    var decimalValue = +p.substring(1);\n                    if (decimalValue && decimalValue <= groupIndex) {\n                        parts[i] = \"\\\\\" + capturedGroups[decimalValue];\n                    }\n                }\n            }\n            for (var i = 0; i < n; ++i) {\n                if (\"^\" === parts[i] && \"^\" !== parts[i + 1]) {\n                    parts[i] = \"\";\n                }\n            }\n            if (regex.ignoreCase && needToFoldCase) {\n                for (var i = 0; i < n; ++i) {\n                    var p = parts[i];\n                    var ch0 = p.charAt(0);\n                    if (p.length >= 2 && ch0 === \"[\") {\n                        parts[i] = caseFoldCharset(p);\n                    } else if (ch0 !== \"\\\\\") {\n                        parts[i] = p.replace(/[a-zA-Z]/g, function(ch) {\n                            var cc = ch.charCodeAt(0);\n                            return \"[\" + String.fromCharCode(cc & ~32, cc | 32) + \"]\";\n                        });\n                    }\n                }\n            }\n            return parts.join(\"\");\n        }\n        var rewritten = [];\n        for (var i = 0, n = regexs.length; i < n; ++i) {\n            var regex = regexs[i];\n            if (regex.global || regex.multiline) {\n                throw new Error(\"\" + regex);\n            }\n            rewritten.push(\"(?:\" + allowAnywhereFoldCaseAndRenumberGroups(regex) + \")\");\n        }\n        return new RegExp(rewritten.join(\"|\"), ignoreCase ? \"gi\" : \"g\");\n    }\n\n    function extractSourceSpans(node, isPreformatted) {\n        var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n        var chunks = [];\n        var length = 0;\n        var spans = [];\n        var k = 0;\n\n        function walk(node) {\n            var type = node.nodeType;\n            if (type == 1) {\n                if (nocode.test(node.className)) {\n                    return;\n                }\n                for (var child = node.firstChild; child; child = child.nextSibling) {\n                    walk(child);\n                }\n                var nodeName = node.nodeName.toLowerCase();\n                if (\"br\" === nodeName || \"li\" === nodeName) {\n                    chunks[k] = \"\\n\";\n                    spans[k << 1] = length++;\n                    spans[k++ << 1 | 1] = node;\n                }\n            } else if (type == 3 || type == 4) {\n                var text = node.nodeValue;\n                if (text.length) {\n                    if (!isPreformatted) {\n                        text = text.replace(/[ \\t\\r\\n]+/g, \" \");\n                    } else {\n                        text = text.replace(/\\r\\n?/g, \"\\n\");\n                    }\n                    chunks[k] = text;\n                    spans[k << 1] = length;\n                    length += text.length;\n                    spans[k++ << 1 | 1] = node;\n                }\n            }\n        }\n        walk(node);\n        return {\n            sourceCode: chunks.join(\"\").replace(/\\n$/, \"\"),\n            spans: spans\n        };\n    }\n\n    function appendDecorations(sourceNode, basePos, sourceCode, langHandler, out) {\n        if (!sourceCode) {\n            return;\n        }\n        var job = {\n            sourceNode: sourceNode,\n            pre: 1,\n            langExtension: null,\n            numberLines: null,\n            sourceCode: sourceCode,\n            spans: null,\n            basePos: basePos,\n            decorations: null\n        };\n        langHandler(job);\n        out.push.apply(out, job.decorations);\n    }\n    var notWs = /\\S/;\n\n    function childContentWrapper(element) {\n        var wrapper = undefined;\n        for (var c = element.firstChild; c; c = c.nextSibling) {\n            var type = c.nodeType;\n            wrapper = type === 1 ? wrapper ? element : c : type === 3 ? notWs.test(c.nodeValue) ? element : wrapper : wrapper;\n        }\n        return wrapper === element ? undefined : wrapper;\n    }\n\n    function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n        var shortcuts = {};\n        var tokenizer;\n        (function() {\n            var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n            var allRegexs = [];\n            var regexKeys = {};\n            for (var i = 0, n = allPatterns.length; i < n; ++i) {\n                var patternParts = allPatterns[i];\n                var shortcutChars = patternParts[3];\n                if (shortcutChars) {\n                    for (var c = shortcutChars.length; --c >= 0;) {\n                        shortcuts[shortcutChars.charAt(c)] = patternParts;\n                    }\n                }\n                var regex = patternParts[1];\n                var k = \"\" + regex;\n                if (!regexKeys.hasOwnProperty(k)) {\n                    allRegexs.push(regex);\n                    regexKeys[k] = null;\n                }\n            }\n            allRegexs.push(/[\\0-\\uffff]/);\n            tokenizer = combinePrefixPatterns(allRegexs);\n        })();\n        var nPatterns = fallthroughStylePatterns.length;\n        var decorate = function(job) {\n            var sourceCode = job.sourceCode,\n                basePos = job.basePos;\n            var sourceNode = job.sourceNode;\n            var decorations = [basePos, PR_PLAIN];\n            var pos = 0;\n            var tokens = sourceCode.match(tokenizer) || [];\n            var styleCache = {};\n            for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n                var token = tokens[ti];\n                var style = styleCache[token];\n                var match = void 0;\n                var isEmbedded;\n                if (typeof style === \"string\") {\n                    isEmbedded = false;\n                } else {\n                    var patternParts = shortcuts[token.charAt(0)];\n                    if (patternParts) {\n                        match = token.match(patternParts[1]);\n                        style = patternParts[0];\n                    } else {\n                        for (var i = 0; i < nPatterns; ++i) {\n                            patternParts = fallthroughStylePatterns[i];\n                            match = token.match(patternParts[1]);\n                            if (match) {\n                                style = patternParts[0];\n                                break;\n                            }\n                        }\n                        if (!match) {\n                            style = PR_PLAIN;\n                        }\n                    }\n                    isEmbedded = style.length >= 5 && \"lang-\" === style.substring(0, 5);\n                    if (isEmbedded && !(match && typeof match[1] === \"string\")) {\n                        isEmbedded = false;\n                        style = PR_SOURCE;\n                    }\n                    if (!isEmbedded) {\n                        styleCache[token] = style;\n                    }\n                }\n                var tokenStart = pos;\n                pos += token.length;\n                if (!isEmbedded) {\n                    decorations.push(basePos + tokenStart, style);\n                } else {\n                    var embeddedSource = match[1];\n                    var embeddedSourceStart = token.indexOf(embeddedSource);\n                    var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n                    if (match[2]) {\n                        embeddedSourceEnd = token.length - match[2].length;\n                        embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n                    }\n                    var lang = style.substring(5);\n                    appendDecorations(sourceNode, basePos + tokenStart, token.substring(0, embeddedSourceStart), decorate, decorations);\n                    appendDecorations(sourceNode, basePos + tokenStart + embeddedSourceStart, embeddedSource, langHandlerForExtension(lang, embeddedSource), decorations);\n                    appendDecorations(sourceNode, basePos + tokenStart + embeddedSourceEnd, token.substring(embeddedSourceEnd), decorate, decorations);\n                }\n            }\n            job.decorations = decorations;\n        };\n        return decorate;\n    }\n\n    function sourceDecorator(options) {\n        var shortcutStylePatterns = [],\n            fallthroughStylePatterns = [];\n        if (options[\"tripleQuotedStrings\"]) {\n            shortcutStylePatterns.push([PR_STRING, /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/, null, \"'\\\"\"]);\n        } else if (options[\"multiLineStrings\"]) {\n            shortcutStylePatterns.push([PR_STRING, /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/, null, \"'\\\"`\"]);\n        } else {\n            shortcutStylePatterns.push([PR_STRING, /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/, null, \"\\\"'\"]);\n        }\n        if (options[\"verbatimStrings\"]) {\n            fallthroughStylePatterns.push([PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n        }\n        var hc = options[\"hashComments\"];\n        if (hc) {\n            if (options[\"cStyleComments\"]) {\n                if (hc > 1) {\n                    shortcutStylePatterns.push([PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, \"#\"]);\n                } else {\n                    shortcutStylePatterns.push([PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/, null, \"#\"]);\n                }\n                fallthroughStylePatterns.push([PR_STRING, /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/, null]);\n            } else {\n                shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, \"#\"]);\n            }\n        }\n        if (options[\"cStyleComments\"]) {\n            fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n            fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n        }\n        var regexLiterals = options[\"regexLiterals\"];\n        if (regexLiterals) {\n            var regexExcls = regexLiterals > 1 ? \"\" : \"\\n\\r\";\n            var regexAny = regexExcls ? \".\" : \"[\\\\S\\\\s]\";\n            var REGEX_LITERAL = \"/(?=[^/*\" + regexExcls + \"])\" + \"(?:[^/\\\\x5B\\\\x5C\" + regexExcls + \"]\" + \"|\\\\x5C\" + regexAny + \"|\\\\x5B(?:[^\\\\x5C\\\\x5D\" + regexExcls + \"]\" + \"|\\\\x5C\" + regexAny + \")*(?:\\\\x5D|$))+\" + \"/\";\n            fallthroughStylePatterns.push([\"lang-regex\", RegExp(\"^\" + REGEXP_PRECEDER_PATTERN + \"(\" + REGEX_LITERAL + \")\")]);\n        }\n        var types = options[\"types\"];\n        if (types) {\n            fallthroughStylePatterns.push([PR_TYPE, types]);\n        }\n        var keywords = (\"\" + options[\"keywords\"]).replace(/^ | $/g, \"\");\n        if (keywords.length) {\n            fallthroughStylePatterns.push([PR_KEYWORD, new RegExp(\"^(?:\" + keywords.replace(/[\\s,]+/g, \"|\") + \")\\\\b\"), null]);\n        }\n        shortcutStylePatterns.push([PR_PLAIN, /^\\s+/, null, \" \\r\\n\t\u00a0\"]);\n        var punctuation = \"^.[^\\\\s\\\\w.$@'\\\"`/\\\\\\\\]*\";\n        if (options[\"regexLiterals\"]) {\n            punctuation += \"(?!s*/)\";\n        }\n        fallthroughStylePatterns.push([PR_LITERAL, /^@[a-z_$][a-z_$@0-9]*/i, null], [PR_TYPE, /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null], [PR_PLAIN, /^[a-z_$][a-z_$@0-9]*/i, null], [PR_LITERAL, new RegExp(\"^(?:\" + \"0x[a-f0-9]+\" + \"|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)\" + \"(?:e[+\\\\-]?\\\\d+)?\" + \")\" + \"[a-z]*\", \"i\"), null, \"0123456789\"], [PR_PLAIN, /^\\\\[\\s\\S]?/, null], [PR_PUNCTUATION, new RegExp(punctuation), null]);\n        return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n    }\n    var decorateSource = sourceDecorator({\n        keywords: ALL_KEYWORDS,\n        hashComments: true,\n        cStyleComments: true,\n        multiLineStrings: true,\n        regexLiterals: true\n    });\n\n    function numberLines(node, startLineNum, isPreformatted) {\n        var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n        var lineBreak = /\\r\\n?|\\n/;\n        var document = node.ownerDocument;\n        var li = document.createElement(\"li\");\n        while (node.firstChild) {\n            li.appendChild(node.firstChild);\n        }\n        var listItems = [li];\n\n        function walk(node) {\n            var type = node.nodeType;\n            if (type == 1 && !nocode.test(node.className)) {\n                if (\"br\" === node.nodeName.toLowerCase()) {\n                    breakAfter(node);\n                    if (node.parentNode) {\n                        node.parentNode.removeChild(node);\n                    }\n                } else {\n                    for (var child = node.firstChild; child; child = child.nextSibling) {\n                        walk(child);\n                    }\n                }\n            } else if ((type == 3 || type == 4) && isPreformatted) {\n                var text = node.nodeValue;\n                var match = text.match(lineBreak);\n                if (match) {\n                    var firstLine = text.substring(0, match.index);\n                    node.nodeValue = firstLine;\n                    var tail = text.substring(match.index + match[0].length);\n                    if (tail) {\n                        var parent = node.parentNode;\n                        parent.insertBefore(document.createTextNode(tail), node.nextSibling);\n                    }\n                    breakAfter(node);\n                    if (!firstLine) {\n                        node.parentNode.removeChild(node);\n                    }\n                }\n            }\n        }\n\n        function breakAfter(lineEndNode) {\n            while (!lineEndNode.nextSibling) {\n                lineEndNode = lineEndNode.parentNode;\n                if (!lineEndNode) {\n                    return;\n                }\n            }\n\n            function breakLeftOf(limit, copy) {\n                var rightSide = copy ? limit.cloneNode(false) : limit;\n                var parent = limit.parentNode;\n                if (parent) {\n                    var parentClone = breakLeftOf(parent, 1);\n                    var next = limit.nextSibling;\n                    parentClone.appendChild(rightSide);\n                    for (var sibling = next; sibling; sibling = next) {\n                        next = sibling.nextSibling;\n                        parentClone.appendChild(sibling);\n                    }\n                }\n                return rightSide;\n            }\n            var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n            for (var parent;\n                (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n                copiedListItem = parent;\n            }\n            listItems.push(copiedListItem);\n        }\n        for (var i = 0; i < listItems.length; ++i) {\n            walk(listItems[i]);\n        }\n        if (startLineNum === (startLineNum | 0)) {\n            listItems[0].setAttribute(\"value\", startLineNum);\n        }\n        var ol = document.createElement(\"ol\");\n        ol.className = \"linenums\";\n        var offset = Math.max(0, startLineNum - 1 | 0) || 0;\n        for (var i = 0, n = listItems.length; i < n; ++i) {\n            li = listItems[i];\n            li.className = \"L\" + (i + offset) % 10;\n            if (!li.firstChild) {\n                li.appendChild(document.createTextNode(\"\u00a0\"));\n            }\n            ol.appendChild(li);\n        }\n        node.appendChild(ol);\n    }\n\n    function recombineTagsAndDecorations(job) {\n        var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n        isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n        var newlineRe = /\\n/g;\n        var source = job.sourceCode;\n        var sourceLength = source.length;\n        var sourceIndex = 0;\n        var spans = job.spans;\n        var nSpans = spans.length;\n        var spanIndex = 0;\n        var decorations = job.decorations;\n        var nDecorations = decorations.length;\n        var decorationIndex = 0;\n        decorations[nDecorations] = sourceLength;\n        var decPos, i;\n        for (i = decPos = 0; i < nDecorations;) {\n            if (decorations[i] !== decorations[i + 2]) {\n                decorations[decPos++] = decorations[i++];\n                decorations[decPos++] = decorations[i++];\n            } else {\n                i += 2;\n            }\n        }\n        nDecorations = decPos;\n        for (i = decPos = 0; i < nDecorations;) {\n            var startPos = decorations[i];\n            var startDec = decorations[i + 1];\n            var end = i + 2;\n            while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n                end += 2;\n            }\n            decorations[decPos++] = startPos;\n            decorations[decPos++] = startDec;\n            i = end;\n        }\n        nDecorations = decorations.length = decPos;\n        var sourceNode = job.sourceNode;\n        var oldDisplay = \"\";\n        if (sourceNode) {\n            oldDisplay = sourceNode.style.display;\n            sourceNode.style.display = \"none\";\n        }\n        try {\n            var decoration = null;\n            while (spanIndex < nSpans) {\n                var spanStart = spans[spanIndex];\n                var spanEnd = spans[spanIndex + 2] || sourceLength;\n                var decEnd = decorations[decorationIndex + 2] || sourceLength;\n                var end = Math.min(spanEnd, decEnd);\n                var textNode = spans[spanIndex + 1];\n                var styledText;\n                if (textNode.nodeType !== 1 && (styledText = source.substring(sourceIndex, end))) {\n                    if (isIE8OrEarlier) {\n                        styledText = styledText.replace(newlineRe, \"\\r\");\n                    }\n                    textNode.nodeValue = styledText;\n                    var document = textNode.ownerDocument;\n                    var span = document.createElement(\"span\");\n                    span.className = decorations[decorationIndex + 1];\n                    var parentNode = textNode.parentNode;\n                    parentNode.replaceChild(span, textNode);\n                    span.appendChild(textNode);\n                    if (sourceIndex < spanEnd) {\n                        spans[spanIndex + 1] = textNode = document.createTextNode(source.substring(end, spanEnd));\n                        parentNode.insertBefore(textNode, span.nextSibling);\n                    }\n                }\n                sourceIndex = end;\n                if (sourceIndex >= spanEnd) {\n                    spanIndex += 2;\n                }\n                if (sourceIndex >= decEnd) {\n                    decorationIndex += 2;\n                }\n            }\n        } finally {\n            if (sourceNode) {\n                sourceNode.style.display = oldDisplay;\n            }\n        }\n    }\n    var langHandlerRegistry = {};\n\n    function registerLangHandler(handler, fileExtensions) {\n        for (var i = fileExtensions.length; --i >= 0;) {\n            var ext = fileExtensions[i];\n            if (!langHandlerRegistry.hasOwnProperty(ext)) {\n                langHandlerRegistry[ext] = handler;\n            } else if (win[\"console\"]) {\n                console[\"warn\"](\"cannot override language handler %s\", ext);\n            }\n        }\n    }\n\n    function langHandlerForExtension(extension, source) {\n        if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n            extension = /^\\s*</.test(source) ? \"default-markup\" : \"default-code\";\n        }\n        return langHandlerRegistry[extension];\n    }\n    registerLangHandler(decorateSource, [\"default-code\"]);\n    registerLangHandler(createSimpleLexer([], [\n        [PR_PLAIN, /^[^<?]+/],\n        [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n        [PR_COMMENT, /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n        [\"lang-\", /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n        [\"lang-\", /^<%([\\s\\S]+?)(?:%>|$)/],\n        [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n        [\"lang-\", /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n        [\"lang-js\", /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n        [\"lang-css\", /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n        [\"lang-in.tag\", /^(<\\/?[a-z][^<>]*>)/i]\n    ]), [\"default-markup\", \"htm\", \"html\", \"mxml\", \"xhtml\", \"xml\", \"xsl\"]);\n    registerLangHandler(createSimpleLexer([\n        [PR_PLAIN, /^[\\s]+/, null, \" \t\\r\\n\"],\n        [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, \"\\\"'\"]\n    ], [\n        [PR_TAG, /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n        [PR_ATTRIB_NAME, /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n        [\"lang-uq.val\", /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n        [PR_PUNCTUATION, /^[=<>\\/]+/],\n        [\"lang-js\", /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n        [\"lang-js\", /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n        [\"lang-js\", /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n        [\"lang-css\", /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n        [\"lang-css\", /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n        [\"lang-css\", /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n    ]), [\"in.tag\"]);\n    registerLangHandler(createSimpleLexer([], [\n        [PR_ATTRIB_VALUE, /^[\\s\\S]+/]\n    ]), [\"uq.val\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: CPP_KEYWORDS,\n        hashComments: true,\n        cStyleComments: true,\n        types: C_TYPES\n    }), [\"c\", \"cc\", \"cpp\", \"cxx\", \"cyc\", \"m\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: \"null,true,false\"\n    }), [\"json\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: CSHARP_KEYWORDS,\n        hashComments: true,\n        cStyleComments: true,\n        verbatimStrings: true,\n        types: C_TYPES\n    }), [\"cs\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: JAVA_KEYWORDS,\n        cStyleComments: true\n    }), [\"java\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: SH_KEYWORDS,\n        hashComments: true,\n        multiLineStrings: true\n    }), [\"bash\", \"bsh\", \"csh\", \"sh\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: PYTHON_KEYWORDS,\n        hashComments: true,\n        multiLineStrings: true,\n        tripleQuotedStrings: true\n    }), [\"cv\", \"py\", \"python\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: PERL_KEYWORDS,\n        hashComments: true,\n        multiLineStrings: true,\n        regexLiterals: 2\n    }), [\"perl\", \"pl\", \"pm\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: RUBY_KEYWORDS,\n        hashComments: true,\n        multiLineStrings: true,\n        regexLiterals: true\n    }), [\"rb\", \"ruby\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: JSCRIPT_KEYWORDS,\n        cStyleComments: true,\n        regexLiterals: true\n    }), [\"javascript\", \"js\", \"ts\", \"typescript\"]);\n    registerLangHandler(sourceDecorator({\n        keywords: COFFEE_KEYWORDS,\n        hashComments: 3,\n        cStyleComments: true,\n        multilineStrings: true,\n        tripleQuotedStrings: true,\n        regexLiterals: true\n    }), [\"coffee\"]);\n    registerLangHandler(createSimpleLexer([], [\n        [PR_STRING, /^[\\s\\S]+/]\n    ]), [\"regex\"]);\n\n    function applyDecorator(job) {\n        var opt_langExtension = job.langExtension;\n        try {\n            var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n            var source = sourceAndSpans.sourceCode;\n            job.sourceCode = source;\n            job.spans = sourceAndSpans.spans;\n            job.basePos = 0;\n            langHandlerForExtension(opt_langExtension, source)(job);\n            recombineTagsAndDecorations(job);\n        } catch (e) {\n            if (win[\"console\"]) {\n                console[\"log\"](e && e[\"stack\"] || e);\n            }\n        }\n    }\n\n    function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n        var nl = opt_numberLines || false;\n        var langExtension = opt_langExtension || null;\n        var container = document.createElement(\"div\");\n        container.innerHTML = \"<pre>\" + sourceCodeHtml + \"</pre>\";\n        container = container.firstChild;\n        if (nl) {\n            numberLines(container, nl, true);\n        }\n        var job = {\n            langExtension: langExtension,\n            numberLines: nl,\n            sourceNode: container,\n            pre: 1,\n            sourceCode: null,\n            basePos: null,\n            spans: null,\n            decorations: null\n        };\n        applyDecorator(job);\n        return container.innerHTML;\n    }\n\n    function $prettyPrint(opt_whenDone, opt_root) {\n        var root = opt_root || document.body;\n        var doc = root.ownerDocument || document;\n\n        function byTagName(tn) {\n            return root.getElementsByTagName(tn);\n        }\n        var codeSegments = [byTagName(\"pre\"), byTagName(\"code\"), byTagName(\"xmp\")];\n        var elements = [];\n        for (var i = 0; i < codeSegments.length; ++i) {\n            for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n                elements.push(codeSegments[i][j]);\n            }\n        }\n        codeSegments = null;\n        var clock = Date;\n        if (!clock[\"now\"]) {\n            clock = {\n                now: function() {\n                    return +new Date();\n                }\n            };\n        }\n        var k = 0;\n        var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n        var prettyPrintRe = /\\bprettyprint\\b/;\n        var prettyPrintedRe = /\\bprettyprinted\\b/;\n        var preformattedTagNameRe = /pre|xmp/i;\n        var codeRe = /^code$/i;\n        var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n        var EMPTY = {};\n\n        function doWork() {\n            var endTime = win[\"PR_SHOULD_USE_CONTINUATION\"] ? clock[\"now\"]() + 250 : Infinity;\n            for (; k < elements.length && clock[\"now\"]() < endTime; k++) {\n                var cs = elements[k];\n                var attrs = EMPTY; {\n                    for (var preceder = cs; preceder = preceder.previousSibling;) {\n                        var nt = preceder.nodeType;\n                        var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n                        if (value ? !/^\\??prettify\\b/.test(value) : nt !== 3 || /\\S/.test(preceder.nodeValue)) {\n                            break;\n                        }\n                        if (value) {\n                            attrs = {};\n                            value.replace(/\\b(\\w+)=([\\w:.%+-]+)/g, function(_, name, value) {\n                                attrs[name] = value;\n                            });\n                            break;\n                        }\n                    }\n                }\n                var className = cs.className;\n                if ((attrs !== EMPTY || prettyPrintRe.test(className)) && !prettyPrintedRe.test(className)) {\n                    var nested = false;\n                    for (var p = cs.parentNode; p; p = p.parentNode) {\n                        var tn = p.tagName;\n                        if (preCodeXmpRe.test(tn) && p.className && prettyPrintRe.test(p.className)) {\n                            nested = true;\n                            break;\n                        }\n                    }\n                    if (!nested) {\n                        cs.className += \" prettyprinted\";\n                        var langExtension = attrs[\"lang\"];\n                        if (!langExtension) {\n                            langExtension = className.match(langExtensionRe);\n                            var wrapper;\n                            if (!langExtension && (wrapper = childContentWrapper(cs)) && codeRe.test(wrapper.tagName)) {\n                                langExtension = wrapper.className.match(langExtensionRe);\n                            }\n                            if (langExtension) {\n                                langExtension = langExtension[1];\n                            }\n                        }\n                        var preformatted;\n                        if (preformattedTagNameRe.test(cs.tagName)) {\n                            preformatted = 1;\n                        } else {\n                            var currentStyle = cs[\"currentStyle\"];\n                            var defaultView = doc.defaultView;\n                            var whitespace = currentStyle ? currentStyle[\"whiteSpace\"] : defaultView && defaultView.getComputedStyle ? defaultView.getComputedStyle(cs, null).getPropertyValue(\"white-space\") : 0;\n                            preformatted = whitespace && \"pre\" === whitespace.substring(0, 3);\n                        }\n                        var lineNums = attrs[\"linenums\"];\n                        if (!(lineNums = lineNums === \"true\" || +lineNums)) {\n                            lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n                            lineNums = lineNums ? lineNums[1] && lineNums[1].length ? +lineNums[1] : true : false;\n                        }\n                        if (lineNums) {\n                            numberLines(cs, lineNums, preformatted);\n                        }\n                        var prettyPrintingJob = {\n                            langExtension: langExtension,\n                            sourceNode: cs,\n                            numberLines: lineNums,\n                            pre: preformatted,\n                            sourceCode: null,\n                            basePos: null,\n                            spans: null,\n                            decorations: null\n                        };\n                        applyDecorator(prettyPrintingJob);\n                    }\n                }\n            }\n            if (k < elements.length) {\n                win.setTimeout(doWork, 250);\n            } else if (\"function\" === typeof opt_whenDone) {\n                opt_whenDone();\n            }\n        }\n        doWork();\n    }\n    var PR = win[\"PR\"] = {\n        createSimpleLexer: createSimpleLexer,\n        registerLangHandler: registerLangHandler,\n        sourceDecorator: sourceDecorator,\n        PR_ATTRIB_NAME: PR_ATTRIB_NAME,\n        PR_ATTRIB_VALUE: PR_ATTRIB_VALUE,\n        PR_COMMENT: PR_COMMENT,\n        PR_DECLARATION: PR_DECLARATION,\n        PR_KEYWORD: PR_KEYWORD,\n        PR_LITERAL: PR_LITERAL,\n        PR_NOCODE: PR_NOCODE,\n        PR_PLAIN: PR_PLAIN,\n        PR_PUNCTUATION: PR_PUNCTUATION,\n        PR_SOURCE: PR_SOURCE,\n        PR_STRING: PR_STRING,\n        PR_TAG: PR_TAG,\n        PR_TYPE: PR_TYPE,\n        prettyPrintOne: IN_GLOBAL_SCOPE ? win[\"prettyPrintOne\"] = $prettyPrintOne : prettyPrintOne = $prettyPrintOne,\n        prettyPrint: IN_GLOBAL_SCOPE ? win[\"prettyPrint\"] = $prettyPrint : prettyPrint = $prettyPrint\n    };\n    var define = win[\"define\"];\n    if (typeof define === \"function\" && define[\"amd\"]) {\n        define(\"google-code-prettify\", [], function() {\n            return PR;\n        });\n    }\n})();\n\n/* https://github.com/google/code-prettify/blob/master/src/lang-css.js */\n/**\n * @license\n * Copyright (C) 2009 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nPR[\"registerLangHandler\"](PR[\"createSimpleLexer\"]([\n    [PR[\"PR_PLAIN\"], /^[ \\t\\r\\n\\f]+/, null, \" \t\\r\\n\\f\"]\n], [\n    [PR[\"PR_STRING\"], /^\\\"(?:[^\\n\\r\\f\\\\\\\"]|\\\\(?:\\r\\n?|\\n|\\f)|\\\\[\\s\\S])*\\\"/, null],\n    [PR[\"PR_STRING\"], /^\\'(?:[^\\n\\r\\f\\\\\\']|\\\\(?:\\r\\n?|\\n|\\f)|\\\\[\\s\\S])*\\'/, null],\n    [\"lang-css-str\", /^url\\(([^\\)\\\"\\']+)\\)/i],\n    [PR[\"PR_KEYWORD\"], /^(?:url|rgb|\\!important|@import|@page|@media|@charset|inherit)(?=[^\\-\\w]|$)/i, null],\n    [\"lang-css-kw\", /^(-?(?:[_a-z]|(?:\\\\[0-9a-f]+ ?))(?:[_a-z0-9\\-]|\\\\(?:\\\\[0-9a-f]+ ?))*)\\s*:/i],\n    [PR[\"PR_COMMENT\"], /^\\/\\*[^*]*\\*+(?:[^\\/*][^*]*\\*+)*\\//],\n    [PR[\"PR_COMMENT\"], /^(?:<!--|-->)/],\n    [PR[\"PR_LITERAL\"], /^(?:\\d+|\\d*\\.\\d+)(?:%|[a-z]+)?/i],\n    [PR[\"PR_LITERAL\"], /^#(?:[0-9a-f]{3}){1,2}\\b/i],\n    [PR[\"PR_PLAIN\"], /^-?(?:[_a-z]|(?:\\\\[\\da-f]+ ?))(?:[_a-z\\d\\-]|\\\\(?:\\\\[\\da-f]+ ?))*/i],\n    [PR[\"PR_PUNCTUATION\"], /^[^\\s\\w\\'\\\"]+/]\n]), [\"css\"]);\n\nPR[\"registerLangHandler\"](PR[\"createSimpleLexer\"]([], [\n    [PR[\"PR_KEYWORD\"], /^-?(?:[_a-z]|(?:\\\\[\\da-f]+ ?))(?:[_a-z\\d\\-]|\\\\(?:\\\\[\\da-f]+ ?))*/i]\n]), [\"css-kw\"]);\n\nPR[\"registerLangHandler\"](PR[\"createSimpleLexer\"]([], [\n    [PR[\"PR_STRING\"], /^[^\\)\\\"\\']+/]\n]), [\"css-str\"]);"}}}