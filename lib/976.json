{"parse":{"title":"\u6a21\u5757:\u6c99\u76d2","pageid":1070,"wikitext":{"*":"\nlocal z = {\n\terror_categories = {};\t\t-- for categorizing citations that contain errors\n\terror_ids = {};\n\tmessage_tail = {};\n\tmaintenance_cats = {};\t\t-- for categorizing citations that aren't erroneous per se, but could use a little work\n\tproperties_cats = {};\t\t-- for categorizing citations based on certain properties, language of source for instance\n}\n\n--[[--------------------------< F O R W A R D   D E C L A R A T I O N S >--------------------------------------\n]]\nlocal dates, year_date_check\t-- functions in Module:Citation/CS1/Date_validation\n\nlocal cfg = {};\t\t\t\t\t-- table of configuration tables that are defined in Module:Citation/CS1/Configuration\nlocal whitelist = {};\t\t\t-- table of tables listing valid template parameter names; defined in Module:Citation/CS1/Whitelist\n\n--[[--------------------------< I S _ S E T >------------------------------------------------------------------\n\nReturns true if argument is set; false otherwise. Argument is 'set' when it exists (not nil) or when it is not an empty string.\nThis function is global because it is called from both this module and from Date validation\n\n]]\nfunction is_set( var )\n\treturn not (var == nil or var == '');\nend\n\n--[[--------------------------< F I R S T _ S E T >------------------------------------------------------------\n\nLocates and returns the first set value in a table of values where the order established in the table,\nleft-to-right (or top-to-bottom), is the order in which the values are evaluated.  Returns nil if none are set.\n\nThis version replaces the original 'for _, val in pairs do' and a similar version that used ipairs.  With the pairs\nversion the order of evaluation could not be guaranteed.  With the ipairs version, a nil value would terminate\nthe for-loop before it reached the actual end of the list.\n\n]]\n\nlocal function first_set (list, count)\n\tlocal i = 1;\n\twhile i <= count do\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- loop through all items in list\n\t\tif is_set( list[i] ) then\n\t\t\treturn list[i];\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- return the first set list member\n\t\tend\n\t\ti = i + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- point to next\n\tend\nend\n\n--[[--------------------------< I N _ A R R A Y >--------------------------------------------------------------\n\nWhether needle is in haystack\n\n]]\n\nlocal function in_array( needle, haystack )\n\tif needle == nil then\n\t\treturn false;\n\tend\n\tfor n,v in ipairs( haystack ) do\n\t\tif v == needle then\n\t\t\treturn n;\n\t\tend\n\tend\n\treturn false;\nend\n\n--[[--------------------------< S U B S T I T U T E >----------------------------------------------------------\n\nPopulates numbered arguments in a message string using an argument table.\n\n]]\n\nlocal function substitute( msg, args )\n\treturn args and mw.message.newRawMessage( msg, args ):plain() or msg;\nend\n\n--[[--------------------------< E R R O R _ C O M M E N T >----------------------------------------------------\n\nWraps error messages with css markup according to the state of hidden.\n\n]]\nlocal function error_comment( content, hidden )\n\treturn substitute( hidden and cfg.presentation['hidden-error'] or cfg.presentation['visible-error'], content );\nend\n\n--[[--------------------------< S E T _ E R R O R >--------------------------------------------------------------\n\nSets an error condition and returns the appropriate error message.  The actual placement of the error message in the output is\nthe responsibility of the calling function.\n\n]]\nlocal function set_error( error_id, arguments, raw, prefix, suffix )\n\tlocal error_state = cfg.error_conditions[ error_id ];\n\t\n\tprefix = prefix or \"\";\n\tsuffix = suffix or \"\";\n\t\n\tif error_state == nil then\n\t\terror( cfg.messages['undefined_error'] );\n\telseif is_set( error_state.category ) then\n\t\ttable.insert( z.error_categories, error_state.category );\n\tend\n\t\n\tlocal message = substitute( error_state.message, arguments );\n\t\n\tmessage = message .. \" ([[\" .. cfg.messages['help page link'] .. \n\t\t\"#\" .. error_state.anchor .. \"|\" ..\n\t\tcfg.messages['help page label'] .. \"]])\";\n\t\n\tz.error_ids[ error_id ] = true;\n\tif in_array( error_id, { 'bare_url_missing_title', 'trans_missing_title' } )\n\t\t\tand z.error_ids['citation_missing_title'] then\n\t\treturn '', false;\n\tend\n\t\n\tmessage = table.concat({ prefix, message, suffix });\n\t\n\tif raw == true then\n\t\treturn message, error_state.hidden;\n\tend\t\t\n\t\t\n\treturn error_comment( message, error_state.hidden );\nend\n\n--[[--------------------------< A D D _ M A I N T _ C A T >------------------------------------------------------\n\nAdds a category to z.maintenance_cats using names from the configuration file with additional text if any.\nTo prevent duplication, the added_maint_cats table lists the categories by key that have been added to z.maintenance_cats.\n\n]]\n\nlocal added_maint_cats = {}\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- list of maintenance categories that have been added to z.maintenance_cats\nlocal function add_maint_cat (key, arguments)\n\tif not added_maint_cats [key] then\n\t\tadded_maint_cats [key] = true;\t\t\t\t\t\t\t\t\t\t\t-- note that we've added this category\n\t\ttable.insert( z.maintenance_cats, substitute (cfg.maint_cats [key], arguments));\t-- make name then add to table\n\tend\nend\n\n--[[--------------------------< A D D _ P R O P _ C A T >--------------------------------------------------------\n\nAdds a category to z.properties_cats using names from the configuration file with additional text if any.\n\n]]\n\nlocal added_prop_cats = {}\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- list of property categories that have been added to z.properties_cats\nlocal function add_prop_cat (key, arguments)\n\tif not added_prop_cats [key] then\n\t\tadded_prop_cats [key] = true;\t\t\t\t\t\t\t\t\t\t\t-- note that we've added this category\n\t\ttable.insert( z.properties_cats, substitute (cfg.prop_cats [key], arguments));\t\t-- make name then add to table\n\tend\nend\n\n--[[--------------------------< A D D _ V A N C _ E R R O R >----------------------------------------------------\n\nAdds a single Vancouver system error message to the template's output regardless of how many error actually exist.\nTo prevent duplication, added_vanc_errs is nil until an error message is emitted.\n\n]]\n\nlocal added_vanc_errs;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- flag so we only emit one Vancouver error / category\nlocal function add_vanc_error ()\n\tif not added_vanc_errs then\n\t\tadded_vanc_errs = true;\t\t\t\t\t\t\t\t\t\t\t\t\t-- note that we've added this category\n\t\ttable.insert( z.message_tail, { set_error( 'vancouver', {}, true ) } );\n\tend\nend\n\n\n--[[--------------------------< I S _ S C H E M E >------------------------------------------------------------\n\ndoes this thing that purports to be a uri scheme seem to be a valid scheme?  The scheme is checked to see if it\nis in agreement with http://tools.ietf.org/html/std66#section-3.1 which says:\n\tScheme names consist of a sequence of characters beginning with a\n   letter and followed by any combination of letters, digits, plus\n   (\"+\"), period (\".\"), or hyphen (\"-\").\n\nreturns true if it does, else false\n\n]]\n\nlocal function is_scheme (scheme)\n\treturn scheme and scheme:match ('^%a[%a%d%+%.%-]*:');\t\t\t\t\t\t-- true if scheme is set and matches the pattern\nend\n\n\n--[=[-------------------------< I S _ D O M A I N _ N A M E >--------------------------------------------------\n\nDoes this thing that purports to be a domain name seem to be a valid domain name?\n\nSyntax defined here: http://tools.ietf.org/html/rfc1034#section-3.5\nBNF defined here: https://tools.ietf.org/html/rfc4234\nSingle character names are generally reserved; see https://tools.ietf.org/html/draft-ietf-dnsind-iana-dns-01#page-15;\n\tsee also [[Single-letter second-level domain]]\nlist of tlds: https://www.iana.org/domains/root/db\n\nrfc952 (modified by rfc 1123) requires the first and last character of a hostname to be a letter or a digit.  Between\nthe first and last characters the name may use letters, digits, and the hyphen.\n\nAlso allowed are IPv4 addresses. IPv6 not supported\n\ndomain is expected to be stripped of any path so that the last character in the last character of the tld.  tld\nis two or more alpha characters.  Any preceding '//' (from splitting a url with a scheme) will be stripped\nhere.  Perhaps not necessary but retained incase it is necessary for IPv4 dot decimal.\n\nThere are several tests:\n\tthe first character of the whole domain name including subdomains must be a letter or a digit\n\tsingle-letter/digit second-level domains in the .org TLD\n\tq, x, and z SL domains in the .com TLD\n\ti and q SL domains in the .net TLD\n\tsingle-letter SL domains in the ccTLDs (where the ccTLD is two letters)\n\ttwo-character SL domains in gTLDs (where the gTLD is two or more letters)\n\tthree-plus-character SL domains in gTLDs (where the gTLD is two or more letters)\n\tIPv4 dot-decimal address format; TLD not allowed\n\nreturns true if domain appears to be a proper name and tld or IPv4 address, else false\n\n]=]\n\nlocal function is_domain_name (domain)\n\tif not domain then\n\t\treturn false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if not set, abandon\n\tend\n\t\n\tdomain = domain:gsub ('^//', '');\t\t\t\t\t\t\t\t\t\t\t-- strip '//' from domain name if present; done here so we only have to do it once\n\t\n\tif not domain:match ('^[%a%d]') then\t\t\t\t\t\t\t\t\t\t-- first character must be letter or digit\n\t\treturn false;\n\tend\n\t\n\tif domain:match ('%f[%a%d][%a%d]%.org$') then\t\t\t\t\t\t\t\t-- one character .org hostname\n\t\treturn true;\n\telseif domain:match ('%f[%a][qxz]%.com$') then\t\t\t\t\t\t\t\t-- assigned one character .com hostname (x.com times out 2015-12-10)\n\t\treturn true;\n\telseif domain:match ('%f[%a][iq]%.net$') then\t\t\t\t\t\t\t\t-- assigned one character .net hostname (q.net registered but not active 2015-12-10)\n\t\treturn true;\n\telseif domain:match ('%f[%a%d][%a%d]%.%a%a$') then\t\t\t\t\t\t\t-- one character hostname and cctld (2 chars)\n\t\treturn true;\n\telseif domain:match ('%f[%a%d][%a%d][%a%d]%.%a%a+$') then\t\t\t\t\t-- two character hostname and tld\n\t\treturn true;\n\telseif domain:match ('%f[%a%d][%a%d][%a%d%-]+[%a%d]%.%a%a+$') then\t\t\t-- three or more character hostname.hostname or hostname.tld\n\t\treturn true;\n\telseif domain:match ('^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?') then\t\t-- IPv4 address\n\t\treturn true;\n\telse\n\t\treturn false;\n\tend\nend\n\n\n--[[--------------------------< I S _ U R L >------------------------------------------------------------------\n\nreturns true if the scheme and domain parts of a url appear to be a valid url; else false.\n\nThis function is the last step in the validation process.  This function is separate because there are cases that\nare not covered by split_url(), for example is_parameter_ext_wikilink() which is looking for bracketted external\nwikilinks.\n\n]]\n\nlocal function is_url (scheme, domain)\n\tif is_set (scheme) then\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if scheme is set check it and domain\n\t\treturn is_scheme (scheme) and is_domain_name (domain);\n\telse\n\t\treturn is_domain_name (domain);\t\t\t\t\t\t\t\t\t\t\t-- scheme not set when url is protocol relative\n\tend\nend\n\n\n--[[--------------------------< S P L I T _ U R L >------------------------------------------------------------\n\nSplit a url into a scheme, authority indicator, and domain.\nIf protocol relative url, return nil scheme and domain else return nil for both scheme and domain.\n\nWhen not protocol relative, get scheme, authority indicator, and domain.  If there is an authority indicator (one\nor more '/' characters following the scheme's colon), make sure that there are only 2.\n\n]]\n\nlocal function split_url (url_str)\n\tlocal scheme, authority, domain;\n\t\n\turl_str = url_str:gsub ('([%a%d])%.?[/%?#].*$', '%1');\t\t\t\t\t\t-- strip FQDN terminator and path(/), query(?), fragment (#) (the capture prevents false replacement of '//')\n\n\tif url_str:match ('^//%S*') then\t\t\t\t\t\t\t\t\t\t\t-- if there is what appears to be a protocol relative url\n\t\tdomain = url_str:match ('^//(%S*)')\n\telseif url_str:match ('%S-:/*%S+') then\t\t\t\t\t\t\t\t\t\t-- if there is what appears to be a scheme, optional authority indicator, and domain name\n\t\tscheme, authority, domain = url_str:match ('(%S-:)(/*)(%S+)');\t\t\t-- extract the scheme, authority indicator, and domain portions\n\t\tauthority = authority:gsub ('//', '', 1);\t\t\t\t\t\t\t\t-- replace place 1 pair of '/' with nothing;\n\t\tif is_set(authority) then\t\t\t\t\t\t\t\t\t\t\t\t-- if anything left (1 or 3+ '/' where authority should be) then\n\t\t\treturn scheme;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- return scheme only making domain nil which will cause an error message\n\t\tend\n\t\tdomain = domain:gsub ('(%a):%d+', '%1');\t\t\t\t\t\t\t\t-- strip port number if present\n\tend\n\t\n\treturn scheme, domain;\nend\n\n\n--[[--------------------------< L I N K _ P A R A M _ O K >---------------------------------------------------\n\nchecks the content of |title-link=, |series-link=, |author-link= etc for properly formatted content: no wikilinks, no urls\n\nLink parameters are to hold the title of a wikipedia article so none of the WP:TITLESPECIALCHARACTERS are allowed:\n\t# < > [ ] | { } _\nexcept the underscore which is used as a space in wiki urls and # which is used for section links\n\nreturns false when the value contains any of these characters.\n\nWhen there are no illegal characters, this function returns TRUE if value DOES NOT appear to be a valid url (the\n|<param>-link= parameter is ok); else false when value appears to be a valid url (the |<param>-link= parameter is NOT ok).\n\n]]\n\nlocal function link_param_ok (value)\n\tlocal scheme, domain;\n\tif value:find ('[<>%[%]|{}]') then\t\t\t\t\t\t\t\t\t\t\t-- if any prohibited characters\n\t\treturn false;\n\tend\n\n\tscheme, domain = split_url (value);\t\t\t\t\t\t\t\t\t\t\t-- get scheme or nil and domain or nil from url; \n\treturn not is_url (scheme, domain);\t\t\t\t\t\t\t\t\t\t\t-- return true if value DOES NOT appear to be a valid url\nend\n\n\n--[[--------------------------< C H E C K _ U R L >------------------------------------------------------------\n\nDetermines whether a URL string appears to be valid.\n\nFirst we test for space characters.  If any are found, return false.  Then split the url into scheme and domain\nportions, or for protocol relative (//example.com) urls, just the domain.  Use is_url() to validate the two\nportions of the url.  If both are valid, or for protocol relative if domain is valid, return true, else false.\n\n]]\n\nlocal function check_url( url_str )\n\tif nil == url_str:match (\"^%S+$\") then\t\t\t\t\t\t\t\t\t\t-- if there are any spaces in |url=value it can't be a proper url\n\t\treturn false;\n\tend\n\tlocal scheme, domain;\n\n\tscheme, domain = split_url (url_str);\t\t\t\t\t\t\t\t\t\t-- get scheme or nil and domain or nil from url; \n\treturn is_url (scheme, domain);\t\t\t\t\t\t\t\t\t\t\t\t-- return true if value appears to be a valid url\nend\n\n\n--[=[-------------------------< I S _ P A R A M E T E R _ E X T _ W I K I L I N K >----------------------------\n\nReturn true if a parameter value has a string that begins and ends with square brackets [ and ] and the first\nnon-space characters following the opening bracket appear to be a url.  The test will also find external wikilinks\nthat use protocol relative urls. Also finds bare urls.\n\nThe frontier pattern prevents a match on interwiki links which are similar to scheme:path urls.  The tests that\nfind bracketed urls are required because the parameters that call this test (currently |title=, |chapter=, |work=,\nand |publisher=) may have wikilinks and there are articles or redirects like '//Hus' so, while uncommon, |title=[[//Hus]]\nis possible as might be [[en://Hus]].\n\n]=]\n\nlocal function is_parameter_ext_wikilink (value)\nlocal scheme, domain;\n\n\tvalue = value:gsub ('([^%s/])/[%a%d].*', '%1');\t\t\t\t\t\t\t\t-- strip path information (the capture prevents false replacement of '//')\n\n\tif value:match ('%f[%[]%[%a%S*:%S+.*%]') then\t\t\t\t\t\t\t\t-- if ext wikilink with scheme and domain: [xxxx://yyyyy.zzz]\n\t\tscheme, domain = value:match ('%f[%[]%[(%a%S*:)(%S+).*%]')\n\telseif value:match ('%f[%[]%[//%S*%.%S+.*%]') then\t\t\t\t\t\t\t-- if protocol relative ext wikilink: [//yyyyy.zzz]\n\t\tdomain = value:match ('%f[%[]%[//(%S*%.%S+).*%]');\n\telseif value:match ('%a%S*:%S+') then\t\t\t\t\t\t\t\t\t\t-- if bare url with scheme; may have leading or trailing plain text\n\t\tscheme, domain = value:match ('(%a%S*:)(%S+)');\n\telseif value:match ('//%S*%.%S+') then\t\t\t\t\t\t\t\t\t\t-- if protocol relative bare url: //yyyyy.zzz; may have leading or trailing plain text\n\t\tdomain = value:match ('//(%S*%.%S+)');\t\t\t\t\t\t\t\t\t-- what is left should be the domain\n\telse\n\t\treturn false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- didn't find anything that is obviously a url\n\tend\n\n\treturn is_url (scheme, domain);\t\t\t\t\t\t\t\t\t\t\t\t-- return true if value appears to be a valid url\nend\n\n\n--[[-------------------------< C H E C K _ F O R _ U R L >-----------------------------------------------------\n\nloop through a list of parameters and their values.  Look at the value and if it has an external link, emit an error message.\n\n]]\n\nlocal function check_for_url (parameter_list)\nlocal error_message = '';\n\tfor k, v in pairs (parameter_list) do\t\t\t\t\t\t\t\t\t\t-- for each parameter in the list\n\t\tif is_parameter_ext_wikilink (v) then\t\t\t\t\t\t\t\t\t-- look at the value; if there is a url add an error message\n\t\t\tif is_set(error_message) then\t\t\t\t\t\t\t\t\t\t-- once we've added the first portion of the error message ...\n\t\t\t\terror_message=error_message .. \", \";\t\t\t\t\t\t\t-- ... add a comma space separator\n\t\t\tend\n\t\t\terror_message=error_message .. \"&#124;\" .. k .. \"=\";\t\t\t\t-- add the failed parameter\n\t\tend\n\tend\n\tif is_set (error_message) then\t\t\t\t\t\t\t\t\t\t\t\t-- done looping, if there is an error message, display it\n\t\ttable.insert( z.message_tail, { set_error( 'param_has_ext_link', {error_message}, true ) } );\n\tend\nend\n\n\n--[[--------------------------< S A F E _ F O R _ I T A L I C S >----------------------------------------------\n\nProtects a string that will be wrapped in wiki italic markup '' ... ''\n\nNote: We cannot use <i> for italics, as the expected behavior for italics specified by ''...'' in the title is that\nthey will be inverted (i.e. unitalicized) in the resulting references.  In addition, <i> and '' tend to interact\npoorly under Mediawiki's HTML tidy.\n\n]]\n\nlocal function safe_for_italics( str )\n\tif not is_set(str) then\n\t\treturn str;\n\telse\n\t\tif str:sub(1,1) == \"'\" then str = \"<span></span>\" .. str; end\n\t\tif str:sub(-1,-1) == \"'\" then str = str .. \"<span></span>\"; end\n\t\t\n\t\t-- Remove newlines as they break italics.\n\t\treturn str:gsub( '\\n', ' ' );\n\tend\nend\n\n--[[--------------------------< S A F E _ F O R _ U R L >------------------------------------------------------\n\nEscape sequences for content that will be used for URL descriptions\n\n]]\n\nlocal function safe_for_url( str )\n\tif str:match( \"%[%[.-%]%]\" ) ~= nil then \n\t\ttable.insert( z.message_tail, { set_error( 'wikilink_in_url', {}, true ) } );\n\tend\n\t\n\treturn str:gsub( '[%[%]\\n]', {\t\n\t\t['['] = '&#91;',\n\t\t[']'] = '&#93;',\n\t\t['\\n'] = ' ' } );\nend\n\n--[[--------------------------< W R A P _ S T Y L E >----------------------------------------------------------\n\nApplies styling to various parameters.  Supplied string is wrapped using a message_list configuration taking one\nargument; protects italic styled parameters.  Additional text taken from citation_config.presentation - the reason\nthis function is similar to but separate from wrap_msg().\n\n]]\n\nlocal function wrap_style (key, str)\n\tif not is_set( str ) then\n\t\treturn \"\";\n\telseif in_array( key, { 'italic-title', 'trans-italic-title' } ) then\n\t\tstr = safe_for_italics( str );\n\tend\n\n\treturn substitute( cfg.presentation[key], {str} );\nend\n\n--[[--------------------------< E X T E R N A L _ L I N K >----------------------------------------------------\n\nFormat an external link with error checking\n\n]]\n\nlocal function external_link( URL, label, source )\n\tlocal error_str = \"\";\n\tif not is_set( label ) then\n\t\tlabel = URL;\n\t\tif is_set( source ) then\n\t\t\terror_str = set_error( 'bare_url_missing_title', { wrap_style ('parameter', source) }, false, \" \" );\n\t\telse\n\t\t\terror( cfg.messages[\"bare_url_no_origin\"] );\n\t\tend\t\t\t\n\tend\n\tif not check_url( URL ) then\n\t\terror_str = set_error( 'bad_url', {wrap_style ('parameter', source)}, false, \" \" ) .. error_str;\n\tend\n\treturn table.concat({ \"[\", URL, \" \", safe_for_url( label ), \"]\", error_str });\nend\n\n--[[--------------------------< E X T E R N A L _ L I N K _ I D >----------------------------------------------\n\nFormats a wiki style external link\n\n]]\n\nlocal function external_link_id(options)\n\tlocal url_string = options.id;\n\tif options.encode == true or options.encode == nil then\n\t\turl_string = mw.uri.encode( url_string );\n\tend\n\treturn mw.ustring.format( '[%s%s%s \\<span title\\=\\\"%s\\\"\\>%s%s%s\\<\\/span\\>]',\n\t\toptions.prefix, url_string, options.suffix or \"\",\n\t\toptions.link, options.label, options.separator or \"&nbsp;\",\n\t\tmw.text.nowiki(options.id)\n\t);\nend\n\n--[[--------------------------< D E P R E C A T E D _ P A R A M E T E R >--------------------------------------\n\nCategorize and emit an error message when the citation contains one or more deprecated parameters.  The function includes the\noffending parameter name to the error message.  Only one error message is emitted regardless of the number of deprecated\nparameters in the citation.\n\n]]\n\nlocal page_in_deprecated_cat;\t\t\t\t\t\t\t\t\t\t\t\t\t-- sticky flag so that the category is added only once\nlocal function deprecated_parameter(name)\n\tif not page_in_deprecated_cat then\n\t\tpage_in_deprecated_cat = true;\t\t\t\t\t\t\t\t\t\t\t-- note that we've added this category\n\t\ttable.insert( z.message_tail, { set_error( 'deprecated_params', {name}, true ) } );\t\t-- add error message\n\tend\nend\n\n--[[--------------------------< K E R N _ Q U O T E S >--------------------------------------------------------\n\nApply kerning to open the space between the quote mark provided by the Module and a leading or trailing quote mark contained in a |title= or |chapter= parameter's value.\nThis function will positive kern either single or double quotes:\n\t\"'Unkerned title with leading and trailing single quote marks'\"\n\t\" 'Kerned title with leading and trailing single quote marks' \" (in real life the kerning isn't as wide as this example)\nDouble single quotes (italic or bold wikimarkup) are not kerned.\n\nCall this function for chapter titles, for website titles, etc; not for book titles.\n\n]]\n\nlocal function kern_quotes (str)\n\tlocal cap='';\n\tlocal cap2='';\n\t\n\tcap, cap2 = str:match (\"^([\\\"\\'])([^\\'].+)\");\t\t\t\t\t\t\t\t-- match leading double or single quote but not double single quotes\n\tif is_set (cap) then\n\t\tstr = substitute (cfg.presentation['kern-left'], {cap, cap2});\n\tend\n\n\tcap, cap2 = str:match (\"^(.+[^\\'])([\\\"\\'])$\")\n\tif is_set (cap) then\n\t\tstr = substitute (cfg.presentation['kern-right'], {cap, cap2});\n\tend\n\treturn str;\nend\n\n--[[--------------------------< F O R M A T _ S C R I P T _ V A L U E >----------------------------------------\n\n|script-title= holds title parameters that are not written in Latin based scripts: Chinese, Japanese, Arabic, Hebrew, etc. These scripts should\nnot be italicized and may be written right-to-left.  The value supplied by |script-title= is concatenated onto Title after Title has been wrapped\nin italic markup.\n\nRegardless of language, all values provided by |script-title= are wrapped in <bdi>...</bdi> tags to isolate rtl languages from the English left to right.\n\n|script-title= provides a unique feature.  The value in |script-title= may be prefixed with a two-character ISO639-1 language code and a colon:\n\t|script-title=ja:*** *** (where * represents a Japanese character)\nSpaces between the two-character code and the colon and the colon and the first script character are allowed:\n\t|script-title=ja : *** ***\n\t|script-title=ja: *** ***\n\t|script-title=ja :*** ***\nSpaces preceding the prefix are allowed: |script-title = ja:*** ***\n\nThe prefix is checked for validity.  If it is a valid ISO639-1 language code, the lang attribute (lang=\"ja\") is added to the <bdi> tag so that browsers can\nknow the language the tag contains.  This may help the browser render the script more correctly.  If the prefix is invalid, the lang attribute\nis not added.  At this time there is no error message for this condition.\n\nSupports |script-title= and |script-chapter=\n\nTODO: error messages when prefix is invalid ISO639-1 code; when script_value has prefix but no script;\n]]\n\nlocal function format_script_value (script_value)\n\tlocal lang='';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- initialize to empty string\n\tlocal name;\n\tif script_value:match('^%l%l%s*:') then\t\t\t\t\t\t\t\t\t\t-- if first 3 non-space characters are script language prefix\n\t\tlang = script_value:match('^(%l%l)%s*:%s*%S.*');\t\t\t\t\t\t-- get the language prefix or nil if there is no script\n\t\tif not is_set (lang) then\n\t\t\treturn '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- script_value was just the prefix so return empty string\n\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if we get this far we have prefix and script\n\t\tname = mw.language.fetchLanguageName( lang, mw.getContentLanguage():getCode() );\t\t\t\t\t\t-- get language name so that we can use it to categorize\n\t\tif is_set (name) then\t\t\t\t\t\t\t\t\t\t\t\t\t-- is prefix a proper ISO 639-1 language code?\n\t\t\tscript_value = script_value:gsub ('^%l%l%s*:%s*', '');\t\t\t\t-- strip prefix from script\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- is prefix one of these language codes?\n\t\t\tif in_array (lang, {'ar', 'bg', 'bs', 'dv', 'el', 'fa', 'he', 'hy', 'ja', 'ka', 'ko', 'ku', 'mk', 'ps', 'ru', 'sd', 'sr', 'th', 'uk', 'ug', 'yi', 'zh'}) then\n\t\t\t\tadd_prop_cat ('script_with_name', {name, lang})\n\t\t\telse\n\t\t\t\tadd_prop_cat ('script')\n\t\t\tend\n\t\t\tlang = ' lang=\"' .. lang .. '\" ';\t\t\t\t\t\t\t\t\t-- convert prefix into a lang attribute\n\t\telse\n\t\t\tlang = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- invalid so set lang to empty string\n\t\tend\n\tend\n\tif is_set(script_value) then\n\t\tscript_value = '-{R|' .. script_value .. '}-';\n\tend\n\tscript_value = substitute (cfg.presentation['bdi'], {lang, script_value});\t-- isolate in case script is rtl\n\n\treturn script_value;\nend\n\n--[[--------------------------< S C R I P T _ C O N C A T E N A T E >------------------------------------------\n\nInitially for |title= and |script-title=, this function concatenates those two parameter values after the script value has been \nwrapped in <bdi> tags.\n]]\n\nlocal function script_concatenate (title, script)\n\tif is_set(title) then\n\t\ttitle = '-{zh;zh-hans;zh-hant|' .. title .. '}-';\n\tend\n\tif is_set (script) then\n\t\tscript = format_script_value (script);\t\t\t\t\t\t\t\t\t-- <bdi> tags, lang atribute, categorization, etc; returns empty string on error\n\t\tif is_set (script) then\n\t\t\ttitle = title .. ' ' .. script;\t\t\t\t\t\t\t\t\t\t-- concatenate title and script title\n\t\tend\n\tend\n\treturn title;\nend\n\n\n--[[--------------------------< W R A P _ M S G >--------------------------------------------------------------\n\nApplies additional message text to various parameter values. Supplied string is wrapped using a message_list\nconfiguration taking one argument.  Supports lower case text for {{citation}} templates.  Additional text taken\nfrom citation_config.messages - the reason this function is similar to but separate from wrap_style().\n\n]]\n\nlocal function wrap_msg (key, str, lower)\n\tif not is_set( str ) then\n\t\treturn \"\";\n\tend\n\tif true == lower then\n\t\tlocal msg;\n\t\tmsg = cfg.messages[key]:lower();\t\t\t\t\t\t\t\t\t\t-- set the message to lower case before \n\t\treturn substitute( msg, str );\t\t\t\t\t\t\t\t\t\t-- including template text\n\telse\n\t\treturn substitute( cfg.messages[key], str );\n\tend\t\t\nend\n\n\n--[[-------------------------< I S _ A L I A S _ U S E D >-----------------------------------------------------\n\nThis function is used by select_one() to determine if one of a list of alias parameters is in the argument list\nprovided by the template.\n\nInput:\n\targs \u2013 pointer to the arguments table from calling template\n\talias \u2013 one of the list of possible aliases in the aliases lists from Module:Citation/CS1/Configuration\n\tindex \u2013 for enumerated parameters, identifies which one\n\tenumerated \u2013 true/false flag used choose how enumerated aliases are examined\n\tvalue \u2013 value associated with an alias that has previously been selected; nil if not yet selected\n\tselected \u2013 the alias that has previously been selected; nil if not yet selected\n\terror_list \u2013 list of aliases that are duplicates of the alias already selected\n\nReturns:\n\tvalue \u2013 value associated with alias we selected or that was previously selected or nil if an alias not yet selected\n\tselected \u2013 the alias we selected or the alias that was previously selected or nil if an alias not yet selected\n\n]]\n\nlocal function is_alias_used (args, alias, index, enumerated, value, selected, error_list)\n\tif enumerated then\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- is this a test for an enumerated parameters?\n\t\talias = alias:gsub ('#', index);\t\t\t\t\t\t\t\t\t\t-- replace '#' with the value in index\n\telse\n\t\talias = alias:gsub ('#', '');\t\t\t\t\t\t\t\t\t\t\t-- remove '#' if it exists\n\tend\n\n\tif is_set(args[alias]) then\t\t\t\t\t\t\t\t\t\t\t\t\t-- alias is in the template's argument list\n\t\tif value ~= nil and selected ~= alias then\t\t\t\t\t\t\t\t-- if we have already selected one of the aliases\n\t\t\tlocal skip;\n\t\t\tfor _, v in ipairs(error_list) do\t\t\t\t\t\t\t\t\t-- spin through the error list to see if we've added this alias\n\t\t\t\tif v == alias then\n\t\t\t\t\tskip = true;\n\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- has been added so stop looking \n\t\t\t\tend\n\t\t\tend\n\t\t\tif not skip then\t\t\t\t\t\t\t\t\t\t\t\t\t-- has not been added so\n\t\t\t\ttable.insert( error_list, alias );\t\t\t\t\t\t\t\t-- add error alias to the error list\n\t\t\tend\n\t\telse\n\t\t\tvalue = args[alias];\t\t\t\t\t\t\t\t\t\t\t\t-- not yet selected an alias, so select this one\n\t\t\tselected = alias;\n\t\tend\n\tend\n\treturn value, selected;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- return newly selected alias, or previously selected alias\nend\n\n\n--[[--------------------------< S E L E C T _ O N E >----------------------------------------------------------\n\nChooses one matching parameter from a list of parameters to consider.  The list of parameters to consider is just\nnames.  For parameters that may be enumerated, the position of the numerator in the parameter name is identified\nby the '#' so |author-last1= and |author1-last= are represented as 'author-last#' and 'author#-last'.\n\nBecause enumerated parameter |<param>1= is an alias of |<param>= we must test for both possibilities.\n\n\nGenerates an error if more than one match is present.\n\n]]\n\nlocal function select_one( args, aliases_list, error_condition, index )\n\tlocal value = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- the value assigned to the selected parameter\n\tlocal selected = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- the name of the parameter we have chosen\n\tlocal error_list = {};\n\n\tif index ~= nil then index = tostring(index); end\n\n\tfor _, alias in ipairs( aliases_list ) do\t\t\t\t\t\t\t\t\t-- for each alias in the aliases list\n\t\tif alias:match ('#') then\t\t\t\t\t\t\t\t\t\t\t\t-- if this alias can be enumerated\n\t\t\tif '1' == index then\t\t\t\t\t\t\t\t\t\t\t\t-- when index is 1 test for enumerated and non-enumerated aliases\n\t\t\t\tvalue, selected = is_alias_used (args, alias, index, false, value, selected, error_list);\t-- first test for non-enumerated alias\n\t\t\tend\n\t\t\tvalue, selected = is_alias_used (args, alias, index, true, value, selected, error_list);\t\t-- test for enumerated alias\n\t\telse\n\t\t\tvalue, selected = is_alias_used (args, alias, index, false, value, selected, error_list);\t\t--test for non-enumerated alias\n\t\tend\n\tend\n\n\tif #error_list > 0 and 'none' ~= error_condition then\t\t\t\t\t\t-- for cases where this code is used outside of extract_names()\n\t\tlocal error_str = \"\";\n\t\tfor _, k in ipairs( error_list ) do\n\t\t\tif error_str ~= \"\" then error_str = error_str .. cfg.messages['parameter-separator'] end\n\t\t\terror_str = error_str .. wrap_style ('parameter', k);\n\t\tend\n\t\tif #error_list > 1 then\n\t\t\terror_str = error_str .. cfg.messages['parameter-final-separator'];\n\t\telse\n\t\t\terror_str = error_str .. cfg.messages['parameter-pair-separator'];\n\t\tend\n\t\terror_str = error_str .. wrap_style ('parameter', selected);\n\t\ttable.insert( z.message_tail, { set_error( error_condition, {error_str}, true ) } );\n\tend\n\t\n\treturn value, selected;\nend\n\n\n--[[--------------------------< F O R M A T _ C H A P T E R _ T I T L E >--------------------------------------\n\nFormat the four chapter parameters: |script-chapter=, |chapter=, |trans-chapter=, and |chapter-url= into a single Chapter meta-\nparameter (chapter_url_source used for error messages).\n\n]]\n\nlocal function format_chapter_title (scriptchapter, chapter, transchapter, chapterurl, chapter_url_source, no_quotes)\n\tlocal chapter_error = '';\n\t\n\tif not is_set (chapter) then\n\t\tchapter = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- to be safe for concatenation\n\telse\n\t\tif false == no_quotes then\n\t\t\tchapter = kern_quotes (chapter);\t\t\t\t\t\t\t\t\t\t-- if necessary, separate chapter title's leading and trailing quote marks from Module provided quote marks\n\t\t\tchapter = wrap_style ('quoted-title', chapter);\n\t\tend\n\tend\n\n\tchapter = script_concatenate (chapter, scriptchapter)\t\t\t\t\t\t-- <bdi> tags, lang atribute, categorization, etc; must be done after title is wrapped\n\n\tif is_set (transchapter) then\n\t\ttranschapter = wrap_style ('trans-quoted-title', transchapter);\n\t\tif is_set (chapter) then\n\t\t\tchapter = chapter ..  ' ' .. transchapter;\n\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- here when transchapter without chapter or script-chapter\n\t\t\tchapter = transchapter;\t\t\t\t\t\t\t\t\t\t\t\t-- \n\t\t\tchapter_error = ' ' .. set_error ('trans_missing_title', {'chapter'});\n\t\tend\n\tend\n\n\tif is_set (chapterurl) then\n\t\tchapter = external_link (chapterurl, chapter, chapter_url_source);\t\t-- adds bare_url_missing_title error if appropriate\n\tend\n\n\treturn chapter .. chapter_error;\nend\n\n--[[--------------------------< H A S _ I N V I S I B L E _ C H A R S >----------------------------------------\n\nThis function searches a parameter's value for nonprintable or invisible characters.  The search stops at the\nfirst match.\n\nThis function will detect the visible replacement character when it is part of the wikisource.\n\nDetects but ignores nowiki and math stripmarkers.  Also detects other named stripmarkers (gallery, math, pre, ref)\nand identifies them with a slightly different error message.  See also coins_cleanup().\n\nDetects but ignores the character pattern that results from the transclusion of {{'}} templates.\n\nOutput of this function is an error message that identifies the character or the Unicode group, or the stripmarker\nthat was detected along with its position (or, for multi-byte characters, the position of its first byte) in the\nparameter value.\n\n]]\n\nlocal function has_invisible_chars (param, v)\n\tlocal position = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- position of invisible char or starting position of stripmarker\n\tlocal dummy;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- end of matching string; not used but required to hold end position when a capture is returned\n\tlocal capture;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- used by stripmarker detection to hold name of the stripmarker\n\tlocal i=1;\n\tlocal stripmarker, apostrophe;\n\n\twhile cfg.invisible_chars[i] do\n\t\tlocal char=cfg.invisible_chars[i][1]\t\t\t\t\t\t\t\t\t-- the character or group name\n\t\tlocal pattern=cfg.invisible_chars[i][2]\t\t\t\t\t\t\t\t\t-- the pattern used to find it\n\t\tposition, dummy, capture = mw.ustring.find (v, pattern)\t\t\t\t\t-- see if the parameter value contains characters that match the pattern\n\t\t\n\t\tif position then\n--\t\t\tif 'nowiki' == capture or 'math' == capture or ('ref' == capture and 'quote' == param) then \t-- nowiki, math, or quote param and ref stripmarker (not an error condition)\n\t\t\tif 'nowiki' == capture or 'math' == capture then \t\t\t\t\t-- nowiki, math stripmarker (not an error condition)\n\t\t\t\tstripmarker = true;\t\t\t\t\t\t\t\t\t\t\t\t-- set a flag\n\t\t\telseif true == stripmarker and 'delete' == char then\t\t\t\t-- because stripmakers begin and end with the delete char, assume that we've found one end of a stripmarker\n\t\t\t\tposition = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset\n\t\t\telseif 'apostrophe' == char then\t\t\t\t\t\t\t\t\t-- apostrophe template uses &zwj;, hair space and zero-width space\n\t\t\t\tapostrophe = true;\n\t\t\telseif true == apostrophe and in_array (char, {'zero width joiner', 'zero width space', 'hair space'}) then\n\t\t\t\tposition = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset\n\t\t\telse\n\t\t\t\tlocal err_msg;\n\t\t\t\tif capture then\n\t\t\t\t\terr_msg = capture .. ' ' .. cfg.invisible_chars[i][3] or char;\n\t\t\t\telse\n\t\t\t\t\terr_msg = cfg.invisible_chars[i][3] or (char .. ' character');\n\t\t\t\tend\n\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'invisible_char', {err_msg, wrap_style ('parameter', param), position}, true ) } );\t-- add error message\n\t\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- and done with this parameter\n\t\t\tend\n\t\tend\n\t\ti=i+1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- bump our index\n\tend\nend\n\n\n--[[--------------------------< A R G U M E N T _ W R A P P E R >----------------------------------------------\n\nArgument wrapper.  This function provides support for argument mapping defined in the configuration file so that\nmultiple names can be transparently aliased to single internal variable.\n\n]]\n\nlocal function argument_wrapper( args )\n\tlocal origin = {};\n\t\n\treturn setmetatable({\n\t\tORIGIN = function( self, k )\n\t\t\tlocal dummy = self[k]; --force the variable to be loaded.\n\t\t\treturn origin[k];\n\t\tend\n\t},\n\t{\n\t\t__index = function ( tbl, k )\n\t\t\tif origin[k] ~= nil then\n\t\t\t\treturn nil;\n\t\t\tend\n\t\t\t\n\t\t\tlocal args, list, v = args, cfg.aliases[k];\n\t\t\t\n\t\t\tif type( list ) == 'table' then\n\t\t\t\tv, origin[k] = select_one( args, list, 'redundant_parameters' );\n\t\t\t\tif origin[k] == nil then\n\t\t\t\t\torigin[k] = ''; -- Empty string, not nil\n\t\t\t\tend\n\t\t\telseif list ~= nil then\n\t\t\t\tv, origin[k] = args[list], list;\n\t\t\telse\n\t\t\t\t-- maybe let through instead of raising an error?\n\t\t\t\t-- v, origin[k] = args[k], k;\n\t\t\t\terror( cfg.messages['unknown_argument_map'] );\n\t\t\tend\n\t\t\t\n\t\t\t-- Empty strings, not nil;\n\t\t\tif v == nil then\n\t\t\t\tv = cfg.defaults[k] or '';\n\t\t\t\torigin[k] = '';\n\t\t\tend\n\t\t\t\n\t\t\ttbl = rawset( tbl, k, v );\n\t\t\treturn v;\n\t\tend,\n\t});\nend\n\n--[[--------------------------< V A L I D A T E >--------------------------------------------------------------\nLooks for a parameter's name in the whitelist.\n\nParameters in the whitelist can have three values:\n\ttrue - active, supported parameters\n\tfalse - deprecated, supported parameters\n\tnil - unsupported parameters\n\t\n]]\n\nlocal function validate( name )\n\tlocal name = tostring( name );\n\tlocal state = whitelist.basic_arguments[ name ];\n\t\n\t-- Normal arguments\n\tif true == state then return true; end\t\t-- valid actively supported parameter\n\tif false == state then\n\t\tdeprecated_parameter (name);\t\t\t\t-- parameter is deprecated but still supported\n\t\treturn true;\n\tend\n\t\n\t-- Arguments with numbers in them\n\tname = name:gsub( \"%d+\", \"#\" );\t\t\t\t-- replace digit(s) with # (last25 becomes last#\n\tstate = whitelist.numbered_arguments[ name ];\n\tif true == state then return true; end\t\t-- valid actively supported parameter\n\tif false == state then\n\t\tdeprecated_parameter (name);\t\t\t\t-- parameter is deprecated but still supported\n\t\treturn true;\n\tend\n\t\n\treturn false;\t\t\t\t\t\t\t\t-- Not supported because not found or name is set to nil\nend\n\n\n-- Formats a wiki style internal link\nlocal function internal_link_id(options)\n\treturn mw.ustring.format( '[[%s%s%s|\\<span title\\=\\\"%s\\\"\\>%s\\<\\/span\\>%s%s]]',\n\t\toptions.prefix, options.id, options.suffix or \"\",\n\t\toptions.link, options.label, options.separator or \"&nbsp;\",\n\t\tmw.text.nowiki(options.id)\n\t);\nend\n\n\n--[[--------------------------< N O W R A P _ D A T E >--------------------------------------------------------\n\nWhen date is YYYY-MM-DD format wrap in nowrap span: <span ...>YYYY-MM-DD</span>.  When date is DD MMMM YYYY or is\nMMMM DD, YYYY then wrap in nowrap span: <span ...>DD MMMM</span> YYYY or <span ...>MMMM DD,</span> YYYY\n\nDOES NOT yet support MMMM YYYY or any of the date ranges.\n\n]]\n\nlocal function nowrap_date (date)\n\tlocal cap='';\n\tlocal cap2='';\n\n\tif date:match(\"^%d%d%d%d%-%d%d%-%d%d$\") then\n\t\tdate = substitute (cfg.presentation['nowrap1'], date);\n\t\n\telseif date:match(\"^%a+%s*%d%d?,%s+%d%d%d%d$\") or date:match (\"^%d%d?%s*%a+%s+%d%d%d%d$\") then\n\t\tcap, cap2 = string.match (date, \"^(.*)%s+(%d%d%d%d)$\");\n\t\tdate = substitute (cfg.presentation['nowrap2'], {cap, cap2});\n\tend\n\t\n\treturn date;\nend\n\n--[[--------------------------< IS _ V A L I D _ I S X N >-----------------------------------------------------\n\nISBN-10 and ISSN validator code calculates checksum across all isbn/issn digits including the check digit. ISBN-13 is checked in check_isbn().\nIf the number is valid the result will be 0. Before calling this function, issbn/issn must be checked for length and stripped of dashes,\nspaces and other non-isxn characters.\n\n]]\n\nlocal function is_valid_isxn (isxn_str, len)\n\tlocal temp = 0;\n\tisxn_str = { isxn_str:byte(1, len) };\t-- make a table of byte values '0' \u2192 0x30 .. '9'  \u2192 0x39, 'X' \u2192 0x58\n\tlen = len+1;\t\t\t\t\t\t\t-- adjust to be a loop counter\n\tfor i, v in ipairs( isxn_str ) do\t\t-- loop through all of the bytes and calculate the checksum\n\t\tif v == string.byte( \"X\" ) then\t\t-- if checkdigit is X (compares the byte value of 'X' which is 0x58)\n\t\t\ttemp = temp + 10*( len - i );\t-- it represents 10 decimal\n\t\telse\n\t\t\ttemp = temp + tonumber( string.char(v) )*(len-i);\n\t\tend\n\tend\n\treturn temp % 11 == 0;\t\t\t\t\t-- returns true if calculation result is zero\nend\n\n\n--[[--------------------------< IS _ V A L I D _ I S X N  _ 1 3 >----------------------------------------------\n\nISBN-13 and ISMN validator code calculates checksum across all 13 isbn/ismn digits including the check digit.\nIf the number is valid, the result will be 0. Before calling this function, isbn-13/ismn must be checked for length\nand stripped of dashes, spaces and other non-isxn-13 characters.\n\n]]\n\nlocal function is_valid_isxn_13 (isxn_str)\n\tlocal temp=0;\n\t\n\tisxn_str = { isxn_str:byte(1, 13) };\t\t\t\t\t\t\t\t\t\t-- make a table of byte values '0' \u2192 0x30 .. '9'  \u2192 0x39\n\tfor i, v in ipairs( isxn_str ) do\n\t\ttemp = temp + (3 - 2*(i % 2)) * tonumber( string.char(v) );\t\t\t\t-- multiply odd index digits by 1, even index digits by 3 and sum; includes check digit\n\tend\n\treturn temp % 10 == 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- sum modulo 10 is zero when isbn-13/ismn is correct\nend\n\n--[[--------------------------< C H E C K _ I S B N >------------------------------------------------------------\n\nDetermines whether an ISBN string is valid\n\n]]\n\nlocal function check_isbn( isbn_str )\n\tif nil ~= isbn_str:match(\"[^%s-0-9X]\") then return false; end\t\t-- fail if isbn_str contains anything but digits, hyphens, or the uppercase X\n\tisbn_str = isbn_str:gsub( \"-\", \"\" ):gsub( \" \", \"\" );\t-- remove hyphens and spaces\n\tlocal len = isbn_str:len();\n \n\tif len ~= 10 and len ~= 13 then\n\t\treturn false;\n\tend\n\n\tif len == 10 then\n\t\tif isbn_str:match( \"^%d*X?$\" ) == nil then return false; end\n\t\treturn is_valid_isxn(isbn_str, 10);\n\telse\n\t\tlocal temp = 0;\n\t\tif isbn_str:match( \"^97[89]%d*$\" ) == nil then return false; end\t\t-- isbn13 begins with 978 or 979; ismn begins with 979\n\t\treturn is_valid_isxn_13 (isbn_str);\n\tend\nend\n\n--[[--------------------------< C H E C K _ I S M N >------------------------------------------------------------\n\nDetermines whether an ISMN string is valid.  Similar to isbn-13, ismn is 13 digits begining 979-0-... and uses the\nsame check digit calculations.  See http://www.ismn-international.org/download/Web_ISMN_Users_Manual_2008-6.pdf\nsection 2, pages 9\u201312.\n\n]]\n\nlocal function ismn (id)\n\tlocal handler = cfg.id_handlers['ISMN'];\n\tlocal text;\n\tlocal valid_ismn = true;\n\n\tid=id:gsub( \"[%s-\u2013]\", \"\" );\t\t\t\t\t\t\t\t\t\t\t\t\t-- strip spaces, hyphens, and endashes from the ismn\n\n\tif 13 ~= id:len() or id:match( \"^9790%d*$\" ) == nil then\t\t\t\t\t-- ismn must be 13 digits and begin 9790\n\t\tvalid_ismn = false;\n\telse\n\t\tvalid_ismn=is_valid_isxn_13 (id);\t\t\t\t\t\t\t\t\t\t-- validate ismn\n\tend\n\n--\ttext = internal_link_id({link = handler.link, label = handler.label,\t\t-- use this (or external version) when there is some place to link to\n--\t\tprefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})\n \n\ttext=\"[[\" .. handler.link .. \"|\" .. handler.label .. \"]]\" .. handler.separator .. id;\t\t-- because no place to link to yet\n\n\tif false == valid_ismn then\n\t\ttext = text .. ' ' .. set_error( 'bad_ismn' )\t\t\t\t\t\t\t-- add an error message if the issn is invalid\n\tend \n\t\n\treturn text;\nend\n\n--[[--------------------------< I S S N >----------------------------------------------------------------------\n\nValidate and format an issn.  This code fixes the case where an editor has included an ISSN in the citation but has separated the two groups of four\ndigits with a space.  When that condition occurred, the resulting link looked like this:\n\n\t|issn=0819 4327 gives: [http://www.worldcat.org/issn/0819 4327 0819 4327]  -- can't have spaces in an external link\n\t\nThis code now prevents that by inserting a hyphen at the issn midpoint.  It also validates the issn for length and makes sure that the checkdigit agrees\nwith the calculated value.  Incorrect length (8 digits), characters other than 0-9 and X, or checkdigit / calculated value mismatch will all cause a check issn\nerror message.  The issn is always displayed with a hyphen, even if the issn was given as a single group of 8 digits.\n\n]]\n\nlocal function issn(id, e)\n\tlocal issn_copy = id;\t\t-- save a copy of unadulterated issn; use this version for display if issn does not validate\n\tlocal handler;\n\tlocal text;\n\tlocal valid_issn = true;\n\t\n\tif e then\n\t\thandler = cfg.id_handlers['EISSN'];\n\telse\n\t\thandler = cfg.id_handlers['ISSN'];\n\tend\n\n\tid=id:gsub( \"[%s-\u2013]\", \"\" );\t\t\t\t\t\t\t\t\t-- strip spaces, hyphens, and endashes from the issn\n\n\tif 8 ~= id:len() or nil == id:match( \"^%d*X?$\" ) then\t\t-- validate the issn: 8 digits long, containing only 0-9 or X in the last position\n\t\tvalid_issn=false;\t\t\t\t\t\t\t\t\t\t-- wrong length or improper character\n\telse\n\t\tvalid_issn=is_valid_isxn(id, 8);\t\t\t\t\t\t-- validate issn\n\tend\n\n\tif true == valid_issn then\n\t\tid = string.sub( id, 1, 4 ) .. \"-\" .. string.sub( id, 5 );\t-- if valid, display correctly formatted version\n\telse\n\t\tid = issn_copy;\t\t\t\t\t\t\t\t\t\t\t-- if not valid, use the show the invalid issn with error message\n\tend\n\t\n\ttext = external_link_id({link = handler.link, label = handler.label,\n\t\tprefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})\n \n\tif false == valid_issn then\n\t\ttext = text .. ' ' .. set_error( 'bad_issn' )\t\t\t-- add an error message if the issn is invalid\n\tend \n\t\n\treturn text\nend\n\n--[[--------------------------< A M A Z O N >------------------------------------------------------------------\n\nFormats a link to Amazon.  Do simple error checking: asin must be mix of 10 numeric or uppercase alpha\ncharacters.  If a mix, first character must be uppercase alpha; if all numeric, asins must be 10-digit\nisbn. If 10-digit isbn, add a maintenance category so a bot or awb script can replace |asin= with |isbn=.\nError message if not 10 characters, if not isbn10, if mixed and first character is a digit.\n\n]]\n\nlocal function amazon(id, domain)\n\tlocal err_cat = \"\"\n\n\tif not id:match(\"^[%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u]$\") then\n\t\terr_cat =  ' ' .. set_error ('bad_asin');\t\t\t\t\t\t\t\t-- asin is not a mix of 10 uppercase alpha and numeric characters\n\telse\n\t\tif id:match(\"^%d%d%d%d%d%d%d%d%d[%dX]$\") then\t\t\t\t\t\t\t\t-- if 10-digit numeric (or 9 digits with terminal X)\n\t\t\tif check_isbn( id ) then\t\t\t\t\t\t\t\t\t\t\t\t-- see if asin value is isbn10\n\t\t\t\tadd_maint_cat ('ASIN');\n\t\t\telseif not is_set (err_cat) then\n\t\t\t\terr_cat =  ' ' .. set_error ('bad_asin');\t\t\t\t\t\t-- asin is not isbn10\n\t\t\tend\n\t\telseif not id:match(\"^%u[%d%u]+$\") then\n\t\t\terr_cat =  ' ' .. set_error ('bad_asin');\t\t\t\t\t\t\t-- asin doesn't begin with uppercase alpha\n\t\tend\n\tend\n\tif not is_set(domain) then \n\t\tdomain = \"com\";\n\telseif in_array (domain, {'jp', 'uk'}) then\t\t\t-- Japan, United Kingdom\n\t\tdomain = \"co.\" .. domain;\n\telseif in_array (domain, {'au', 'br', 'mx'}) then\t-- Australia, Brazil, Mexico\n\t\tdomain = \"com.\" .. domain;\n\tend\n\tlocal handler = cfg.id_handlers['ASIN'];\n\treturn external_link_id({link=handler.link,\n\t\tlabel=handler.label, prefix=handler.prefix .. domain .. \"/dp/\",\n\t\tid=id, encode=handler.encode, separator = handler.separator}) .. err_cat;\nend\n\n--[[--------------------------< A R X I V >--------------------------------------------------------------------\n\nSee: http://arxiv.org/help/arxiv_identifier\n\nformat and error check arXiv identifier.  There are three valid forms of the identifier:\nthe first form, valid only between date codes 9108 and 0703 is:\n\tarXiv:<archive>.<class>/<date code><number><version>\nwhere:\n\t<archive> is a string of alpha characters - may be hyphenated; no other punctuation\n\t<class> is a string of alpha characters - may be hyphenated; no other punctuation\n\t<date code> is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01\n\t\tfirst digit of YY for this form can only 9 and 0\n\t<number> is a three-digit number\n\t<version> is a 1 or more digit number preceded with a lowercase v; no spaces (undocumented)\n\t\nthe second form, valid from April 2007 through December 2014 is:\n\tarXiv:<date code>.<number><version>\nwhere:\n\t<date code> is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01\n\t<number> is a four-digit number\n\t<version> is a 1 or more digit number preceded with a lowercase v; no spaces\n\nthe third form, valid from January 2015 is:\n\tarXiv:<date code>.<number><version>\nwhere:\n\t<date code> and <version> are as defined for 0704-1412\n\t<number> is a five-digit number\n]]\n\nlocal function arxiv (id, class)\n\tlocal handler = cfg.id_handlers['ARXIV'];\n\tlocal year, month, version;\n\tlocal err_cat = '';\n\tlocal text;\n\t\n\tif id:match(\"^%a[%a%.%-]+/[90]%d[01]%d%d%d%d$\") or id:match(\"^%a[%a%.%-]+/[90]%d[01]%d%d%d%dv%d+$\") then\t-- test for the 9108-0703 format w/ & w/o version\n\t\tyear, month = id:match(\"^%a[%a%.%-]+/([90]%d)([01]%d)%d%d%d[v%d]*$\");\n\t\tyear = tonumber(year);\n\t\tmonth = tonumber(month);\n\t\tif ((not (90 < year or 8 > year)) or (1 > month or 12 < month)) or\t\t-- if invalid year or invalid month\n\t\t\t((91 == year and 7 > month) or (7 == year and 3 < month)) then\t\t-- if years ok, are starting and ending months ok?\n\t\t\t\terr_cat = ' ' .. set_error( 'bad_arxiv' );\t\t\t\t\t\t-- set error message\n\t\tend\n\telseif id:match(\"^%d%d[01]%d%.%d%d%d%d$\") or id:match(\"^%d%d[01]%d%.%d%d%d%dv%d+$\") then\t-- test for the 0704-1412 w/ & w/o version\n\t\tyear, month = id:match(\"^(%d%d)([01]%d)%.%d%d%d%d[v%d]*$\");\n\t\tyear = tonumber(year);\n\t\tmonth = tonumber(month);\n\t\tif ((7 > year) or (14 < year) or (1 > month or 12 < month)) or\t\t\t-- is year invalid or is month invalid? (doesn't test for future years)\n\t\t\t((7 == year) and (4 > month)) then --or\t\t\t\t\t\t\t\t\t-- when year is 07, is month invalid (before April)?\n\t\t\t\terr_cat = ' ' .. set_error( 'bad_arxiv' );\t\t\t\t\t\t-- set error message\n\t\tend\n\telseif id:match(\"^%d%d[01]%d%.%d%d%d%d%d$\") or id:match(\"^%d%d[01]%d%.%d%d%d%d%dv%d+$\") then\t-- test for the 1501- format w/ & w/o version\n\t\tyear, month = id:match(\"^(%d%d)([01]%d)%.%d%d%d%d%d[v%d]*$\");\n\t\tyear = tonumber(year);\n\t\tmonth = tonumber(month);\n\t\tif ((15 > year) or (1 > month or 12 < month)) then\t\t\t\t\t\t-- is year invalid or is month invalid? (doesn't test for future years)\n\t\t\terr_cat = ' ' .. set_error( 'bad_arxiv' );\t\t\t\t\t\t\t-- set error message\n\t\tend\n\telse\n\t\terr_cat = ' ' .. set_error( 'bad_arxiv' );\t\t\t\t\t\t\t\t-- arXiv id doesn't match any format\n\tend\n\n\ttext = external_link_id({link = handler.link, label = handler.label,\n\t\t\tprefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;\n\n\tif is_set (class) then\n\t\tclass = ' [[' .. '//arxiv.org/archive/' .. class .. ' ' .. class .. ']]';\t-- external link within square brackets, not wikilink\n\telse\n\t\tclass = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- empty string for concatenation\n\tend\n\t\n\treturn text .. class;\nend\n\n--[[\nlccn normalization (http://www.loc.gov/marc/lccn-namespace.html#normalization)\n1. Remove all blanks.\n2. If there is a forward slash (/) in the string, remove it, and remove all characters to the right of the forward slash.\n3. If there is a hyphen in the string:\n\ta. Remove it.\n\tb. Inspect the substring following (to the right of) the (removed) hyphen. Then (and assuming that steps 1 and 2 have been carried out):\n\t\t1. All these characters should be digits, and there should be six or less. (not done in this function)\n\t\t2. If the length of the substring is less than 6, left-fill the substring with zeroes until the length is six.\n\nReturns a normalized lccn for lccn() to validate.  There is no error checking (step 3.b.1) performed in this function.\n]]\n\nlocal function normalize_lccn (lccn)\n\tlccn = lccn:gsub (\"%s\", \"\");\t\t\t\t\t\t\t\t\t-- 1. strip whitespace\n\n\tif nil ~= string.find (lccn,'/') then\n\t\tlccn = lccn:match (\"(.-)/\");\t\t\t\t\t\t\t\t-- 2. remove forward slash and all character to the right of it\n\tend\n\n\tlocal prefix\n\tlocal suffix\n\tprefix, suffix = lccn:match (\"(.+)%-(.+)\");\t\t\t\t\t\t-- 3.a remove hyphen by splitting the string into prefix and suffix\n\n\tif nil ~= suffix then\t\t\t\t\t\t\t\t\t\t\t-- if there was a hyphen\n\t\tsuffix=string.rep(\"0\", 6-string.len (suffix)) .. suffix;\t-- 3.b.2 left fill the suffix with 0s if suffix length less than 6\n\t\tlccn=prefix..suffix;\t\t\t\t\t\t\t\t\t\t-- reassemble the lccn\n\tend\n\t\n\treturn lccn;\n\tend\n\n--[[\nFormat LCCN link and do simple error checking.  LCCN is a character string 8-12 characters long. The length of the LCCN dictates the character type of the first 1-3 characters; the\nrightmost eight are always digits. http://info-uri.info/registry/OAIHandler?verb=GetRecord&metadataPrefix=reg&identifier=info:lccn/\n\nlength = 8 then all digits\nlength = 9 then lccn[1] is lower case alpha\nlength = 10 then lccn[1] and lccn[2] are both lower case alpha or both digits\nlength = 11 then lccn[1] is lower case alpha, lccn[2] and lccn[3] are both lower case alpha or both digits\nlength = 12 then lccn[1] and lccn[2] are both lower case alpha\n\n]]\n\nlocal function lccn(lccn)\n\tlocal handler = cfg.id_handlers['LCCN'];\n\tlocal err_cat =  '';\t\t\t\t\t\t\t\t-- presume that LCCN is valid\n\tlocal id = lccn;\t\t\t\t\t\t\t\t\t-- local copy of the lccn\n\n\tid = normalize_lccn (id);\t\t\t\t\t\t\t-- get canonical form (no whitespace, hyphens, forward slashes)\n\tlocal len = id:len();\t\t\t\t\t\t\t\t-- get the length of the lccn\n\n\tif 8 == len then\n\t\tif id:match(\"[^%d]\") then\t\t\t\t\t\t-- if LCCN has anything but digits (nil if only digits)\n\t\t\terr_cat = ' ' .. set_error( 'bad_lccn' );\t-- set an error message\n\t\tend\n\telseif 9 == len then\t\t\t\t\t\t\t\t-- LCCN should be adddddddd\n\t\tif nil == id:match(\"%l%d%d%d%d%d%d%d%d\") then\t\t\t-- does it match our pattern?\n\t\t\terr_cat = ' ' .. set_error( 'bad_lccn' );\t-- set an error message\n\t\tend\n\telseif 10 == len then\t\t\t\t\t\t\t\t-- LCCN should be aadddddddd or dddddddddd\n\t\tif id:match(\"[^%d]\") then\t\t\t\t\t\t\t-- if LCCN has anything but digits (nil if only digits) ...\n\t\t\tif nil == id:match(\"^%l%l%d%d%d%d%d%d%d%d\") then\t-- ... see if it matches our pattern\n\t\t\t\terr_cat = ' ' .. set_error( 'bad_lccn' );\t-- no match, set an error message\n\t\t\tend\n\t\tend\n\telseif 11 == len then\t\t\t\t\t\t\t\t-- LCCN should be aaadddddddd or adddddddddd\n\t\tif not (id:match(\"^%l%l%l%d%d%d%d%d%d%d%d\") or id:match(\"^%l%d%d%d%d%d%d%d%d%d%d\")) then\t-- see if it matches one of our patterns\n\t\t\terr_cat = ' ' .. set_error( 'bad_lccn' );\t-- no match, set an error message\n\t\tend\n\telseif 12 == len then\t\t\t\t\t\t\t\t-- LCCN should be aadddddddddd\n\t\tif not id:match(\"^%l%l%d%d%d%d%d%d%d%d%d%d\") then\t-- see if it matches our pattern\n\t\t\terr_cat = ' ' .. set_error( 'bad_lccn' );\t-- no match, set an error message\n\t\tend\n\telse\n\t\terr_cat = ' ' .. set_error( 'bad_lccn' );\t\t-- wrong length, set an error message\n\tend\n\n\tif not is_set (err_cat) and nil ~= lccn:find ('%s') then\n\t\terr_cat = ' ' .. set_error( 'bad_lccn' );\t\t-- lccn contains a space, set an error message\n\tend\n\n\treturn external_link_id({link = handler.link, label = handler.label,\n\t\t\tprefix=handler.prefix,id=lccn,separator=handler.separator, encode=handler.encode}) .. err_cat;\nend\n\n--[[\nFormat PMID and do simple error checking.  PMIDs are sequential numbers beginning at 1 and counting up.  This code checks the PMID to see that it\ncontains only digits and is less than test_limit; the value in local variable test_limit will need to be updated periodically as more PMIDs are issued.\n]]\n\nlocal function pmid(id)\n\tlocal test_limit = 30000000;\t\t\t\t\t\t-- update this value as PMIDs approach\n\tlocal handler = cfg.id_handlers['PMID'];\n\tlocal err_cat =  '';\t\t\t\t\t\t\t\t-- presume that PMID is valid\n\t\n\tif id:match(\"[^%d]\") then\t\t\t\t\t\t\t-- if PMID has anything but digits\n\t\terr_cat = ' ' .. set_error( 'bad_pmid' );\t\t-- set an error message\n\telse\t\t\t\t\t\t\t\t\t\t\t\t-- PMID is only digits\n\t\tlocal id_num = tonumber(id);\t\t\t\t\t-- convert id to a number for range testing\n\t\tif 1 > id_num or test_limit < id_num then\t\t-- if PMID is outside test limit boundaries\n\t\t\terr_cat = ' ' .. set_error( 'bad_pmid' );\t-- set an error message\n\t\tend\n\tend\n\t\n\treturn external_link_id({link = handler.link, label = handler.label,\n\t\t\tprefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;\nend\n\n--[[--------------------------< I S _ E M B A R G O E D >------------------------------------------------------\n\nDetermines if a PMC identifier's online version is embargoed. Compares the date in |embargo= against today's date.  If embargo date is\nin the future, returns the content of |embargo=; otherwise, returns and empty string because the embargo has expired or because\n|embargo= was not set in this cite.\n\n]]\n\nlocal function is_embargoed (embargo)\n\tif is_set (embargo) then\n\t\tlocal lang = mw.getContentLanguage();\n\t\tlocal good1, embargo_date, good2, todays_date;\n\t\tgood1, embargo_date = pcall( lang.formatDate, lang, 'U', embargo );\n\t\tgood2, todays_date = pcall( lang.formatDate, lang, 'U' );\n\t\n\t\tif good1 and good2 then\t\t\t\t\t\t\t\t\t\t\t\t\t-- if embargo date and today's date are good dates\n\t\t\tif tonumber( embargo_date ) >= tonumber( todays_date ) then\t\t\t-- is embargo date is in the future?\n\t\t\t\treturn embargo;\t\t\t\t\t\t\t\t\t\t\t\t\t-- still embargoed\n\t\t\telse\n\t\t\t\tadd_maint_cat ('embargo')\n\t\t\t\treturn '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset because embargo has expired\n\t\t\tend\n\t\tend\n\tend\n\treturn '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- |embargo= not set return empty string\nend\n\n--[[--------------------------< P M C >------------------------------------------------------------------------\n\nFormat a PMC, do simple error checking, and check for embargoed articles.\n\nThe embargo parameter takes a date for a value. If the embargo date is in the future the PMC identifier will not\nbe linked to the article.  If the embargo date is today or in the past, or if it is empty or omitted, then the\nPMC identifier is linked to the article through the link at cfg.id_handlers['PMC'].prefix.\n\nPMC embargo date testing is done in function is_embargoed () which is called earlier because when the citation\nhas |pmc=<value> but does not have a |url= then |title= is linked with the PMC link.  Function is_embargoed ()\nreturns the embargo date if the PMC article is still embargoed, otherwise it returns an empty string.\n\nPMCs are sequential numbers beginning at 1 and counting up.  This code checks the PMC to see that it contains only digits and is less\nthan test_limit; the value in local variable test_limit will need to be updated periodically as more PMCs are issued.\n\n]]\n\nlocal function pmc(id, embargo)\n\tlocal test_limit = 6000000;\t\t\t\t\t\t\t-- update this value as PMCs approach\n\tlocal handler = cfg.id_handlers['PMC'];\n\tlocal err_cat =  '';\t\t\t\t\t\t\t\t-- presume that PMC is valid\n\t\n\tlocal text;\n\n\tif id:match(\"[^%d]\") then\t\t\t\t\t\t\t-- if PMC has anything but digits\n\t\terr_cat = ' ' .. set_error( 'bad_pmc' );\t\t\t-- set an error message\n\telse\t\t\t\t\t\t\t\t\t\t\t\t-- PMC is only digits\n\t\tlocal id_num = tonumber(id);\t\t\t\t\t-- convert id to a number for range testing\n\t\tif 1 > id_num or test_limit < id_num then\t\t-- if PMC is outside test limit boundaries\n\t\t\terr_cat = ' ' .. set_error( 'bad_pmc' );\t\t-- set an error message\n\t\tend\n\tend\n\t\n\tif is_set (embargo) then\t\t\t\t\t\t\t\t\t\t\t\t\t-- is PMC is still embargoed?\n\t\ttext=\"[[\" .. handler.link .. \"|\" .. handler.label .. \"]]:\" .. handler.separator .. id .. err_cat;\t-- still embargoed so no external link\n\telse\n\t\ttext = external_link_id({link = handler.link, label = handler.label,\t\t\t-- no embargo date or embargo has expired, ok to link to article\n\t\t\tprefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode}) .. err_cat;\n\tend\n\treturn text;\nend\n\n-- Formats a DOI and checks for DOI errors.\n\n-- DOI names contain two parts: prefix and suffix separated by a forward slash.\n--  Prefix: directory indicator '10.' followed by a registrant code\n--  Suffix: character string of any length chosen by the registrant\n\n-- This function checks a DOI name for: prefix/suffix.  If the doi name contains spaces or endashes,\n-- or, if it ends with a period or a comma, this function will emit a bad_doi error message.\n\n-- DOI names are case-insensitive and can incorporate any printable Unicode characters so the test for spaces, endash,\n-- and terminal punctuation may not be technically correct but it appears, that in practice these characters are rarely if ever used in doi names.\n\nlocal function doi(id, inactive)\n\tlocal cat = \"\"\n\tlocal handler = cfg.id_handlers['DOI'];\n\t\n\tlocal text;\n\tif is_set(inactive) then\n\t\tlocal inactive_year = inactive:match(\"%d%d%d%d\") or '';\t\t-- try to get the year portion from the inactive date\n\t\ttext = \"[[\" .. handler.link .. \"|\" .. handler.label .. \"]]:\" .. id;\n\t\tif is_set(inactive_year) then\n\t\t\ttable.insert( z.error_categories, \"Pages with DOIs inactive since \" .. inactive_year );\n\t\telse\n\t\t\ttable.insert( z.error_categories, \"Pages with inactive DOIs\" );\t-- when inactive doesn't contain a recognizable year\n\t\tend\n\t\tinactive = \" (\" .. cfg.messages['inactive'] .. \" \" .. inactive .. \")\" \n\telse \n\t\ttext = external_link_id({link = handler.link, label = handler.label,\n\t\t\tprefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})\n\t\tinactive = \"\" \n\tend\n\n\tif nil == id:match(\"^10%.[^%s\u2013]-/[^%s\u2013]-[^%.,]$\") then\t-- doi must begin with '10.', must contain a fwd slash, must not contain spaces or endashes, and must not end with period or comma\n\t\tcat = ' ' .. set_error( 'bad_doi' );\n\tend\n\treturn text .. inactive .. cat \nend\n\n\n--[[--------------------------< O P E N L I B R A R Y >--------------------------------------------------------\n\nFormats an OpenLibrary link, and checks for associated errors.\n\n]]\nlocal function openlibrary(id)\n\tlocal code = id:match(\"^%d+([AMW])$\");\t\t\t\t\t\t\t\t\t\t-- only digits followed by 'A', 'M', or 'W'\n\tlocal handler = cfg.id_handlers['OL'];\n\n\tif ( code == \"A\" ) then\n\t\treturn external_link_id({link=handler.link, label=handler.label,\n\t\t\tprefix=handler.prefix .. 'authors/OL',\n\t\t\tid=id, separator=handler.separator,\tencode = handler.encode})\n\telseif ( code == \"M\" ) then\n\t\treturn external_link_id({link=handler.link, label=handler.label,\n\t\t\tprefix=handler.prefix .. 'books/OL',\n\t\t\tid=id, separator=handler.separator,\tencode = handler.encode})\n\telseif ( code == \"W\" ) then\n\t\treturn external_link_id({link=handler.link, label=handler.label,\n\t\t\tprefix=handler.prefix .. 'works/OL',\n\t\t\tid=id, separator=handler.separator,\tencode = handler.encode})\n\telse\n\t\treturn external_link_id({link=handler.link, label=handler.label,\n\t\t\tprefix=handler.prefix .. 'OL',\n\t\t\tid=id, separator=handler.separator,\tencode = handler.encode}) .. ' ' .. set_error( 'bad_ol' );\n\tend\nend\n\n\n--[[--------------------------< M E S S A G E _ I D >----------------------------------------------------------\n\nValidate and format a usenet message id.  Simple error checking, looks for 'id-left@id-right' not enclosed in\n'<' and/or '>' angle brackets.\n\n]]\n\nlocal function message_id (id)\n\tlocal handler = cfg.id_handlers['USENETID'];\n\n\ttext = external_link_id({link = handler.link, label = handler.label,\n\t\tprefix=handler.prefix,id=id,separator=handler.separator, encode=handler.encode})\n \n\tif not id:match('^.+@.+$') or not id:match('^[^<].*[^>]$')then\t\t\t\t-- doesn't have '@' or has one or first or last character is '< or '>'\n\t\ttext = text .. ' ' .. set_error( 'bad_message_id' )\t\t\t\t\t\t-- add an error message if the message id is invalid\n\tend \n\t\n\treturn text\nend\n\n--[[--------------------------< S E T _ T I T L E T Y P E >----------------------------------------------------\n\nThis function sets default title types (equivalent to the citation including |type=<default value>) for those templates that have defaults.\nAlso handles the special case where it is desirable to omit the title type from the rendered citation (|type=none).\n\n]]\n\nlocal function set_titletype (cite_class, title_type)\n\tif is_set(title_type) then\n\t\tif \"none\" == title_type then\n\t\t\ttitle_type = \"\";\t\t\t\t\t\t\t\t\t\t\t\t\t-- if |type=none then type parameter not displayed\n\t\tend\n\t\treturn title_type;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if |type= has been set to any other value use that value\n\tend\n\n\treturn cfg.title_types [cite_class] or '';\t\t\t\t\t\t\t\t\t-- set template's default title type; else empty string for concatenation\nend\n\n--[[--------------------------< C L E A N _ I S B N >----------------------------------------------------------\n\nRemoves irrelevant text and dashes from ISBN number\nSimilar to that used for Special:BookSources\n\n]]\n\nlocal function clean_isbn( isbn_str )\n\treturn isbn_str:gsub( \"[^-0-9X]\", \"\" );\nend\n\n--[[--------------------------< E S C A P E _ L U A _ M A G I C _ C H A R S >----------------------------------\n\nReturns a string where all of lua's magic characters have been escaped.  This is important because functions like\nstring.gsub() treat their pattern and replace strings as patterns, not literal strings.\n]]\nlocal function escape_lua_magic_chars (argument)\n\targument = argument:gsub(\"%%\", \"%%%%\");\t\t\t\t\t\t\t\t\t\t-- replace % with %%\n\targument = argument:gsub(\"([%^%$%(%)%.%[%]%*%+%-%?])\", \"%%%1\");\t\t\t\t-- replace all other lua magic pattern characters\n\treturn argument;\nend\n\n--[[--------------------------< S T R I P _ A P O S T R O P H E _ M A R K U P >--------------------------------\n\nStrip wiki italic and bold markup from argument so that it doesn't contaminate COinS metadata.\nThis function strips common patterns of apostrophe markup.  We presume that editors who have taken the time to\nmarkup a title have, as a result, provided valid markup. When they don't, some single apostrophes are left behind.\n\n]]\n\nlocal function strip_apostrophe_markup (argument)\n\tif not is_set (argument) then return argument; end\n\n\twhile true do\n\t\tif argument:match (\"%'%'%'%'%'\") then\t\t\t\t\t\t\t\t\t-- bold italic (5)\n\t\t\targument=argument:gsub(\"%'%'%'%'%'\", \"\");\t\t\t\t\t\t\t-- remove all instances of it\n\t\telseif argument:match (\"%'%'%'%'\") then\t\t\t\t\t\t\t\t\t-- italic start and end without content (4)\n\t\t\targument=argument:gsub(\"%'%'%'%'\", \"\");\n\t\telseif argument:match (\"%'%'%'\") then\t\t\t\t\t\t\t\t\t-- bold (3)\n\t\t\targument=argument:gsub(\"%'%'%'\", \"\");\n\t\telseif argument:match (\"%'%'\") then\t\t\t\t\t\t\t\t\t\t-- italic (2)\n\t\t\targument=argument:gsub(\"%'%'\", \"\");\n\t\telse\n\t\t\tbreak;\n\t\tend\n\tend\n\treturn argument;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- done\nend\n\n--[[--------------------------< M A K E _ C O I N S _ T I T L E >----------------------------------------------\n\nMakes a title for COinS from Title and / or ScriptTitle (or any other name-script pairs)\n\nApostrophe markup (bold, italics) is stripped from each value so that the COinS metadata isn't correupted with strings\nof %27%27...\n]]\n\nlocal function make_coins_title (title, script)\n\tif is_set (title) then\n\t\ttitle = strip_apostrophe_markup (title);\t\t\t\t\t\t\t\t-- strip any apostrophe markup\n\telse\n\t\ttitle='';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if not set, make sure title is an empty string\n\tend\n\tif is_set (script) then\n\t\tscript = script:gsub ('^%l%l%s*:%s*', '');\t\t\t\t\t\t\t\t-- remove language prefix if present (script value may now be empty string)\n\t\tscript = strip_apostrophe_markup (script);\t\t\t\t\t\t\t\t-- strip any apostrophe markup\n\telse\n\t\tscript='';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if not set, make sure script is an empty string\n\tend\n\tif is_set (title) and is_set (script) then\n\t\tscript = ' ' .. script;\t\t\t\t\t\t\t\t\t\t\t\t\t-- add a space before we concatenate\n\tend\n\treturn title .. script;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- return the concatenation\nend\n\n--[[--------------------------< G E T _ C O I N S _ P A G E S >------------------------------------------------\n\nExtract page numbers from external wikilinks in any of the |page=, |pages=, or |at= parameters for use in COinS.\n\n]]\n\nlocal function get_coins_pages (pages)\n\tlocal pattern;\n\tif not is_set (pages) then return pages; end\t\t\t\t\t\t\t\t-- if no page numbers then we're done\n\t\n\twhile true do\n\t\tpattern = pages:match(\"%[(%w*:?//[^ ]+%s+)[%w%d].*%]\");\t\t\t\t\t-- pattern is the opening bracket, the url and following space(s): \"[url \"\n\t\tif nil == pattern then break; end\t\t\t\t\t\t\t\t\t\t-- no more urls\n\t\tpattern = escape_lua_magic_chars (pattern);\t\t\t\t\t\t\t\t-- pattern is not a literal string; escape lua's magic pattern characters\n\t\tpages = pages:gsub(pattern, \"\");\t\t\t\t\t\t\t\t\t\t-- remove as many instances of pattern as possible\n\tend\n\tpages = pages:gsub(\"[%[%]]\", \"\");\t\t\t\t\t\t\t\t\t\t\t-- remove the brackets\n\tpages = pages:gsub(\"\u2013\", \"-\" );\t\t\t\t\t\t\t-- replace endashes with hyphens\n\tpages = pages:gsub(\"&%w+;\", \"-\" );\t\t\t\t\t\t-- and replace html entities (&ndash; etc.) with hyphens; do we need to replace numerical entities like &#32; and the like?\n\treturn pages;\nend\n\n-- Gets the display text for a wikilink like [[A|B]] or [[B]] gives B\nlocal function remove_wiki_link( str )\n\treturn (str:gsub( \"%[%[([^%[%]]*)%]%]\", function(l)\n\t\treturn l:gsub( \"^[^|]*|(.*)$\", \"%1\" ):gsub(\"^%s*(.-)%s*$\", \"%1\");\n\tend));\nend\n\n-- Converts a hyphen to a dash\nlocal function hyphen_to_dash( str )\n\tif not is_set(str) or str:match( \"[%[%]{}<>]\" ) ~= nil then\n\t\treturn str;\n\tend\t\n\treturn str:gsub( '-', '\u2013' );\nend\n\n--[[--------------------------< S A F E _ J O I N >------------------------------------------------------------\n\nJoins a sequence of strings together while checking for duplicate separation characters.\n\n]]\n\nlocal function safe_join( tbl, duplicate_char )\n\t--[[\n\tNote: we use string functions here, rather than ustring functions.\n\t\n\tThis has considerably faster performance and should work correctly as \n\tlong as the duplicate_char is strict ASCII.  The strings\n\tin tbl may be ASCII or UTF8.\n\t]]\n\t\n\tlocal str = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- the output string\n\tlocal comp = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- what does 'comp' mean?\n\tlocal end_chr = '';\n\tlocal trim;\n\tfor _, value in ipairs( tbl ) do\n\t\tif value == nil then value = ''; end\n\t\t\n\t\tif str == '' then\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if output string is empty\n\t\t\tstr = value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- assign value to it (first time through the loop)\n\t\telseif value ~= '' then\n\t\t\tif value:sub(1,1) == '<' then\t\t\t\t\t\t\t\t\t\t-- Special case of values enclosed in spans and other markup.\n\t\t\t\tcomp = value:gsub( \"%b<>\", \"\" );\t\t\t\t\t\t\t\t-- remove html markup (<span>string</span> -> string)\n\t\t\telse\n\t\t\t\tcomp = value;\n\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- typically duplicate_char is sepc\n\t\t\tif comp:sub(1,1) == duplicate_char then\t\t\t\t\t\t\t\t-- is first charactier same as duplicate_char? why test first character?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t--   Because individual string segments often (always?) begin with terminal punct for th\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t--   preceding segment: 'First element' .. 'sepc next element' .. etc?\n\t\t\t\ttrim = false;\n\t\t\t\tend_chr = str:sub(-1,-1);\t\t\t\t\t\t\t\t\t\t-- get the last character of the output string\n\t\t\t\t-- str = str .. \"<HERE(enchr=\" .. end_chr.. \")\"\t\t\t\t\t-- debug stuff?\n\t\t\t\tif end_chr == duplicate_char then\t\t\t\t\t\t\t\t-- if same as separator\n\t\t\t\t\tstr = str:sub(1,-2);\t\t\t\t\t\t\t\t\t\t-- remove it\n\t\t\t\telseif end_chr == \"'\" then\t\t\t\t\t\t\t\t\t\t-- if it might be wikimarkup\n\t\t\t\t\tif str:sub(-3,-1) == duplicate_char .. \"''\" then\t\t\t-- if last three chars of str are sepc'' \n\t\t\t\t\t\tstr = str:sub(1, -4) .. \"''\";\t\t\t\t\t\t\t-- remove them and add back ''\n\t\t\t\t\telseif str:sub(-5,-1) == duplicate_char .. \"]]''\" then\t\t-- if last five chars of str are sepc]]'' \n\t\t\t\t\t\ttrim = true;\t\t\t\t\t\t\t\t\t\t\t-- why? why do this and next differently from previous?\n\t\t\t\t\telseif str:sub(-4,-1) == duplicate_char .. \"]''\" then\t\t-- if last four chars of str are sepc]'' \n\t\t\t\t\t\ttrim = true;\t\t\t\t\t\t\t\t\t\t\t-- same question\n\t\t\t\t\tend\n\t\t\t\telseif end_chr == \"]\" then\t\t\t\t\t\t\t\t\t\t-- if it might be wikimarkup\n\t\t\t\t\tif str:sub(-3,-1) == duplicate_char .. \"]]\" then\t\t\t-- if last three chars of str are sepc]] wikilink \n\t\t\t\t\t\ttrim = true;\n\t\t\t\t\telseif str:sub(-2,-1) == duplicate_char .. \"]\" then\t\t\t-- if last two chars of str are sepc] external link\n\t\t\t\t\t\ttrim = true;\n\t\t\t\t\telseif str:sub(-4,-1) == duplicate_char .. \"'']\" then\t\t-- normal case when |url=something & |title=Title.\n\t\t\t\t\t\ttrim = true;\n\t\t\t\t\tend\n\t\t\t\telseif end_chr == \" \" then\t\t\t\t\t\t\t\t\t\t-- if last char of output string is a space\n\t\t\t\t\tif str:sub(-2,-1) == duplicate_char .. \" \" then\t\t\t\t-- if last two chars of str are <sepc><space>\n\t\t\t\t\t\tstr = str:sub(1,-3);\t\t\t\t\t\t\t\t\t-- remove them both\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tif trim then\n\t\t\t\t\tif value ~= comp then \t\t\t\t\t\t\t\t\t\t-- value does not equal comp when value contains html markup\n\t\t\t\t\t\tlocal dup2 = duplicate_char;\n\t\t\t\t\t\tif dup2:match( \"%A\" ) then dup2 = \"%\" .. dup2; end\t\t-- if duplicate_char not a letter then escape it\n\t\t\t\t\t\t\n\t\t\t\t\t\tvalue = value:gsub( \"(%b<>)\" .. dup2, \"%1\", 1 )\t\t\t-- remove duplicate_char if it follows html markup\n\t\t\t\t\telse\n\t\t\t\t\t\tvalue = value:sub( 2, -1 );\t\t\t\t\t\t\t\t-- remove duplicate_char when it is first character\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tstr = str .. value;\t\t\t\t\t\t\t\t\t\t\t\t\t--add it to the output string\n\t\tend\n\tend\n\treturn str;\nend  \n\n--[[--------------------------< I S _ G O O D _ V A N C _ N A M E >--------------------------------------------\n\nFor Vancouver Style, author/editor names are supposed to be rendered in Latin (read ASCII) characters.  When a name\nuses characters that contain diacritical marks, those characters are to converted to the corresponding Latin character.\nWhen a name is written using a non-Latin alphabet or logogram, that name is to be transliterated into Latin characters.\nThese things are not currently possible in this module so are left to the editor to do.\n\nThis test allows |first= and |last= names to contain any of the letters defined in the four Unicode Latin character sets\n\t[http://www.unicode.org/charts/PDF/U0000.pdf C0 Controls and Basic Latin] 0041\u2013005A, 0061\u2013007A\n\t[http://www.unicode.org/charts/PDF/U0080.pdf C1 Controls and Latin-1 Supplement] 00C0\u201300D6, 00D8\u201300F6, 00F8\u201300FF\n\t[http://www.unicode.org/charts/PDF/U0100.pdf Latin Extended-A] 0100\u2013017F\n\t[http://www.unicode.org/charts/PDF/U0180.pdf Latin Extended-B] 0180\u201301BF, 01C4\u2013024F\n\n|lastn= also allowed to contain hyphens, spaces, and apostrophes. (http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)\n|firstn= also allowed to contain hyphens, spaces, apostrophes, and periods\n\nAt the time of this writing, I had to write the 'if nil == mw.ustring.find ...' test ouside of the code editor and paste it here\nbecause the code editor gets confused between character insertion point and cursor position.\n\n]]\n\nlocal function is_good_vanc_name (last, first)\n\tif nil == mw.ustring.find (last, \"^[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u01bf\u01c4-\u024f%-%s%']*$\") or nil == mw.ustring.find (first, \"^[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u01bf\u01c4-\u024f%-%s%'%.]*$\") then\n\t\tadd_vanc_error ();\n\t\treturn false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- not a string of latin characters; Vancouver required Romanization\n\tend;\n\treturn true;\nend\n\n--[[--------------------------< R E D U C E _ T O _ I N I T I A L S >------------------------------------------\n\nAttempts to convert names to initials in support of |name-list-format=vanc.  \n\nNames in |firstn= may be separated by spaces or hyphens, or for initials, a period. See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35062/.\n\nVancouver style requires family rank designations (Jr, II, III, etc) to be rendered as Jr, 2nd, 3rd, etc.  This form is not\ncurrently supported by this code so correctly formed names like Smith JL 2nd are converted to Smith J2. See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35085/.\n\nThis function uses ustring functions because firstname initials may be any of the unicode Latin characters accepted by is_good_vanc_name ().\n\n]]\n\nlocal function reduce_to_initials(first)\n\tif mw.ustring.match(first, \"^%u%u$\") then return first end;\t\t\t\t\t-- when first contains just two upper-case letters, nothing to do\n\tlocal initials = {}\n\tlocal i = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- counter for number of initials\n\tfor word in mw.ustring.gmatch(first, \"[^%s%.%-]+\") do\t\t\t\t\t\t-- names separated by spaces, hyphens, or periods\n\t\ttable.insert(initials, mw.ustring.sub(word,1,1))\t\t\t\t\t\t-- Vancouver format does not include full stops.\n\t\ti = i + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- bump the counter \n\t\tif 2 <= i then break; end\t\t\t\t\t\t\t\t\t\t\t\t-- only two initials allowed in Vancouver system; if 2, quit\n\tend\n\treturn table.concat(initials)\t\t\t\t\t\t\t\t\t\t\t\t-- Vancouver format does not include spaces.\nend\n\n--[[--------------------------< L I S T  _ P E O P L E >-------------------------------------------------------\n\nFormats a list of people (e.g. authors / editors) \n\n]]\n\nlocal function list_people(control, people, etal, list_name)\t\t\t\t\t-- TODO: why is list_name here?  not used in this function\n\tlocal sep;\n\tlocal namesep;\n\tlocal format = control.format\n\tlocal maximum = control.maximum\n\tlocal lastauthoramp = control.lastauthoramp;\n\tlocal text = {}\n\n\tif 'vanc' == format then\t\t\t\t\t\t\t\t\t\t\t\t\t-- Vancouver-like author/editor name styling?\n\t\tsep = ',';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- name-list separator between authors is a comma\n\t\tnamesep = ' ';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- last/first separator is a space\n\telse\n\t\tsep = ';'\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- name-list separator between authors is a semicolon\n\t\tnamesep = ', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- last/first separator is <comma><space>\n\tend\n\t\n\tif sep:sub(-1,-1) ~= \" \" then sep = sep .. \" \" end\n\tif is_set (maximum) and maximum < 1 then return \"\", 0; end\t\t\t\t\t-- returned 0 is for EditorCount; not used for authors\n\t\n\tfor i,person in ipairs(people) do\n\t\tif is_set(person.last) then\n\t\t\tlocal mask = person.mask\n\t\t\tlocal one\n\t\t\tlocal sep_one = sep;\n\t\t\tif is_set (maximum) and i > maximum then\n\t\t\t\tetal = true;\n\t\t\t\tbreak;\n\t\t\telseif (mask ~= nil) then\n\t\t\t\tlocal n = tonumber(mask)\n\t\t\t\tif (n ~= nil) then\n\t\t\t\t\tone = string.rep(\"&mdash;\",n)\n\t\t\t\telse\n\t\t\t\t\tone = mask;\n\t\t\t\t\tsep_one = \" \";\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tone = person.last\n\t\t\t\tlocal first = person.first\n\t\t\t\tif is_set(first) then \n\t\t\t\t\tif ( \"vanc\" == format ) then\t\t\t\t\t\t\t\t-- if vancouver format\n\t\t\t\t\t\tone = one:gsub ('%.', '');\t\t\t\t\t\t\t\t-- remove periods from surnames (http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)\n\t\t\t\t\t\tif not person.corporate and is_good_vanc_name (one, first) then\t\t\t\t\t-- and name is all Latin characters; corporate authors not tested\n\t\t\t\t\t\t\tfirst = reduce_to_initials(first)\t\t\t\t\t-- attempt to convert first name(s) to initials\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tone = one .. namesep .. first \n\t\t\t\tend\n\t\t\t\tif is_set(person.link) and person.link ~= control.page_name then\n\t\t\t\t\tone = \"[[\" .. person.link .. \"|\" .. one .. \"]]\"\t\t\t\t-- link author/editor if this page is not the author's/editor's page\n\t\t\t\tend\n\t\t\tend\n\t\t\ttable.insert( text, one )\n\t\t\ttable.insert( text, sep_one )\n\t\tend\n\tend\n\n\tlocal count = #text / 2;\t\t\t\t\t\t\t\t\t\t\t\t\t-- (number of names + number of separators) divided by 2\n\tif count > 0 then \n\t\tif count > 1 and is_set(lastauthoramp) and not etal then\n\t\t\ttext[#text-2] = \" & \";\t\t\t\t\t\t\t\t\t\t\t\t-- replace last separator with ampersand text\n\t\tend\n\t\ttext[#text] = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- erase the last separator\n\tend\n\t\n\tlocal result = table.concat(text)\t\t\t\t\t\t\t\t\t\t\t-- construct list\n\tif etal and is_set (result) then\t\t\t\t\t\t\t\t\t\t\t-- etal may be set by |display-authors=etal but we might not have a last-first list\n\t\tresult = result .. sep .. ' ' .. cfg.messages['et al'];\t\t\t\t\t-- we've go a last-first list and etal so add et al.\n\tend\n\t\n\treturn result, count\nend\n\n--[[--------------------------< A N C H O R _ I D >------------------------------------------------------------\n\nGenerates a CITEREF anchor ID if we have at least one name or a date.  Otherwise returns an empty string.\n\nnamelist is one of the contributor-, author-, or editor-name lists chosen in that order.  year is Year or anchor_year.\n\n]]\nlocal function anchor_id (namelist, year)\n\tlocal names={};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- a table for the one to four names and year\n\tfor i,v in ipairs (namelist) do\t\t\t\t\t\t\t\t\t\t\t\t-- loop through the list and take up to the first four last names\n\t\tnames[i] = v.last \n\t\tif i == 4 then break end\t\t\t\t\t\t\t\t\t\t\t\t-- if four then done\n\tend\n\ttable.insert (names, year);\t\t\t\t\t\t\t\t\t\t\t\t\t-- add the year at the end\n\tlocal id = table.concat(names);\t\t\t\t\t\t\t\t\t\t\t\t-- concatenate names and year for CITEREF id\n\tif is_set (id) then\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if concatenation is not an empty string\n\t\treturn \"CITEREF\" .. id;\t\t\t\t\t\t\t\t\t\t\t\t\t-- add the CITEREF portion\n\telse\n\t\treturn '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- return an empty string; no reason to include CITEREF id in this citation\n\tend\nend\n\n\n--[[--------------------------< N A M E _ H A S _ E T A L >----------------------------------------------------\n\nEvaluates the content of author and editor name parameters for variations on the theme of et al.  If found,\nthe et al. is removed, a flag is set to true and the function returns the modified name and the flag.\n\nThis function never sets the flag to false but returns it's previous state because it may have been set by\nprevious passes through this function or by the parameters |display-authors=etal or |display-editors=etal\n\n]]\n\nlocal function name_has_etal (name, etal, nocat)\n\n\tif is_set (name) then\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- name can be nil in which case just return\n\t\tlocal etal_pattern = \"[;,]? *[\\\"']*%f[%a][Ee][Tt] *[Aa][Ll][%.\\\"']*$\"\t-- variations on the 'et al' theme\n\t\tlocal others_pattern = \"[;,]? *%f[%a]and [Oo]thers\";\t\t\t\t\t-- and alternate to et al.\n\t\t\n\t\tif name:match (etal_pattern) then\t\t\t\t\t\t\t\t\t\t-- variants on et al.\n\t\t\tname = name:gsub (etal_pattern, '');\t\t\t\t\t\t\t\t-- if found, remove\n\t\t\tetal = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- set flag (may have been set previously here or by |display-authors=etal)\n\t\t\tif not nocat then\t\t\t\t\t\t\t\t\t\t\t\t\t-- no categorization for |vauthors=\n\t\t\t\tadd_maint_cat ('etal');\t\t\t\t\t\t\t\t\t\t\t-- and add a category if not already added\n\t\t\tend\n\t\telseif name:match (others_pattern) then\t\t\t\t\t\t\t\t\t-- if not 'et al.', then 'and others'?\n\t\t\tname = name:gsub (others_pattern, '');\t\t\t\t\t\t\t\t-- if found, remove\n\t\t\tetal = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- set flag (may have been set previously here or by |display-authors=etal)\n\t\t\tif not nocat then\t\t\t\t\t\t\t\t\t\t\t\t\t-- no categorization for |vauthors=\n\t\t\t\tadd_maint_cat ('etal');\t\t\t\t\t\t\t\t\t\t\t-- and add a category if not already added\n\t\t\tend\n\t\tend\n\tend\n\treturn name, etal;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- \nend\n\n--[[--------------------------< E X T R A C T _ N A M E S >----------------------------------------------------\nGets name list from the input arguments\n\nSearches through args in sequential order to find |lastn= and |firstn= parameters (or their aliases), and their matching link and mask parameters.\nStops searching when both |lastn= and |firstn= are not found in args after two sequential attempts: found |last1=, |last2=, and |last3= but doesn't\nfind |last4= and |last5= then the search is done.\n\nThis function emits an error message when there is a |firstn= without a matching |lastn=.  When there are 'holes' in the list of last names, |last1= and |last3=\nare present but |last2= is missing, an error message is emitted. |lastn= is not required to have a matching |firstn=.\n\nWhen an author or editor parameter contains some form of 'et al.', the 'et al.' is stripped from the parameter and a flag (etal) returned\nthat will cause list_people() to add the static 'et al.' text from Module:Citation/CS1/Configuration.  This keeps 'et al.' out of the \ntemplate's metadata.  When this occurs, the page is added to a maintenance category.\n\n]]\n\nlocal function extract_names(args, list_name)\n\tlocal names = {};\t\t\t-- table of names\n\tlocal last;\t\t\t\t\t-- individual name components\n\tlocal first;\n\tlocal link;\n\tlocal mask;\n\tlocal i = 1;\t\t\t\t-- loop counter/indexer\n\tlocal n = 1;\t\t\t\t-- output table indexer\n\tlocal count = 0;\t\t\t-- used to count the number of times we haven't found a |last= (or alias for authors, |editor-last or alias for editors)\n\tlocal etal=false;\t\t\t-- return value set to true when we find some form of et al. in an author parameter\n\n\tlocal err_msg_list_name = list_name:match (\"(%w+)List\") .. 's list';\t\t-- modify AuthorList or EditorList for use in error messages if necessary\n\twhile true do\n\t\tlast = select_one( args, cfg.aliases[list_name .. '-Last'], 'redundant_parameters', i );\t\t-- search through args for name components beginning at 1\n\t\tfirst = select_one( args, cfg.aliases[list_name .. '-First'], 'redundant_parameters', i );\n\t\tlink = select_one( args, cfg.aliases[list_name .. '-Link'], 'redundant_parameters', i );\n\t\tmask = select_one( args, cfg.aliases[list_name .. '-Mask'], 'redundant_parameters', i );\n\n\t\tlast, etal = name_has_etal (last, etal, false);\t\t\t\t\t\t\t\t-- find and remove variations on et al.\n\t\tfirst, etal = name_has_etal (first, etal, false);\t\t\t\t\t\t\t\t-- find and remove variations on et al.\n\n\t\tif first and not last then\t\t\t\t\t\t\t\t\t\t\t\t-- if there is a firstn without a matching lastn\n\t\t\ttable.insert( z.message_tail, { set_error( 'first_missing_last', {err_msg_list_name, i}, true ) } );\t-- add this error message\n\t\telseif not first and not last then\t\t\t\t\t\t\t\t\t\t-- if both firstn and lastn aren't found, are we done?\n\t\t\tcount = count + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t-- number of times we haven't found last and first\n\t\t\tif 2 <= count then\t\t\t\t\t\t\t\t\t\t\t\t\t-- two missing names and we give up\n\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- normal exit or there is a two-name hole in the list; can't tell which\n\t\t\tend\n\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- we have last with or without a first\n\t\t\tif is_set (link) and false == link_param_ok (link) then\t\t\t\t-- do this test here in case link is missing last\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'bad_paramlink', list_name:match (\"(%w+)List\"):lower() .. '-link' .. i )});\t\t\t-- url or wikilink in author link;\n\t\t\tend\n\t\t\tnames[n] = {last = last, first = first, link = link, mask = mask, corporate=false};\t-- add this name to our names list (corporate for |vauthors= only)\n\t\t\tn = n + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- point to next location in the names table\n\t\t\tif 1 == count then\t\t\t\t\t\t\t\t\t\t\t\t\t-- if the previous name was missing\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'missing_name', {err_msg_list_name, i-1}, true ) } );\t\t-- add this error message\n\t\t\tend\n\t\t\tcount = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- reset the counter, we're looking for two consecutive missing names\n\t\tend\n\t\ti = i + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- point to next args location\n\tend\n\t\n\treturn names, etal;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- all done, return our list of names\nend\n\n--[[--------------------------< B U I L D _ I D _ L I S T >--------------------------------------------------------\n\nPopulates ID table from arguments using configuration settings. Loops through cfg.id_handlers and searches args for\nany of the parameters listed in each cfg.id_handlers['...'].parameters.  If found, adds the parameter and value to\nthe identifier list.  Emits redundant error message is more than one alias exists in args\n\n]]\n\nlocal function extract_ids( args )\n\tlocal id_list = {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- list of identifiers found in args\n\tfor k, v in pairs( cfg.id_handlers ) do\t\t\t\t\t\t\t\t\t\t-- k is uc identifier name as index to cfg.id_handlers; e.g. cfg.id_handlers['ISBN'], v is a table\n\t\tv = select_one( args, v.parameters, 'redundant_parameters' );\t\t\t-- v.parameters is a table of aliases for k; here we pick one from args if present\n\t\tif is_set(v) then id_list[k] = v; end\t\t\t\t\t\t\t\t\t-- if found in args, add identifier to our list\n\tend\n\treturn id_list;\nend\n\n--[[--------------------------< B U I L D _ I D _ L I S T >--------------------------------------------------------\n\nTakes a table of IDs created by extract_ids() and turns it into a table of formatted ID outputs.\n\ninputs:\n\tid_list \u2013 table of identifiers built by extract_ids()\n\toptions \u2013 table of various template parameter values used to modify some manually handled identifiers\n\n]]\n\nlocal function build_id_list( id_list, options )\n\tlocal new_list, handler = {};\n\n\tfunction fallback(k) return { __index = function(t,i) return cfg.id_handlers[k][i] end } end;\n\t\n\tfor k, v in pairs( id_list ) do\t\t\t\t\t\t\t\t\t\t\t\t-- k is uc identifier name as index to cfg.id_handlers; e.g. cfg.id_handlers['ISBN'], v is a table\n\t\t-- fallback to read-only cfg\n\t\thandler = setmetatable( { ['id'] = v }, fallback(k) );\n\t\t\n\t\tif handler.mode == 'external' then\n\t\t\ttable.insert( new_list, {handler.label, external_link_id( handler ) } );\n\t\telseif handler.mode == 'internal' then\n\t\t\ttable.insert( new_list, {handler.label, internal_link_id( handler ) } );\n\t\telseif handler.mode ~= 'manual' then\n\t\t\terror( cfg.messages['unknown_ID_mode'] );\n\t\telseif k == 'DOI' then\n\t\t\ttable.insert( new_list, {handler.label, doi( v, options.DoiBroken ) } );\n\t\telseif k == 'ARXIV' then\n\t\t\ttable.insert( new_list, {handler.label, arxiv( v, options.Class ) } ); \n\t\telseif k == 'ASIN' then\n\t\t\ttable.insert( new_list, {handler.label, amazon( v, options.ASINTLD ) } ); \n\t\telseif k == 'LCCN' then\n\t\t\ttable.insert( new_list, {handler.label, lccn( v ) } );\n\t\telseif k == 'OL' or k == 'OLA' then\n\t\t\ttable.insert( new_list, {handler.label, openlibrary( v ) } );\n\t\telseif k == 'PMC' then\n\t\t\ttable.insert( new_list, {handler.label, pmc( v, options.Embargo ) } );\n\t\telseif k == 'PMID' then\n\t\t\ttable.insert( new_list, {handler.label, pmid( v ) } );\n\t\telseif k == 'ISMN' then\n\t\t\ttable.insert( new_list, {handler.label, ismn( v ) } );\n\t\telseif k == 'ISSN' then\n\t\t\ttable.insert( new_list, {handler.label, issn( v ) } );\n\t\telseif k == 'EISSN' then\n\t\t\ttable.insert( new_list, {handler.label, issn( v, true ) } );\t\t-- true distinguishes eissn from issn\n\t\telseif k == 'ISBN' then\n\t\t\tlocal ISBN = internal_link_id( handler );\n\t\t\tif not check_isbn( v ) and not is_set(options.IgnoreISBN) then\n\t\t\t\tISBN = ISBN .. set_error( 'bad_isbn', {}, false, \" \", \"\" );\n\t\t\tend\n\t\t\ttable.insert( new_list, {handler.label, ISBN } );\t\t\t\t\n\t\telseif k == 'USENETID' then\n\t\t\ttable.insert( new_list, {handler.label, message_id( v ) } );\n\t\telse\n\t\t\terror( cfg.messages['unknown_manual_ID'] );\n\t\tend\n\tend\n\t\n\tfunction comp( a, b )\t-- used in following table.sort()\n\t\treturn a[1] < b[1];\n\tend\n\t\n\ttable.sort( new_list, comp );\n\tfor k, v in ipairs( new_list ) do\n\t\tnew_list[k] = v[2];\n\tend\n\t\n\treturn new_list;\nend\n  \n\n--[[--------------------------< C O I N S _ C L E A N U P >----------------------------------------------------\n\nCleanup parameter values for the metadata by removing or replacing invisible characters and certain html entities.\n\n2015-12-10: there is a bug in mw.text.unstripNoWiki ().  It replaced math stripmarkers with the appropriate content\nwhen it shouldn't.  See https://phabricator.wikimedia.org/T121085 and Wikipedia_talk:Lua#stripmarkers_and_mw.text.unstripNoWiki.28.29\n\nTODO: move the replacement patterns and replacement values into a table in /Configuration similar to the invisible\ncharacters table?\n]]\n\nlocal function coins_cleanup (value)\n\tvalue = mw.text.unstripNoWiki (value);\t\t\t\t\t\t\t\t\t\t-- replace nowiki stripmarkers with their content\n\tvalue = value:gsub ('<span class=\"nowrap\" style=\"padding%-left:0%.1em;\">&#39;s</span>', \"'s\");\t-- replace {{'s}} template with simple apostrophe-s\n\tvalue = value:gsub ('&zwj;\\226\\128\\138\\039\\226\\128\\139', \"'\");\t\t\t\t-- replace {{'}} with simple apostrophe\n\tvalue = value:gsub ('\\226\\128\\138\\039\\226\\128\\139', \"'\");\t\t\t\t\t-- replace {{'}} with simple apostrophe (as of 2015-12-11)\n\tvalue = value:gsub ('&nbsp;', ' ');\t\t\t\t\t\t\t\t\t\t\t-- replace &nbsp; entity with plain space\n\tvalue = value:gsub ('\\226\\128\\138', ' ');\t\t\t\t\t\t\t\t\t-- replace hair space with plain space\n\tvalue = value:gsub ('&zwj;', '');\t\t\t\t\t\t\t\t\t\t\t-- remove &zwj; entities\n\tvalue = value:gsub ('[\\226\\128\\141\\226\\128\\139]', '')\t\t\t\t\t\t-- remove zero-width joiner, zero-width space\n\tvalue = value:gsub ('[\\194\\173\\009\\010\\013]', ' ');\t\t\t\t\t\t\t-- replace soft hyphen, horizontal tab, line feed, carriage return with plain space\n\treturn value;\nend\n\n\n--[[--------------------------< C O I N S >--------------------------------------------------------------------\n\nCOinS metadata (see <http://ocoins.info/>) allows automated tools to parse the citation information.\n\n]]\n\nlocal function COinS(data, class)\n\tif 'table' ~= type(data) or nil == next(data) then\n\t\treturn '';\n\tend\n\n\tfor k, v in pairs (data) do\t\t\t\t\t\t\t\t\t\t\t\t\t-- spin through all of the metadata parameter values\n\t\tif 'ID_list' ~= k and 'Authors' ~= k then\t\t\t\t\t\t\t\t-- except the ID_list and Author tables (author nowiki stripmarker done when Author table processed)\n\t\t\tdata[k] = coins_cleanup (v);\n\t\tend\n\tend\n\n\tlocal ctx_ver = \"Z39.88-2004\";\n\t\n\t-- treat table strictly as an array with only set values.\n\tlocal OCinSoutput = setmetatable( {}, {\n\t\t__newindex = function(self, key, value)\n\t\t\tif is_set(value) then\n\t\t\t\trawset( self, #self+1, table.concat{ key, '=', mw.uri.encode( remove_wiki_link( value ) ) } );\n\t\t\tend\n\t\tend\n\t});\n\t\n\tif in_array (class, {'arxiv', 'journal', 'news'}) or (in_array (class, {'conference', 'interview', 'map', 'press release', 'web'}) and is_set(data.Periodical)) or \n\t\t('citation' == class and is_set(data.Periodical) and not is_set (data.Encyclopedia)) then\n\t\t\tOCinSoutput.rft_val_fmt = \"info:ofi/fmt:kev:mtx:journal\";\t\t\t-- journal metadata identifier\n\t\t\tif 'arxiv' == class then\t\t\t\t\t\t\t\t\t\t\t-- set genre according to the type of citation template we are rendering\n\t\t\t\tOCinSoutput[\"rft.genre\"] = \"preprint\";\t\t\t\t\t\t\t-- cite arxiv\n\t\t\telseif 'conference' == class then\n\t\t\t\tOCinSoutput[\"rft.genre\"] = \"conference\";\t\t\t\t\t\t-- cite conference (when Periodical set)\n\t\t\telseif 'web' == class then\n\t\t\t\tOCinSoutput[\"rft.genre\"] = \"unknown\";\t\t\t\t\t\t\t-- cite web (when Periodical set)\n\t\t\telse\n\t\t\t\tOCinSoutput[\"rft.genre\"] = \"article\";\t\t\t\t\t\t\t-- journal and other 'periodical' articles\n\t\t\tend\n\t\t\tOCinSoutput[\"rft.jtitle\"] = data.Periodical;\t\t\t\t\t\t-- journal only\n\t\t\tif is_set (data.Map) then\n\t\t\t\tOCinSoutput[\"rft.atitle\"] = data.Map;\t\t\t\t\t\t\t-- for a map in a periodical\n\t\t\telse\n\t\t\t\tOCinSoutput[\"rft.atitle\"] = data.Title;\t\t\t\t\t\t\t-- all other 'periodical' article titles\n\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- these used onlu for periodicals\n\t\t\tOCinSoutput[\"rft.ssn\"] = data.Season;\t\t\t\t\t\t\t\t-- keywords: winter, spring, summer, fall\n\t\t\tOCinSoutput[\"rft.chron\"] = data.Chron;\t\t\t\t\t\t\t\t-- free-form date components\n\t\t\tOCinSoutput[\"rft.volume\"] = data.Volume;\t\t\t\t\t\t\t-- does not apply to books\n\t\t\tOCinSoutput[\"rft.issue\"] = data.Issue;\n\t\t\tOCinSoutput[\"rft.pages\"] = data.Pages;\t\t\t\t\t\t\t\t-- also used in book metadata\n\n\telseif 'thesis' ~= class then\t\t\t\t\t\t\t\t\t\t\t\t-- all others except cite thesis are treated as 'book' metadata; genre distinguishes\n\t\tOCinSoutput.rft_val_fmt = \"info:ofi/fmt:kev:mtx:book\";\t\t\t\t\t-- book metadata identifier\n\t\tif 'report' == class or 'techreport' == class then\t\t\t\t\t\t-- cite report and cite techreport\n\t\t\tOCinSoutput[\"rft.genre\"] = \"report\";\n\t\telseif 'conference' == class then\t\t\t\t\t\t\t\t\t\t-- cite conference when Periodical not set\n\t\t\tOCinSoutput[\"rft.genre\"] = \"conference\";\n\t\telseif in_array (class, {'book', 'citation', 'encyclopaedia', 'interview', 'map'}) then\n\t\t\tif is_set (data.Chapter) then\n\t\t\t\tOCinSoutput[\"rft.genre\"] = \"bookitem\";\n\t\t\t\tOCinSoutput[\"rft.atitle\"] = data.Chapter;\t\t\t\t\t\t-- book chapter, encyclopedia article, interview in a book, or map title\n\t\t\telse\n\t\t\t\tif 'map' == class or 'interview' == class then\n\t\t\t\t\tOCinSoutput[\"rft.genre\"] = 'unknown';\t\t\t\t\t\t-- standalone map or interview\n\t\t\t\telse\n\t\t\t\t\tOCinSoutput[\"rft.genre\"] = 'book';\t\t\t\t\t\t\t-- book and encyclopedia\n\t\t\t\tend\n\t\t\tend\n\t\telse\t--{'audio-visual', 'AV-media-notes', 'DVD-notes', 'episode', 'interview', 'mailinglist', 'map', 'newsgroup', 'podcast', 'press release', 'serial', 'sign', 'speech', 'web'}\n\t\t\tOCinSoutput[\"rft.genre\"] = \"unknown\";\n\t\tend\n\t\tOCinSoutput[\"rft.btitle\"] = data.Title;\t\t\t\t\t\t\t\t\t-- book only\n\t\tOCinSoutput[\"rft.place\"] = data.PublicationPlace;\t\t\t\t\t\t-- book only\n\t\tOCinSoutput[\"rft.series\"] = data.Series;\t\t\t\t\t\t\t\t-- book only\n\t\tOCinSoutput[\"rft.pages\"] = data.Pages;\t\t\t\t\t\t\t\t\t-- book, journal\n\t\tOCinSoutput[\"rft.edition\"] = data.Edition;\t\t\t\t\t\t\t\t-- book only\n\t\tOCinSoutput[\"rft.pub\"] = data.PublisherName;\t\t\t\t\t\t\t-- book and dissertation\n\t\t\n\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- cite thesis\n\t\tOCinSoutput.rft_val_fmt = \"info:ofi/fmt:kev:mtx:dissertation\";\t\t\t-- dissertation metadata identifier\n\t\tOCinSoutput[\"rft.title\"] = data.Title;\t\t\t\t\t\t\t\t\t-- dissertation (also patent but that is not yet supported)\n\t\tOCinSoutput[\"rft.degree\"] = data.Degree;\t\t\t\t\t\t\t\t-- dissertation only\n\t\tOCinSoutput['rft.inst'] = data.PublisherName;\t\t\t\t\t\t\t-- book and dissertation\n\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- and now common parameters (as much as possible)\n\tOCinSoutput[\"rft.date\"] = data.Date;\t\t\t\t\t\t\t\t\t\t-- book, journal, dissertation\n\t\n\tfor k, v in pairs( data.ID_list ) do\t\t\t\t\t\t\t\t\t\t-- what to do about these? For now assume that they are common to all?\n\t\tif k == 'ISBN' then v = clean_isbn( v ) end\n\t\tlocal id = cfg.id_handlers[k].COinS;\n\t\tif string.sub( id or \"\", 1, 4 ) == 'info' then\t\t\t\t\t\t\t-- for ids that are in the info:registry\n\t\t\tOCinSoutput[\"rft_id\"] = table.concat{ id, \"/\", v };\n\t\telseif string.sub (id or \"\", 1, 3 ) == 'rft' then\t\t\t\t\t\t-- for isbn, issn, eissn, etc that have defined COinS keywords\n\t\t\tOCinSoutput[ id ] = v;\n\t\telseif id then\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- when cfg.id_handlers[k].COinS is not nil\n\t\t\tOCinSoutput[\"rft_id\"] = table.concat{ cfg.id_handlers[k].prefix, v };\t-- others; provide a url\n\t\tend\n\tend\n\n--[[\t\n\tfor k, v in pairs( data.ID_list ) do\t\t\t\t\t\t\t\t\t\t-- what to do about these? For now assume that they are common to all?\n\t\tlocal id, value = cfg.id_handlers[k].COinS;\n\t\tif k == 'ISBN' then value = clean_isbn( v ); else value = v; end\n\t\tif string.sub( id or \"\", 1, 4 ) == 'info' then\n\t\t\tOCinSoutput[\"rft_id\"] = table.concat{ id, \"/\", v };\n\t\telse\n\t\t\tOCinSoutput[ id ] = value;\n\t\tend\n\tend\n]]\n\tlocal last, first;\n\tfor k, v in ipairs( data.Authors ) do\n\t\tlast, first = coins_cleanup (v.last), coins_cleanup (v.first or '');\t-- replace any nowiki strip markers, non-printing or invisible characers\n\t\tif k == 1 then\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- for the first author name only\n\t\t\tif is_set(last)  and is_set(first) then\t\t\t\t\t\t\t\t-- set these COinS values if |first= and |last= specify the first author name\n\t\t\t\tOCinSoutput[\"rft.aulast\"] = last;\t\t\t\t\t\t\t\t-- book, journal, dissertation\n\t\t\t\tOCinSoutput[\"rft.aufirst\"] = first;\t\t\t\t\t\t\t\t-- book, journal, dissertation\n\t\t\telseif is_set(last) then \n\t\t\t\tOCinSoutput[\"rft.au\"] = last;\t\t\t\t\t\t\t\t\t-- book, journal, dissertation -- otherwise use this form for the first name\n\t\t\tend\n\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- for all other authors\n\t\t\tif is_set(last) and is_set(first) then\n\t\t\t\tOCinSoutput[\"rft.au\"] = table.concat{ last, \", \", first };\t\t-- book, journal, dissertation\n\t\t\telseif is_set(last) then\n\t\t\t\tOCinSoutput[\"rft.au\"] = last;\t\t\t\t\t\t\t\t\t-- book, journal, dissertation\n\t\t\tend\n\t\tend\n\tend\n\n\tOCinSoutput.rft_id = data.URL;\n\tOCinSoutput.rfr_id = table.concat{ \"info:sid/\", mw.site.server:match( \"[^/]*$\" ), \":\", data.RawPage };\n\tOCinSoutput = setmetatable( OCinSoutput, nil );\n\t\n\t-- sort with version string always first, and combine.\n\ttable.sort( OCinSoutput );\n\ttable.insert( OCinSoutput, 1, \"ctx_ver=\" .. ctx_ver );  -- such as \"Z39.88-2004\"\n\treturn table.concat(OCinSoutput, \"&\");\nend\n\n\n--[[--------------------------< G E T _ I S O 6 3 9 _ C O D E >------------------------------------------------\n\nValidates language names provided in |language= parameter if not an ISO639-1 code.  Handles the special case that is Norwegian where\nISO639-1 code 'no' is mapped to language name 'Norwegian Bokm\u00e5l' by Extention:CLDR.\n\nReturns the language name and associated ISO639-1 code.  Because case of the source may be incorrect or different from the case that Wikimedia\nuses, the name comparisons are done in lower case and when a match is found, the Wikimedia version (assumed to be correct) is returned along\nwith the code.  When there is no match, we return the original language name string.\n\nmw.language.fetchLanguageNames() will return a list of languages that aren't part of ISO639-1. Names that aren't ISO639-1 but that are included\nin the list will be found if that name is provided in the |language= parameter.  For example, if |language=Samaritan Aramaic, that name will be\nfound with the associated code 'sam', not an ISO639-1 code.  When names are found and the associated code is not two characters, this function\nreturns only the Wikimedia language name.\n\nAdapted from code taken from Module:Check ISO 639-1.\n\n]]\n\nlocal function get_iso639_code (lang)\n\tif 'norwegian' == lang:lower() then\t\t\t\t\t\t\t\t\t\t\t-- special case related to Wikimedia remap of code 'no' at Extension:CLDR\n\t\treturn 'Norwegian', 'no';\t\t\t\t\t\t\t\t\t\t\t\t-- Make sure rendered version is properly capitalized\n\tend\n\t\n\tlocal languages = mw.language.fetchLanguageNames(mw.getContentLanguage():getCode(), 'all')\t\t\t\t-- get a list of language names known to Wikimedia\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- ('all' is required for North Ndebele, South Ndebele, and Ojibwa)\n\tlocal langlc = mw.ustring.lower(lang);\t\t\t\t\t\t\t\t\t\t-- lower case version for comparisons\n\t\n\tfor code, name in pairs(languages) do\t\t\t\t\t\t\t\t\t\t-- scan the list to see if we can find our language\n\t\tif langlc == mw.ustring.lower(name) then\n\t\t\tif 2 ~= code:len() then\t\t\t\t\t\t\t\t\t\t\t\t-- ISO639-1 codes only\n\t\t\t\treturn name;\t\t\t\t\t\t\t\t\t\t\t\t\t-- so return the name but not the code\n\t\t\tend\n\t\t\treturn name, code;\t\t\t\t\t\t\t\t\t\t\t\t\t-- found it, return name to ensure proper capitalization and the ISO639-1 code\n\t\tend\n\tend\n\treturn lang;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- not valid language; return language in original case and nil for ISO639-1 code\nend\n\n--[[--------------------------< L A N G U A G E _ P A R A M E T E R >------------------------------------------\n\nGet language name from ISO639-1 code value provided.  If a code is valid use the returned name; if not, then use the value that was provided with the language parameter.\n\nThere is an exception.  There are three ISO639-1 codes for Norewegian language variants.  There are two official variants: Norwegian Bokm\u00e5l (code 'nb') and\nNorwegian Nynorsk (code 'nn').  The third, code 'no',  is defined by ISO639-1 as 'Norwegian' though in Norway this is pretty much meaningless.  However, it appears\nthat on enwiki, editors are for the most part unaware of the nb and nn variants (compare page counts for these variants at Category:Articles with non-English-language external links.\n\nBecause Norwegian Bokm\u00e5l is the most common language variant, Media wiki has been modified to return Norwegian Bokm\u00e5l for ISO639-1 code 'no'. Here we undo that and\nreturn 'Norwegian' when editors use |language=no.  We presume that editors don't know about the variants or can't descriminate between them.\n\nSee Help talk:Citation Style_1#An ISO 639-1 language name test\n\nWhen |language= contains a valid ISO639-1 code, the page is assigned to the category for that code: Category:Norwegian-language sources (no) if\nthe page is a mainspace page and the ISO639-1 code is not 'en'.  Similarly, if the  parameter is |language=Norwegian, it will be categorized in the same way.\n\nThis function supports multiple languages in the form |language=nb, French, th where the language names or codes are separated from each other by commas.\n\n]]\n\nlocal function language_parameter (lang)\n\tlocal code;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- the ISO639-1 two character code\n\tlocal name;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- the language name\n\tlocal language_list = {};\t\t\t\t\t\t\t\t\t\t\t\t\t-- table of language names to be rendered\n\tlocal names_table = {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- table made from the value assigned to |language=\n\n\tnames_table = mw.text.split (lang, '%s*,%s*');\t\t\t\t\t\t\t\t-- names should be a comma separated list\n\n\tfor _, lang in ipairs (names_table) do\t\t\t\t\t\t\t\t\t\t-- reuse lang\n\n\t\tif lang:match ('^%a%a%-') or 2 == lang:len() then\t\t\t\t\t\t\t\t\t\t\t\t\t-- ISO639-1 language code are 2 characters (fetchLanguageName also supports 3 character codes)\n\t\t\tif lang:match ('^zh-') then\n\t\t\t\tname = mw.language.fetchLanguageName( lang:lower(), lang:lower() );\n\t\t\telse\n\t\t\t\tname = mw.language.fetchLanguageName( lang:lower(), mw.getContentLanguage():getCode() );\t\t\t-- get ISO 639-1 language name if Language is a proper code\n\t\t\tend\n\t\tend\n\t\n\t\tif is_set (name) then\t\t\t\t\t\t\t\t\t\t\t\t\t-- if Language specified a valid ISO639-1 code\n\t\t\tcode = lang:lower();\t\t\t\t\t\t\t\t\t\t\t\t-- save it\n\t\telse\n\t\t\tname, code = get_iso639_code (lang);\t\t\t\t\t\t\t\t-- attempt to get code from name (assign name here so that we are sure of proper capitalization)\n\t\tend\n\t\n\t\tif is_set (code) then\n\t\t\tif 'no' == code then name = 'Norwegian' end;\t\t\t\t\t\t-- override wikimedia when code is 'no'\n\t\t\tif 'zh' ~= code and not code:match ('^zh-') then\t\t\t\t\t\t\t\t\t\t\t\t-- English not the language\n\t\t\t\tadd_prop_cat ('foreign_lang_source', {name, code})\n\t\t\tend\n\t\telse\n\t\t\tadd_maint_cat ('unknown_lang');\t\t\t\t\t\t\t\t\t\t-- add maint category if not already added\n\t\tend\n\t\t\n\t\ttable.insert (language_list, name);\n\t\tname = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- so we can reuse it\n\tend\n\t\n\tcode = #language_list\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- reuse code as number of languages in the list\n\tif 2 >= code then\n\t\tname = table.concat (language_list, ' and ')\t\t\t\t\t\t\t-- insert '<space>and<space>' between two language names\n\telseif 2 < code then\n\t\tlanguage_list[code] = 'and ' .. language_list[code];\t\t\t\t\t-- prepend last name with 'and<space>'\n\t\tname = table.concat (language_list, ', ')\t\t\t\t\t\t\t\t-- and concatenate with '<comma><space>' separators\n\tend\n\treturn (\" \" .. wrap_msg ('language', name));\t\t\t\t\t\t\t\t-- otherwise wrap with '(in ...)'\nend\n\n--[[--------------------------< S E T _ C S 1 _ S T Y L E >----------------------------------------------------\n\nSet style settings for CS1 citation templates. Returns separator and postscript settings\n\n]]\n\nlocal function set_cs1_style (ps)\n\tif not is_set (ps) then\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unless explicitely set to something\n\t\tps = '.';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- terminate the rendered citation with a period\n\tend\n\treturn '.', ps;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- separator is a full stop\nend\n\n--[[--------------------------< S E T _ C S 2 _ S T Y L E >----------------------------------------------------\n\nSet style settings for CS2 citation templates. Returns separator, postscript, ref settings\n\n]]\n\nlocal function set_cs2_style (ps, ref)\n\tif not is_set (ps) then\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if |postscript= has not been set, set cs2 default\n\t\tps = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- make sure it isn't nil\n\tend\n\tif not is_set (ref) then\t\t\t\t\t\t\t\t\t\t\t\t\t-- if |ref= is not set\n\t\tref = \"harv\";\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- set default |ref=harv\n\tend\n\treturn ',', ps, ref;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- separator is a comma\nend\n\n--[[--------------------------< G E T _ S E T T I N G S _ F R O M _ C I T E _ C L A S S >----------------------\n\nWhen |mode= is not set or when its value is invalid, use config.CitationClass and parameter values to establish\nrendered style.\n\n]]\n\nlocal function get_settings_from_cite_class (ps, ref, cite_class)\n\tlocal sep;\n\tif (cite_class == \"citation\") then\t\t\t\t\t\t\t\t\t\t\t-- for citation templates (CS2)\n\t\tsep, ps, ref = set_cs2_style (ps, ref);\n\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- not a citation template so CS1\n\t\tsep, ps = set_cs1_style (ps);\n\tend\n\n\treturn sep, ps, ref\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- return them all\nend\n\n--[[--------------------------< S E T _ S T Y L E >------------------------------------------------------------\n\nEstablish basic style settings to be used when rendering the citation.  Uses |mode= if set and valid or uses\nconfig.CitationClass from the template's #invoke: to establish style.\n\n]]\n\nlocal function set_style (mode, ps, ref, cite_class)\n\tlocal sep;\n\tif 'cs2' == mode then\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if this template is to be rendered in CS2 (citation) style\n\t\tsep, ps, ref = set_cs2_style (ps, ref);\n\telseif 'cs1' == mode then\t\t\t\t\t\t\t\t\t\t\t\t\t-- if this template is to be rendered in CS1 (cite xxx) style\n\t\tsep, ps = set_cs1_style (ps);\n\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- anything but cs1 or cs2\n\t\tsep, ps, ref = get_settings_from_cite_class (ps, ref, cite_class);\t\t-- get settings based on the template's CitationClass\n\tend\n\tif 'none' == ps:lower() then\t\t\t\t\t\t\t\t\t\t\t\t-- if assigned value is 'none' then\n\t\tps = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- set to empty string\n\tend\n\t\n\treturn sep, ps, ref\nend\n\n--[=[-------------------------< I S _ P D F >------------------------------------------------------------------\n\nDetermines if a url has the file extension that is one of the pdf file extensions used by [[MediaWiki:Common.css]] when\napplying the pdf icon to external links.\n\nreturns true if file extension is one of the recognized extension, else false\n\n]=]\n\nlocal function is_pdf (url)\n\treturn url:match ('%.pdf[%?#]?') or url:match ('%.PDF[%?#]?');\nend\n\n--[[--------------------------< S T Y L E _ F O R M A T >------------------------------------------------------\n\nApplies css style to |format=, |chapter-format=, etc.  Also emits an error message if the format parameter does\nnot have a matching url parameter.  If the format parameter is not set and the url contains a file extension that\nis recognized as a pdf document by MediaWiki's commons.css, this code will set the format parameter to (PDF) with\nthe appropriate styling.\n\n]]\n\nlocal function style_format (format, url, fmt_param, url_param)\n\tif is_set (format) then\n\t\tformat = wrap_style ('format', format);\t\t\t\t\t\t\t\t\t-- add leading space, parenthases, resize\n\t\tif not is_set (url) then\n\t\t\tformat = format .. set_error( 'format_missing_url', {fmt_param, url_param} );\t-- add an error message\n\t\tend\n\telseif is_pdf (url) then\t\t\t\t\t\t\t\t\t\t\t\t\t-- format is not set so if url is a pdf file then\n\t\tformat = wrap_style ('format', 'PDF');\t\t\t\t\t\t\t\t\t-- set format to pdf\n\telse\n\t\tformat = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- empty string for concatenation\n\tend\n\treturn format;\nend\n\n--[[--------------------------< G E T _ D I S P L A Y _ A U T H O R S _ E D I T O R S >------------------------\n\nReturns a number that may or may not limit the length of the author or editor name lists.\n\nWhen the value assigned to |display-authors= is a number greater than or equal to zero, return the number and\nthe previous state of the 'etal' flag (false by default but may have been set to true if the name list contains\nsome variant of the text 'et al.').\n\nWhen the value assigned to |display-authors= is the keyword 'etal', return a number that is one greater than the\nnumber of authors in the list and set the 'etal' flag true.  This will cause the list_people() to display all of\nthe names in the name list followed by 'et al.'\n\nIn all other cases, returns nil and the previous state of the 'etal' flag.\n\n]]\n\nlocal function get_display_authors_editors (max, count, list_name, etal)\n\tif is_set (max) then\n\t\tif 'etal' == max:lower():gsub(\"[ '%.]\", '') then\t\t\t\t\t\t-- the :gsub() portion makes 'etal' from a variety of 'et al.' spellings and stylings\n\t\t\tmax = count + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t-- number of authors + 1 so display all author name plus et al.\n\t\t\tetal = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- overrides value set by extract_names()\n\t\telseif max:match ('^%d+$') then\t\t\t\t\t\t\t\t\t\t\t-- if is a string of numbers\n\t\t\tmax = tonumber (max);\t\t\t\t\t\t\t\t\t\t\t\t-- make it a number\n\t\t\tif max >= count and 'authors' == list_name then\t-- AUTHORS ONLY\t\t-- if |display-xxxxors= value greater than or equal to number of authors/editors\n\t\t\t\tadd_maint_cat ('disp_auth_ed', list_name);\n\t\t\tend\n\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- not a valid keyword or number\n\t\t\ttable.insert( z.message_tail, { set_error( 'invalid_param_val', {'display-' .. list_name, max}, true ) } );\t\t-- add error message\n\t\t\tmax = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset\n\t\tend\n\telseif 'authors' == list_name then\t\t-- AUTHORS ONLY\tneed to clear implicit et al category\n\t\tmax = count + 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- number of authors + 1\n\tend\n\t\n\treturn max, etal;\nend\n\n--[[--------------------------< E X T R A _ T E X T _ I N _ P A G E _ C H E C K >------------------------------\n\nAdds page to Category:CS1 maint: extra text if |page= or |pages= has what appears to be some form of p. or pp. \nabbreviation in the first characters of the parameter content.\n\ncheck Page and Pages for extraneous p, p., pp, and pp. at start of parameter value:\n\tgood pattern: '^P[^%.P%l]' matches when |page(s)= begins PX or P# but not Px where x and X are letters and # is a dgiit\n\tbad pattern: '^[Pp][Pp]' matches matches when |page(s)= begins pp or pP or Pp or PP\n\n]]\n\nlocal function extra_text_in_page_check (page)\n--\tlocal good_pattern = '^P[^%.P%l]';\n\tlocal good_pattern = '^P[^%.Pp]';\t\t\t\t\t\t\t\t\t\t\t-- ok to begin with uppercase P: P7 (pg 7 of section P) but not p123 (page 123) TODO: add Gg for PG or Pg?\n--\tlocal bad_pattern = '^[Pp][Pp]';\n\tlocal bad_pattern = '^[Pp]?[Pp]%.?[ %d]';\n\n\tif not page:match (good_pattern) and (page:match (bad_pattern) or  page:match ('^[Pp]ages?')) then\n\t\tadd_maint_cat ('extra_text');\n\tend\n--\t\tif Page:match ('^[Pp]?[Pp]%.?[ %d]') or  Page:match ('^[Pp]ages?[ %d]') or\n--\t\t\tPages:match ('^[Pp]?[Pp]%.?[ %d]') or  Pages:match ('^[Pp]ages?[ %d]') then\n--\t\t\t\tadd_maint_cat ('extra_text');\n--\t\tend\nend\n\n\n--[[--------------------------< P A R S E _ V A U T H O R S _ V E D I T O R S >--------------------------------\n\nThis function extracts author / editor names from |vauthors= or |veditors= and finds matching |xxxxor-maskn= and\n|xxxxor-linkn= in args.  It then returns a table of assembled names just as extract_names() does.\n\nAuthor / editor names in |vauthors= or |veditors= must be in Vancouver system style. Corporate or institutional names\nmay sometimes be required and because such names will often fail the is_good_vanc_name() and other format compliance\ntests, are wrapped in doubled paranethese ((corporate name)) to suppress the format tests.\n\nThis function sets the vancouver error when a reqired comma is missing and when there is a space between an author's initials.\n\n]]\n\nlocal function parse_vauthors_veditors (args, vparam, list_name)\n\tlocal names = {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- table of names assembled from |vauthors=, |author-maskn=, |author-linkn=\n\tlocal v_name_table = {};\n\tlocal etal = false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- return value set to true when we find some form of et al. vauthors parameter\n\tlocal last, first, link, mask;\n\tlocal corporate = false;\n\n\tvparam, etal = name_has_etal (vparam, etal, true);\t\t\t\t\t\t\t-- find and remove variations on et al. do not categorize (do it here because et al. might have a period)\n\tif vparam:find ('%[%[') or vparam:find ('%]%]')\tthen\t\t\t\t\t\t-- no wikilinking vauthors names\n\t\tadd_vanc_error ();\n\tend\n\tv_name_table = mw.text.split(vparam, \"%s*,%s*\")\t\t\t\t\t\t\t\t-- names are separated by commas\n\n\tfor i, v_name in ipairs(v_name_table) do\n\t\tif v_name:match ('^%(%(.+%)%)$') then\t\t\t\t\t\t\t\t\t-- corporate authors are wrapped in doubled parenthese to supress vanc formatting and error detection\n\t\t\tfirst = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- set to empty string for concatenation and because it may have been set for previous author/editor\n\t\t\tlast = v_name:match ('^%(%((.+)%)%)$')\n\t\t\tcorporate = true;\n\t\telseif string.find(v_name, \"%s\") then\n\t\t    lastfirstTable = {}\n\t\t    lastfirstTable = mw.text.split(v_name, \"%s\")\n\t\t    first = table.remove(lastfirstTable);\t\t\t\t\t\t\t\t-- removes and returns value of last element in table which should be author intials\n\t\t    last  = table.concat(lastfirstTable, \" \")\t\t\t\t\t\t\t-- returns a string that is the concatenation of all other names that are not initials\n\t\t    if mw.ustring.match (last, '%a+%s+%u+%s+%a+') or mw.ustring.match (v_name, ' %u %u$') then\n\t\t\t\tadd_vanc_error ();\t\t\t\t\t\t\t\t\t\t\t\t-- matches last II last; the case when a comma is missing or a space between two intiials\n\t\t\tend\n\t\telse\n\t\t\tfirst = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- set to empty string for concatenation and because it may have been set for previous author/editor\n\t\t\tlast = v_name;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- last name or single corporate name?  Doesn't support multiword corporate names? do we need this?\n\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif is_set (first) and not mw.ustring.match (first, \"^%u?%u$\") then\t\t-- first shall contain one or two upper-case letters, nothing else\n\t\t\tadd_vanc_error ();\n\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- this from extract_names ()\n\t\tlink = select_one( args, cfg.aliases[list_name .. '-Link'], 'redundant_parameters', i );\n\t\tmask = select_one( args, cfg.aliases[list_name .. '-Mask'], 'redundant_parameters', i );\n\t\tnames[i] = {last = last, first = first, link = link, mask = mask, corporate=corporate};\t\t-- add this assembled name to our names list\n\tend\n\treturn names, etal;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- all done, return our list of names\nend\n\n--[[--------------------------< S E L E C T _ A U T H O R _ E D I T O R _ S O U R C E >------------------------\n\nSelect one of |authors=, |authorn= / |lastn / firstn=, or |vauthors= as the source of the author name list or\nselect one of |editors=, |editorn= / editor-lastn= / |editor-firstn= or |veditors= as the source of the editor name list.\n\nOnly one of these appropriate three will be used.  The hierarchy is: |authorn= (and aliases) highest and |authors= lowest and\nsimilarly, |editorn= (and aliases) highest and |editors= lowest\n\nWhen looking for |authorn= / |editorn= parameters, test |xxxxor1= and |xxxxor2= (and all of their aliases); stops after the second\ntest which mimicks the test used in extract_names() when looking for a hole in the author name list.  There may be a better\nway to do this, I just haven't discovered what that way is.\n\nEmits an error message when more than one xxxxor name source is provided.\n\nIn this function, vxxxxors = vauthors or veditors; xxxxors = authors or editors as appropriate.\n\n]]\n\nlocal function select_author_editor_source (vxxxxors, xxxxors, args, list_name)\nlocal lastfirst = false;\n\tif select_one( args, cfg.aliases[list_name .. '-Last'], 'none', 1 ) or\t\t-- do this twice incase we have a first 1 without a last1\n\t\tselect_one( args, cfg.aliases[list_name .. '-Last'], 'none', 2 ) then\n\t\t\tlastfirst=true;\n\tend\n\n\tif (is_set (vxxxxors) and true == lastfirst) or\t\t\t\t\t\t\t\t-- these are the three error conditions\n\t\t(is_set (vxxxxors) and is_set (xxxxors)) or\n\t\t(true == lastfirst and is_set (xxxxors)) then\n\t\t\tlocal err_name;\n\t\t\tif 'AuthorList' == list_name then\t\t\t\t\t\t\t\t\t-- figure out which name should be used in error message\n\t\t\t\terr_name = 'author';\n\t\t\telse\n\t\t\t\terr_name = 'editor';\n\t\t\tend\n\t\t\ttable.insert( z.message_tail, { set_error( 'redundant_parameters',\n\t\t\t\t{err_name .. '-name-list parameters'}, true ) } );\t\t\t\t-- add error message\n\tend\n\n\tif true == lastfirst then return 1 end;\t\t\t\t\t\t\t\t\t\t-- return a number indicating which author name source to use\n\tif is_set (vxxxxors) then return 2 end;\n\tif is_set (xxxxors) then return 3 end;\n\treturn 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- no authors so return 1; this allows missing author name test to run in case there is a first without last \nend\n\n\n--[[--------------------------< I S _ V A L I D _ P A R A M E T E R _ V A L U E >------------------------------\n\nThis function is used to validate a parameter's assigned value for those parameters that have only a limited number\nof allowable values (yes, y, true, no, etc).  When the parameter value has not been assigned a value (missing or empty\nin the source template) the function refurns true.  If the parameter value is one of the list of allowed values returns\ntrue; else, emits an error message and returns false.\n\n]]\n\nlocal function is_valid_parameter_value (value, name, possible)\n\tif not is_set (value) then\n\t\treturn true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- an empty parameter is ok\n\telseif in_array(value:lower(), possible) then\n\t\treturn true;\n\telse\n\t\ttable.insert( z.message_tail, { set_error( 'invalid_param_val', {name, value}, true ) } );\t-- not an allowed value so add error message\n\t\treturn false\n\tend\nend\n\n\n--[[--------------------------< T E R M I N A T E _ N A M E _ L I S T >----------------------------------------\n\nThis function terminates a name list (author, contributor, editor) with a separator character (sepc) and a space\nwhen the last character is not a sepc character or when the last three characters are not sepc followed by two\nclosing square brackets (close of a wikilink).  When either of these is true, the name_list is terminated with a\nsingle space character.\n\n]]\n\nlocal function terminate_name_list (name_list, sepc)\n\tif (string.sub (name_list,-1,-1) == sepc) or (string.sub (name_list,-3,-1) == sepc .. ']]') then\t-- if last name in list ends with sepc char\n\t\treturn name_list .. \" \";\t\t\t\t\t\t\t\t\t\t\t\t-- don't add another\n\telse\n\t\treturn name_list .. sepc .. ' ';\t\t\t\t\t\t\t\t\t\t-- otherwise terninate the name list\n\tend\nend\n\n\n--[[-------------------------< F O R M A T _ V O L U M E _ I S S U E >----------------------------------------\n\nreturns the concatenation of the formatted volume and issue parameters as a single string; or formatted volume\nor formatted issue, or an empty string if neither are set.\n\n]]\n\t\nlocal function format_volume_issue (volume, issue, cite_class, origin, sepc, lower)\n\tif not is_set (volume) and not is_set (issue) then\n\t\treturn '';\n\tend\n\t\n\tif 'magazine' == cite_class or (in_array (cite_class, {'citation', 'map'}) and 'magazine' == origin) then\n\t\tif is_set (volume) and is_set (issue) then\n\t\t\treturn wrap_msg ('vol-no', {sepc, volume, issue}, lower);\n\t\telseif is_set (volume) then\n\t\t\treturn wrap_msg ('vol', {sepc, volume}, lower);\n\t\telse\n\t\t\treturn wrap_msg ('issue', {sepc, issue}, lower);\n\t\tend\n\tend\n\t\n\tlocal vol = '';\n\t\t\n\tif is_set (volume) then\n\t\tif (6 < mw.ustring.len(volume)) then\n\t\t\tvol = substitute (cfg.messages['j-vol'], {sepc, volume});\n\t\telse\n\t\t\tvol = wrap_style ('vol-bold', hyphen_to_dash(volume));\n\t\tend\n\tend\n\tif is_set (issue) then\n\t\treturn vol .. substitute (cfg.messages['j-issue'], issue);\n\tend\n\treturn vol;\nend\n\n\n--[[-------------------------< F O R M A T _ P A G E S _ S H E E T S >-----------------------------------------\n\nadds static text to one of |page(s)= or |sheet(s)= values and returns it with all of the others set to empty strings.\nThe return order is:\n\tpage, pages, sheet, sheets\n\nSingular has priority over plural when both are provided.\n\n]]\n\nlocal function format_pages_sheets (page, pages, sheet, sheets, cite_class, origin, sepc, nopp, lower)\n\tif 'map' == cite_class then\t\t\t\t\t\t\t\t\t\t\t\t\t-- only cite map supports sheet(s) as in-source locators\n\t\tif is_set (sheet) then\n\t\t\tif 'journal' == origin then\n\t\t\t\treturn '', '', wrap_msg ('j-sheet', sheet, lower), '';\n\t\t\telse\n\t\t\t\treturn '', '', wrap_msg ('sheet', {sepc, sheet}, lower), '';\n\t\t\tend\n\t\telseif is_set (sheets) then\n\t\t\tif 'journal' == origin then\n\t\t\t\treturn '', '', '', wrap_msg ('j-sheets', sheets, lower);\n\t\t\telse\n\t\t\t\treturn '', '', '', wrap_msg ('sheets', {sepc, sheets}, lower);\n\t\t\tend\n\t\tend\n\tend\n\n\tlocal is_journal = 'journal' == cite_class or (in_array (cite_class, {'citation', 'map'}) and 'journal' == origin);\n\n\tif is_set (page) then\n\t\tif is_journal then\n\t\t\treturn substitute (cfg.messages['j-page(s)'], page), '', '', '';\n\t\telseif not nopp then\n\t\t\treturn substitute (cfg.messages['p-prefix'], {sepc, page}), '', '', '';\n\t\telse\n\t\t\treturn substitute (cfg.messages['nopp'], {sepc, page}), '', '', '';\n\t\tend\n\telseif is_set(pages) then\n\t\tif is_journal then\n\t\t\treturn substitute (cfg.messages['j-page(s)'], pages), '', '', '';\n\t\telseif tonumber(pages) ~= nil and not nopp then\t\t\t\t\t\t\t\t\t\t-- if pages is only digits, assume a single page number\n\t\t\treturn '', substitute (cfg.messages['p-prefix'], {sepc, pages}), '', '';\n\t\telseif not nopp then\n\t\t\treturn '', substitute (cfg.messages['pp-prefix'], {sepc, pages}), '', '';\n\t\telse\n\t\t\treturn '', substitute (cfg.messages['nopp'], {sepc, pages}), '', '';\n\t\tend\n\tend\n\t\n\treturn '', '', '', '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- return empty strings\nend\n\n--[[--------------------------< C I T A T I O N 0 >------------------------------------------------------------\n\nThis is the main function doing the majority of the citation formatting.\n\n]]\n\nlocal function citation0( config, args)\n\t--[[ \n\tLoad Input Parameters\n\tThe argument_wrapper facilitates the mapping of multiple aliases to single internal variable.\n\t]]\n\tlocal A = argument_wrapper( args );\n\tlocal i \n\n\t-- Pick out the relevant fields from the arguments.  Different citation templates\n\t-- define different field names for the same underlying things.\t\n\tlocal author_etal;\n\tlocal a\t= {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- authors list from |lastn= / |firstn= pairs or |vauthors=\n\tlocal Authors;\n\tlocal NameListFormat = A['NameListFormat'];\n\n\tdo\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- to limit scope of selected\n\t\tlocal selected = select_author_editor_source (A['Vauthors'], A['Authors'], args, 'AuthorList');\n\t\tif 1 == selected then\n\t\t\ta, author_etal = extract_names (args, 'AuthorList');\t\t\t\t-- fetch author list from |authorn= / |lastn= / |firstn=, |author-linkn=, and |author-maskn=\n\t\telseif 2 == selected then\n\t\t\tNameListFormat = 'vanc';\t\t\t\t\t\t\t\t\t\t\t-- override whatever |name-list-format= might be\n\t\t\ta, author_etal = parse_vauthors_veditors (args, args.vauthors, 'AuthorList');\t-- fetch author list from |vauthors=, |author-linkn=, and |author-maskn=\n\t\telseif 3 == selected then\n\t\t\tAuthors = A['Authors'];\t\t\t\t\t\t\t\t\t\t\t\t-- use content of |authors=\n\t\tend\n\tend\n\n\tlocal Coauthors = A['Coauthors'];\n\tlocal Others = A['Others'];\n\n\tlocal editor_etal;\n\tlocal e\t= {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- editors list from |editor-lastn= / |editor-firstn= pairs or |veditors=\n\tlocal Editors;\n\n\tdo\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- to limit scope of selected\n\t\tlocal selected = select_author_editor_source (A['Veditors'], A['Editors'], args, 'EditorList');\n\t\tif 1 == selected then\n\t\t\te, editor_etal = extract_names (args, 'EditorList');\t\t\t\t-- fetch editor list from |editorn= / |editor-lastn= / |editor-firstn=, |editor-linkn=, and |editor-maskn=\n\t\telseif 2 == selected then\n\t\t\tNameListFormat = 'vanc';\t\t\t\t\t\t\t\t\t\t\t-- override whatever |name-list-format= might be\n\t\t\te, editor_etal = parse_vauthors_veditors (args, args.veditors, 'EditorList');\t-- fetch editor list from |veditors=, |editor-linkn=, and |editor-maskn=\n\t\telseif 3 == selected then\n\t\t\tEditors = A['Editors'];\t\t\t\t\t\t\t\t\t\t\t\t-- use content of |editors=\n\t\tend\n\tend\n\n\tlocal t = {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- translators list from |translator-lastn= / translator-firstn= pairs\n\tlocal Translators;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- assembled translators name list\n\tt = extract_names (args, 'TranslatorList');\t\t\t\t\t\t\t\t\t-- fetch translator list from |translatorn= / |translator-lastn=, -firstn=, -linkn=, -maskn=\n\t\n\tlocal c = {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- contributors list from |contributor-lastn= / contributor-firstn= pairs\n\tlocal Contributors;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- assembled contributors name list\n\tlocal Contribution = A['Contribution'];\n\tif in_array(config.CitationClass, {\"book\",\"citation\"}) and not is_set(A['Periodical']) then\t-- |contributor= and |contribution= only supported in book cites\n\t\tc = extract_names (args, 'ContributorList');\t\t\t\t\t\t\t-- fetch contributor list from |contributorn= / |contributor-lastn=, -firstn=, -linkn=, -maskn=\n\t\t\n\t\tif 0 < #c then\n\t\t\tif not is_set (Contribution) then\t\t\t\t\t\t\t\t\t-- |contributor= requires |contribution=\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'contributor_missing_required_param', 'contribution')});\t-- add missing contribution error message\n\t\t\t\tc = {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- blank the contributors' table; it is used as a flag later\n\t\t\tend\n\t\t\tif 0 == #a then\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- |contributor= requires |author=\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'contributor_missing_required_param', 'author')});\t-- add missing author error message\n\t\t\t\tc = {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- blank the contributors' table; it is used as a flag later\n\t\t\tend\n\t\tend\n\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if not a book cite\n\t\tif select_one (args, cfg.aliases['ContributorList-Last'], 'redundant_parameters', 1 ) then\t-- are there contributor name list parameters?\n\t\t\ttable.insert( z.message_tail, { set_error( 'contributor_ignored')});\t-- add contributor ignored error message\n\t\tend\n\t\tContribution = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset\n\tend\n\n\tif not is_valid_parameter_value (NameListFormat, 'name-list-format', cfg.keywords['name-list-format']) then\t\t\t-- only accepted value for this parameter is 'vanc'\n\t\tNameListFormat = '';\t\t\t\t\t\t\t\t\t\t\t\t\t-- anything else, set to empty string\n\tend\n\n\tlocal Year = A['Year'];\n\tlocal PublicationDate = A['PublicationDate'];\n\tlocal OrigYear = A['OrigYear'];\n\tlocal Date = A['Date'];\n\tlocal LayDate = A['LayDate'];\n\t------------------------------------------------- Get title data\n\tlocal Title = A['Title'];\n\tlocal ScriptTitle = A['ScriptTitle'];\n\tlocal BookTitle = A['BookTitle'];\n\tlocal Conference = A['Conference'];\n\tlocal TransTitle = A['TransTitle'];\n\tlocal TitleNote = A['TitleNote'];\n\tlocal TitleLink = A['TitleLink'];\n\t\tif is_set (TitleLink) and false == link_param_ok (TitleLink) then\n\t\t\ttable.insert( z.message_tail, { set_error( 'bad_paramlink', A:ORIGIN('TitleLink'))});\t\t-- url or wikilink in |title-link=;\n\t\tend\n\n\tlocal Chapter = A['Chapter'];\n\tlocal ScriptChapter = A['ScriptChapter'];\n\tlocal ChapterLink\t-- = A['ChapterLink'];\t\t\t\t\t\t\t\t\t-- deprecated as a parameter but still used internally by cite episode\n\tlocal TransChapter = A['TransChapter'];\n\tlocal TitleType = A['TitleType'];\n\tlocal Degree = A['Degree'];\n\tlocal Docket = A['Docket'];\n\tlocal ArchiveFormat = A['ArchiveFormat'];\n\tlocal ArchiveURL = A['ArchiveURL'];\n\tlocal URL = A['URL']\n\tlocal URLorigin = A:ORIGIN('URL');\t\t\t\t\t\t\t\t\t\t\t-- get name of parameter that holds URL\n\tlocal ChapterURL = A['ChapterURL'];\n\tlocal ChapterURLorigin = A:ORIGIN('ChapterURL');\t\t\t\t\t\t\t-- get name of parameter that holds ChapterURL\n\tlocal ConferenceFormat = A['ConferenceFormat'];\n\tlocal ConferenceURL = A['ConferenceURL'];\n\tlocal ConferenceURLorigin = A:ORIGIN('ConferenceURL');\t\t\t\t\t\t-- get name of parameter that holds ConferenceURL\n\tlocal Periodical = A['Periodical'];\n\tlocal Periodical_origin = A:ORIGIN('Periodical');\t\t\t\t\t\t\t-- get the name of the periodical parameter\n\n\tlocal Series = A['Series'];\n\t\n\tlocal Volume;\n\tlocal Issue;\n\tlocal Page;\n\tlocal Pages;\n\tlocal At;\n\n\tif in_array (config.CitationClass, cfg.templates_using_volume) and not ('conference' == config.CitationClass and not is_set (Periodical)) then\n\t\tVolume = A['Volume'];\n\tend\n\tif in_array (config.CitationClass, cfg.templates_using_issue) and not (in_array (config.CitationClass, {'conference', 'map'}) and not is_set (Periodical))then\n\t\tIssue = A['Issue'];\n\tend\n\tlocal Position = '';\n\tif not in_array (config.CitationClass, cfg.templates_not_using_page) then\n\t\tPage = A['Page'];\n\t\tPages = hyphen_to_dash( A['Pages'] );\t\n\t\tAt = A['At'];\n\tend\n\n\tlocal Edition = A['Edition'];\n\tlocal PublicationPlace = A['PublicationPlace']\n\tlocal Place = A['Place'];\n\t\n\tlocal PublisherName = A['PublisherName'];\n\tlocal RegistrationRequired = A['RegistrationRequired'];\n\t\tif not is_valid_parameter_value (RegistrationRequired, 'registration', cfg.keywords ['yes_true_y']) then\n\t\t\tRegistrationRequired=nil;\n\t\tend\n\tlocal SubscriptionRequired = A['SubscriptionRequired'];\n\t\tif not is_valid_parameter_value (SubscriptionRequired, 'subscription', cfg.keywords ['yes_true_y']) then\n\t\t\tSubscriptionRequired=nil;\n\t\tend\n\n\tlocal Via = A['Via'];\n\tlocal AccessDate = A['AccessDate'];\n\tlocal ArchiveDate = A['ArchiveDate'];\n\tlocal Agency = A['Agency'];\n\tlocal DeadURL = A['DeadURL']\n\t\tif not is_valid_parameter_value (DeadURL, 'dead-url', cfg.keywords ['deadurl']) then\t-- set in config.defaults to 'yes'\n\t\t\tDeadURL = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- anything else, set to empty string\n\t\tend\n\n\tlocal Language = A['Language'];\n\tlocal Format = A['Format'];\n\tlocal ChapterFormat = A['ChapterFormat'];\n\tlocal DoiBroken = A['DoiBroken'];\n\tlocal ID = A['ID'];\n\tlocal ASINTLD = A['ASINTLD'];\n\tlocal IgnoreISBN = A['IgnoreISBN'];\n\t\tif not is_valid_parameter_value (IgnoreISBN, 'ignore-isbn-error', cfg.keywords ['yes_true_y']) then\n\t\t\tIgnoreISBN = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t-- anything else, set to empty string\n\t\tend\n\tlocal Embargo = A['Embargo'];\n\tlocal Class = A['Class'];\t\t\t\t\t\t\t\t\t\t\t\t\t-- arxiv class identifier\n\n\tlocal ID_list = extract_ids( args );\n\n\tlocal Quote = A['Quote'];\n\n\tlocal LayFormat = A['LayFormat'];\n\tlocal LayURL = A['LayURL'];\n\tlocal LaySource = A['LaySource'];\n\tlocal Transcript = A['Transcript'];\n\tlocal TranscriptFormat = A['TranscriptFormat'];\n\tlocal TranscriptURL = A['TranscriptURL'] \n\tlocal TranscriptURLorigin = A:ORIGIN('TranscriptURL');\t\t\t\t\t\t-- get name of parameter that holds TranscriptURL\n\n\tlocal LastAuthorAmp = A['LastAuthorAmp'];\n\t\tif not is_valid_parameter_value (LastAuthorAmp, 'last-author-amp', cfg.keywords ['yes_true_y']) then\n\t\t\tLastAuthorAmp = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t-- set to empty string\n\t\tend\n\tlocal no_tracking_cats = A['NoTracking'];\n\t\tif not is_valid_parameter_value (no_tracking_cats, 'no-tracking', cfg.keywords ['yes_true_y']) then\n\t\t\tno_tracking_cats = nil;\t\t\t\t\t\t\t\t\t\t\t\t-- set to empty string\n\t\tend\n\n--these are used by cite interview\n\tlocal Callsign = A['Callsign'];\n\tlocal City = A['City'];\n\tlocal Program = A['Program'];\n\n--local variables that are not cs1 parameters\n\tlocal use_lowercase;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- controls capitalization of certain static text\n\tlocal this_page = mw.title.getCurrentTitle();\t\t\t\t\t\t\t\t-- also used for COinS and for language\n\tlocal anchor_year;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- used in the CITEREF identifier\n\tlocal COinS_date = {};\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- holds date info extracted from |date= for the COinS metadata by Module:Date verification\n\n-- set default parameter values defined by |mode= parameter.  If |mode= is empty or omitted, use CitationClass to set these values\n\tlocal Mode = A['Mode'];\n\tif not is_valid_parameter_value (Mode, 'mode', cfg.keywords['mode']) then\n\t\tMode = '';\n\tend\n\tlocal sepc;\t\t\t\t\t\t\t\t\t\t\t-- separator between citation elements for CS1 a period, for CS2, a comma\n\tlocal PostScript;\n\tlocal Ref;\n\tsepc, PostScript, Ref = set_style (Mode:lower(), A['PostScript'], A['Ref'], config.CitationClass);\n\tuse_lowercase = ( sepc == ',' );\t\t\t\t\t-- used to control capitalization for certain static text\n\n--check this page to see if it is in one of the namespaces that cs1 is not supposed to add to the error categories\n\tif not is_set (no_tracking_cats) then\t\t\t\t\t\t\t\t\t\t-- ignore if we are already not going to categorize this page\n\t\tif in_array (this_page.nsText, cfg.uncategorized_namespaces) then\n\t\t\tno_tracking_cats = \"true\";\t\t\t\t\t\t\t\t\t\t\t-- set no_tracking_cats\n\t\tend\n\t\tfor _,v in ipairs (cfg.uncategorized_subpages) do\t\t\t\t\t\t-- cycle through page name patterns\n\t\t\tif this_page.text:match (v) then\t\t\t\t\t\t\t\t\t-- test page name against each pattern\n\t\t\t\tno_tracking_cats = \"true\";\t\t\t\t\t\t\t\t\t\t-- set no_tracking_cats\n\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- bail out if one is found\n\t\t\tend\n\t\tend\n\tend\n\n-- check for extra |page=, |pages= or |at= parameters. (also sheet and sheets while we're at it)\n\tselect_one( args, {'page', 'p', 'pp', 'pages', 'at', 'sheet', 'sheets'}, 'redundant_parameters' );\t\t-- this is a dummy call simply to get the error message and category\n\n\tlocal NoPP = A['NoPP'] \n\tif is_set (NoPP) and is_valid_parameter_value (NoPP, 'nopp', cfg.keywords ['yes_true_y']) then\n\t\tNoPP = true;\n\telse\n\t\tNoPP = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset, used as a flag later\n\tend\n\n\tif is_set(Page) then\n\t\tif is_set(Pages) or is_set(At) then\n\t\t\tPages = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset the others\n\t\t\tAt = '';\n\t\tend\n\t\textra_text_in_page_check (Page);\t\t\t\t\t\t\t\t\t\t-- add this page to maint cat if |page= value begins with what looks like p. or pp.\n\telseif is_set(Pages) then\n\t\tif is_set(At) then\n\t\t\tAt = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset\n\t\tend\n\t\textra_text_in_page_check (Pages);\t\t\t\t\t\t\t\t\t\t-- add this page to maint cat if |pages= value begins with what looks like p. or pp.\n\tend\t\n\n-- both |publication-place= and |place= (|location=) allowed if different\n\tif not is_set(PublicationPlace) and is_set(Place) then\n\t\tPublicationPlace = Place;\t\t\t\t\t\t\t-- promote |place= (|location=) to |publication-place\n\tend\n\t\n\tif PublicationPlace == Place then Place = ''; end\t\t-- don't need both if they are the same\n\t\n--[[\nParameter remapping for cite encyclopedia:\nWhen the citation has these parameters:\n\t|encyclopedia and |title then map |title to |article and |encyclopedia to |title\n\t|encyclopedia and |article then map |encyclopedia to |title\n\t|encyclopedia then map |encyclopedia to |title\n\n\t|trans_title maps to |trans_chapter when |title is re-mapped\n\t|url maps to |chapterurl when |title is remapped\n\nAll other combinations of |encyclopedia, |title, and |article are not modified\n\n]]\n\nlocal Encyclopedia = A['Encyclopedia'];\n\n\tif ( config.CitationClass == \"encyclopaedia\" ) or ( config.CitationClass == \"citation\" and is_set (Encyclopedia)) then\t-- test code for citation\n\t\tif is_set(Periodical) then\t\t\t\t\t\t\t\t\t\t\t\t-- Periodical is set when |encyclopedia is set\n\t\t\tif is_set(Title) or is_set (ScriptTitle) then\n\t\t\t\tif not is_set(Chapter) then\n\t\t\t\t\tChapter = Title;\t\t\t\t\t\t\t\t\t\t\t-- |encyclopedia and |title are set so map |title to |article and |encyclopedia to |title\n\t\t\t\t\tScriptChapter = ScriptTitle;\n\t\t\t\t\tTransChapter = TransTitle;\n\t\t\t\t\tChapterURL = URL;\n\t\t\t\t\tif not is_set (ChapterURL) and is_set (TitleLink) then\n\t\t\t\t\t\tChapter= '[[' .. TitleLink .. '|' .. Chapter .. ']]';\n\t\t\t\t\tend\n\t\t\t\t\tTitle = Periodical;\n\t\t\t\t\tChapterFormat = Format;\n\t\t\t\t\tPeriodical = '';\t\t\t\t\t\t\t\t\t\t\t-- redundant so unset\n\t\t\t\t\tTransTitle = '';\n\t\t\t\t\tURL = '';\n\t\t\t\t\tFormat = '';\n\t\t\t\t\tTitleLink = '';\n\t\t\t\t\tScriptTitle = '';\n\t\t\t\tend\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- |title not set\n\t\t\t\tTitle = Periodical;\t\t\t\t\t\t\t\t\t\t\t\t-- |encyclopedia set and |article set or not set so map |encyclopedia to |title\n\t\t\t\tPeriodical = '';\t\t\t\t\t\t\t\t\t\t\t\t-- redundant so unset\n\t\t\tend\n\t\tend\n\tend\n\n-- Special case for cite techreport.\n\tif (config.CitationClass == \"techreport\") then\t\t\t\t\t\t\t\t-- special case for cite techreport\n\t\tif is_set(A['Number']) then\t\t\t\t\t\t\t\t\t\t\t\t\t-- cite techreport uses 'number', which other citations alias to 'issue'\n\t\t\tif not is_set(ID) then\t\t\t\t\t\t\t\t\t\t\t\t-- can we use ID for the \"number\"?\n\t\t\t\tID = A['Number'];\t\t\t\t\t\t\t\t\t\t\t\t\t-- yes, use it\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- ID has a value so emit error message\n\t\t\t\ttable.insert( z.message_tail, { set_error('redundant_parameters', {wrap_style ('parameter', 'id') .. ' and ' .. wrap_style ('parameter', 'number')}, true )});\n\t\t\tend\n\t\tend\t\n\tend\n\n-- special case for cite interview\n\tif (config.CitationClass == \"interview\") then\n\t\tif is_set(Program) then\n\t\t\tID = ' ' .. Program;\n\t\tend\n\t\tif is_set(Callsign) then\n\t\t\tif is_set(ID) then\n\t\t\t\tID = ID .. sepc .. ' ' .. Callsign;\n\t\t\telse\n\t\t\t\tID = ' ' .. Callsign;\n\t\t\tend\n\t\tend\n\t\tif is_set(City) then\n\t\t\tif is_set(ID) then\n\t\t\t\tID = ID .. sepc .. ' ' .. City;\n\t\t\telse\n\t\t\t\tID = ' ' .. City;\n\t\t\tend\n\t\tend\n\n\t\tif is_set(Others) then\n\t\t\tif is_set(TitleType) then\n\t\t\t\tOthers = ' ' .. TitleType .. ' with ' .. Others;\n\t\t\t\tTitleType = '';\n\t\t\telse\n\t\t\t\tOthers = ' ' .. 'Interview with ' .. Others;\n\t\t\tend\n\t\telse\n\t\t\tOthers = '(Interview)';\n\t\tend\n\tend\n\n-- special case for cite mailing list\n\tif (config.CitationClass == \"mailinglist\") then\n\t\tPeriodical = A ['MailingList'];\n\telseif 'mailinglist' == A:ORIGIN('Periodical') then\n\t\tPeriodical = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset because mailing list is only used for cite mailing list\n\tend\n\n-- Account for the oddity that is {{cite conference}}, before generation of COinS data.\n\tif 'conference' == config.CitationClass then\n\t\tif is_set(BookTitle) then\n\t\t\tChapter = Title;\n--\t\t\tChapterLink = TitleLink;\t\t\t\t\t\t\t\t\t\t\t-- |chapterlink= is deprecated\n\t\t\tChapterURL = URL;\n\t\t\tChapterURLorigin = URLorigin;\n\t\t\tURLorigin = '';\n\t\t\tChapterFormat = Format;\n\t\t\tTransChapter = TransTitle;\n\t\t\tTitle = BookTitle;\n\t\t\tFormat = '';\n--\t\t\tTitleLink = '';\n\t\t\tTransTitle = '';\n\t\t\tURL = '';\n\t\tend\n\telseif 'speech' ~= config.CitationClass then\n\t\tConference = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- not cite conference or cite speech so make sure this is empty string\n\tend\n\n-- cite map oddities\n\tlocal Cartography = \"\";\n\tlocal Scale = \"\";\n\tlocal Sheet = A['Sheet'] or '';\n\tlocal Sheets = A['Sheets'] or '';\n\tif config.CitationClass == \"map\" then\n\t\tChapter = A['Map'];\n\t\tChapterURL = A['MapURL'];\n\t\tTransChapter = A['TransMap'];\n\t\tChapterURLorigin = A:ORIGIN('MapURL');\n\t\tChapterFormat = A['MapFormat'];\n\t\t\n\t\tCartography = A['Cartography'];\n\t\tif is_set( Cartography ) then\n\t\t\tCartography = sepc .. \" \" .. wrap_msg ('cartography', Cartography, use_lowercase);\n\t\tend\t\t\n\t\tScale = A['Scale'];\n\t\tif is_set( Scale ) then\n\t\t\tScale = sepc .. \" \" .. Scale;\n\t\tend\n\tend\n\n-- Account for the oddities that are {{cite episode}} and {{cite serial}}, before generation of COinS data.\n\tif 'episode' == config.CitationClass or 'serial' == config.CitationClass then\n\t\tlocal AirDate = A['AirDate'];\n\t\tlocal SeriesLink = A['SeriesLink'];\n\t\t\tif is_set (SeriesLink) and false == link_param_ok (SeriesLink) then\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'bad_paramlink', A:ORIGIN('SeriesLink'))});\n\t\t\tend\n\t\tlocal Network = A['Network'];\n\t\tlocal Station = A['Station'];\n\t\tlocal s, n = {}, {};\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- do common parameters first\n\t\tif is_set(Network) then table.insert(n, Network); end\n\t\tif is_set(Station) then table.insert(n, Station); end\n\t\tID = table.concat(n, sepc .. ' ');\n\t\t\n\t\tif not is_set (Date) and is_set (AirDate) then\t\t\t\t\t\t\t-- promote airdate to date\n\t\t\tDate = AirDate;\n\t\tend\n\n\t\tif 'episode' == config.CitationClass then\t\t\t\t\t\t\t\t-- handle the oddities that are strictly {{cite episode}}\n\t\t\tlocal Season = A['Season'];\n\t\t\tlocal SeriesNumber = A['SeriesNumber'];\n\n\t\t\tif is_set (Season) and is_set (SeriesNumber) then\t\t\t\t\t-- these are mutually exclusive so if both are set\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'redundant_parameters', {wrap_style ('parameter', 'season') .. ' and ' .. wrap_style ('parameter', 'seriesno')}, true ) } );\t\t-- add error message\n\t\t\t\tSeriesNumber = '';\t\t\t\t\t\t\t\t\t\t\t\t-- unset; prefer |season= over |seriesno=\n\t\t\tend\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- assemble a table of parts concatenated later into Series\n\t\t\tif is_set(Season) then table.insert(s, wrap_msg ('season', Season, use_lowercase)); end\n\t\t\tif is_set(SeriesNumber) then table.insert(s, wrap_msg ('series', SeriesNumber, use_lowercase)); end\n\t\t\tif is_set(Issue) then table.insert(s, wrap_msg ('episode', Issue, use_lowercase)); end\n\t\t\tIssue = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset because this is not a unique parameter\n\t\n\t\t\tChapter = Title;\t\t\t\t\t\t\t\t\t\t\t\t\t-- promote title parameters to chapter\n\t\t\tScriptChapter = ScriptTitle;\n\t\t\tChapterLink = TitleLink;\t\t\t\t\t\t\t\t\t\t\t-- alias episodelink\n\t\t\tTransChapter = TransTitle;\n\t\t\tChapterURL = URL;\n\t\t\tChapterURLorigin = A:ORIGIN('URL');\n\t\t\t\n\t\t\tTitle = Series;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- promote series to title\n\t\t\tTitleLink = SeriesLink;\n\t\t\tSeries = table.concat(s, sepc .. ' ');\t\t\t\t\t\t\t\t-- this is concatenation of season, seriesno, episode number\n\n\t\t\tif is_set (ChapterLink) and not is_set (ChapterURL) then\t\t\t-- link but not URL\n\t\t\t\tChapter = '[[' .. ChapterLink .. '|' .. Chapter .. ']]';\t\t-- ok to wikilink\n\t\t\telseif is_set (ChapterLink) and is_set (ChapterURL) then\t\t\t-- if both are set, URL links episode;\n\t\t\t\tSeries = '[[' .. ChapterLink .. '|' .. Series .. ']]';\t\t\t-- series links with ChapterLink (episodelink -> TitleLink -> ChapterLink) ugly\n\t\t\tend\n\t\t\tURL = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset\n\t\t\tTransTitle = '';\n\t\t\tScriptTitle = '';\n\t\t\t\n\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- now oddities that are cite serial\n\t\t\tIssue = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset because this parameter no longer supported by the citation/core version of cite serial\n\t\t\tChapter = A['Episode'];\t\t\t\t\t\t\t\t\t\t\t\t-- TODO: make |episode= available to cite episode someday?\n\t\t\tif is_set (Series) and is_set (SeriesLink) then\n\t\t\t\tSeries = '[[' .. SeriesLink .. '|' .. Series .. ']]';\n\t\t\tend\n\t\t\tSeries = wrap_style ('italic-title', Series);\t\t\t\t\t\t-- series is italicized\n\t\tend\t\n\tend\n-- end of {{cite episode}} stuff\n\n-- Account for the oddities that are {{cite arxiv}}, before generation of COinS data.\n\tif 'arxiv' == config.CitationClass then\n\t\tif not is_set (ID_list['ARXIV']) then\t\t\t\t\t\t\t\t\t-- |arxiv= or |eprint= required for cite arxiv\n\t\t\ttable.insert( z.message_tail, { set_error( 'arxiv_missing', {}, true ) } );\t\t-- add error message\n\t\telseif is_set (Series) then\t\t\t\t\t\t\t\t\t\t\t\t-- series is an alias of version\n\t\t\tID_list['ARXIV'] = ID_list['ARXIV'] .. Series;\t\t\t\t\t\t-- concatenate version onto the end of the arxiv identifier\n\t\t\tSeries = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- unset\n\t\t\tdeprecated_parameter ('version');\t\t\t\t\t\t\t\t\t-- deprecated parameter but only for cite arxiv\n\t\tend\n\t\t\n\t\tif first_set ({AccessDate, At, Chapter, Format, Page, Pages, Periodical, PublisherName, URL,\t-- a crude list of parameters that are not supported by cite arxiv\n\t\t\tID_list['ASIN'], ID_list['BIBCODE'], ID_list['DOI'], ID_list['ISBN'], ID_list['ISSN'],\n\t\t\tID_list['JFM'], ID_list['JSTOR'], ID_list['LCCN'], ID_list['MR'], ID_list['OCLC'], ID_list['OL'],\n\t\t\tID_list['OSTI'], ID_list['PMC'], ID_list['PMID'], ID_list['RFC'], ID_list['SSRN'], ID_list['USENETID'], ID_list['ZBL']},27) then\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'arxiv_params_not_supported', {}, true ) } );\t\t-- add error message\n\n\t\t\t\tAccessDate= '';\t\t\t\t\t\t\t\t\t\t\t\t\t-- set these to empty string; not supported in cite arXiv\n\t\t\t\tPublisherName = '';\t\t\t\t\t\t\t\t\t\t\t\t-- (if the article has been published, use cite journal, or other)\n\t\t\t\tChapter = '';\n\t\t\t\tURL = '';\n\t\t\t\tFormat = '';\n\t\t\t\tPage = ''; Pages = ''; At = '';\n\t\tend\n\t\tPeriodical = 'arXiv';\t\t\t\t\t\t\t\t\t\t\t\t\t-- set to arXiv for COinS; after that, must be set to empty string\n\tend\n\n-- handle type parameter for those CS1 citations that have default values\n\tif in_array(config.CitationClass, {\"AV-media-notes\", \"DVD-notes\", \"mailinglist\", \"map\", \"podcast\", \"pressrelease\", \"report\", \"techreport\", \"thesis\"}) then\n\t\tTitleType = set_titletype (config.CitationClass, TitleType);\n\t\tif is_set(Degree) and \"Thesis\" == TitleType then\t\t\t\t\t\t-- special case for cite thesis\n\t\t\tTitleType = Degree .. \" thesis\";\n\t\tend\n\tend\n\n\tif is_set(TitleType) then\t\t\t\t\t\t\t\t\t\t\t\t\t-- if type parameter is specified\n\tTitleType = substitute( cfg.messages['type'], TitleType);\t\t\t\t\t-- display it in parentheses\n\tend\n\n-- legacy: promote concatenation of |month=, and |year= to Date if Date not set; or, promote PublicationDate to Date if neither Date nor Year are set.\n\tif not is_set (Date) then\n\t\tDate = Year;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- promote Year to Date\n\t\tYear = nil;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- make nil so Year as empty string isn't used for CITEREF\n\t\tif not is_set (Date) and is_set(PublicationDate) then\t\t\t\t\t-- use PublicationDate when |date= and |year= are not set\n\t\t\tDate = PublicationDate;\t\t\t\t\t\t\t\t\t\t\t\t-- promote PublicationDate to Date\n\t\t\tPublicationDate = '';\t\t\t\t\t\t\t\t\t\t\t\t-- unset, no longer needed\n\t\tend\n\tend\n\n\tif PublicationDate == Date then PublicationDate = ''; end\t\t\t\t\t-- if PublicationDate is same as Date, don't display in rendered citation\n\n--[[\nGo test all of the date-holding parameters for valid MOS:DATE format and make sure that dates are real dates. This must be done before we do COinS because here is where\nwe get the date used in the metadata.\n\nDate validation supporting code is in Module:Citation/CS1/Date_validation\n]]\n\tdo\t-- create defined block to contain local variables error_message and mismatch\n\t\tlocal error_message = '';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- AirDate has been promoted to Date so not necessary to check it\n\t\tanchor_year, error_message = dates({['access-date']=AccessDate, ['archive-date']=ArchiveDate, ['date']=Date, ['doi-broken-date']=DoiBroken,\n\t\t\t['embargo']=Embargo, ['lay-date']=LayDate, ['publication-date']=PublicationDate, ['year']=Year}, COinS_date);\n\n\t\tif is_set (Year) and is_set (Date) then\t\t\t\t\t\t\t\t\t-- both |date= and |year= not normally needed; \n\t\t\tlocal mismatch = year_date_check (Year, Date)\n\t\t\tif 0 == mismatch then\t\t\t\t\t\t\t\t\t\t\t\t-- |year= does not match a year-value in |date=\n\t\t\t\tif is_set (error_message) then\t\t\t\t\t\t\t\t\t-- if there is already an error message\n\t\t\t\t\terror_message = error_message .. ', ';\t\t\t\t\t\t-- tack on this additional message\n\t\t\t\tend\n\t\t\t\terror_message = error_message .. '&#124;year= / &#124;date= mismatch';\n\t\t\telseif 1 == mismatch then\t\t\t\t\t\t\t\t\t\t\t-- |year= matches year-value in |date=\n\t\t\t\tadd_maint_cat ('date_year');\n\t\t\tend\n\t\tend\n\n\t\tif is_set(error_message) then\n\t\t\ttable.insert( z.message_tail, { set_error( 'bad_date', {error_message}, true ) } );\t-- add this error message\n\t\tend\n\tend\t-- end of do\n\n-- Account for the oddity that is {{cite journal}} with |pmc= set and |url= not set.  Do this after date check but before COInS.\n-- Here we unset Embargo if PMC not embargoed (|embargo= not set in the citation) or if the embargo time has expired. Otherwise, holds embargo date\n\tEmbargo = is_embargoed (Embargo);\t\t\t\t\t\t\t\t\t\t\t-- \n\n\tif config.CitationClass == \"journal\" and not is_set(URL) and is_set(ID_list['PMC']) then\n\t\tif not is_set (Embargo) then\t\t\t\t\t\t\t\t\t\t\t-- if not embargoed or embargo has expired\n\t\t\tURL=cfg.id_handlers['PMC'].prefix .. ID_list['PMC'];\t\t\t\t-- set url to be the same as the PMC external link if not embargoed\n\t\t\tURLorigin = cfg.id_handlers['PMC'].parameters[1];\t\t\t\t\t-- set URLorigin to parameter name for use in error message if citation is missing a |title=\n\t\tend\n\tend\n\n-- At this point fields may be nil if they weren't specified in the template use.  We can use that fact.\n\t-- Test if citation has no title\n\tif\tnot is_set(Title) and\n\t\tnot is_set(TransTitle) and\n\t\tnot is_set(ScriptTitle) then\n\t\t\tif 'episode' == config.CitationClass then\t\t\t\t\t\t\t-- special case for cite episode; TODO: is there a better way to do this?\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'citation_missing_title', {'series'}, true ) } );\n\t\t\telse\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'citation_missing_title', {'title'}, true ) } );\n\t\t\tend\n\tend\n\t\n\tif 'none' == Title and in_array (config.CitationClass, {'journal', 'citation'}) and is_set (Periodical) and 'journal' == A:ORIGIN('Periodical') then\t-- special case for journal cites\n\t\tTitle = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- set title to empty string\n\t\tadd_maint_cat ('untitled');\n\tend\n\n\tcheck_for_url ({\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- add error message when any of these parameters contains a URL\n\t\t['title']=Title,\n\t\t[A:ORIGIN('Chapter')]=Chapter,\n\t\t[A:ORIGIN('Periodical')]=Periodical,\n\t\t[A:ORIGIN('PublisherName')] = PublisherName,\n\t\t});\n\n\t-- COinS metadata (see <http://ocoins.info/>) for automated parsing of citation information.\n\t-- handle the oddity that is cite encyclopedia and {{citation |encyclopedia=something}}. Here we presume that\n\t-- when Periodical, Title, and Chapter are all set, then Periodical is the book (encyclopedia) title, Title\n\t-- is the article title, and Chapter is a section within the article.  So, we remap \n\t\n\tlocal coins_chapter = Chapter;\t\t\t\t\t\t\t\t\t\t\t\t-- default assuming that remapping not required\n\tlocal coins_title = Title;\t\t\t\t\t\t\t\t\t\t\t\t\t-- et tu\n\tif 'encyclopaedia' == config.CitationClass or ('citation' == config.CitationClass and is_set (Encyclopedia)) then\n\t\tif is_set (Chapter) and is_set (Title) and is_set (Periodical) then\t\t-- if all are used then\n\t\t\tcoins_chapter = Title;\t\t\t\t\t\t\t\t\t\t\t\t-- remap\n\t\t\tcoins_title = Periodical;\n\t\tend\n\tend\n\tlocal coins_author = a;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- default for coins rft.au \n\tif 0 < #c then\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- but if contributor list\n\t\tcoins_author = c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- use that instead\n\tend\n\n\t-- this is the function call to COinS()\n\tlocal OCinSoutput = COinS({\n\t\t['Periodical'] = Periodical,\n\t\t['Encyclopedia'] = Encyclopedia,\n\t\t['Chapter'] = make_coins_title (coins_chapter, ScriptChapter),\t\t\t-- Chapter and ScriptChapter stripped of bold / italic wikimarkup\n\t\t['Map'] = Map,\n\t\t['Degree'] = Degree;\t\t\t\t\t\t\t\t\t\t\t\t\t-- cite thesis only\n\t\t['Title'] = make_coins_title (coins_title, ScriptTitle),\t\t\t\t-- Title and ScriptTitle stripped of bold / italic wikimarkup\n\t\t['PublicationPlace'] = PublicationPlace,\n\t\t['Date'] = COinS_date.rftdate,\t\t\t\t\t\t\t\t\t\t\t-- COinS_date has correctly formatted date if Date is valid;\n\t\t['Season'] = COinS_date.rftssn,\n\t\t['Chron'] =  COinS_date.rftchron or (not COinS_date.rftdate and Date) or '',\t-- chron but if not set and invalid date format use Date; keep this last bit?\n\t\t['Series'] = Series,\n\t\t['Volume'] = Volume,\n\t\t['Issue'] = Issue,\n\t\t['Pages'] = get_coins_pages (first_set ({Sheet, Sheets, Page, Pages, At}, 5)),\t\t\t\t-- pages stripped of external links\n\t\t['Edition'] = Edition,\n\t\t['PublisherName'] = PublisherName,\n\t\t['URL'] = first_set ({ChapterURL, URL}, 2),\n\t\t['Authors'] = coins_author,\n\t\t['ID_list'] = ID_list,\n\t\t['RawPage'] = this_page.prefixedText,\n\t}, config.CitationClass);\n\n-- Account for the oddities that are {{cite arxiv}}, AFTER generation of COinS data.\n\tif 'arxiv' == config.CitationClass then\t\t\t\t\t\t\t\t\t\t-- we have set rft.jtitle in COinS to arXiv, now unset so it isn't displayed\n\t\tPeriodical = '';\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- periodical not allowed in cite arxiv; if article has been published, use cite journal\n\tend\n\n-- special case for cite newsgroup.  Do this after COinS because we are modifying Publishername to include some static text\n\tif 'newsgroup' == config.CitationClass then\n\t\tif is_set (PublisherName) then\n\t\t\tPublisherName = substitute (cfg.messages['newsgroup'], external_link( 'news:' .. PublisherName, PublisherName, A:ORIGIN('PublisherName') ));\n\t\tend\n\tend\n\n\n\n\t-- Now perform various field substitutions.\n\t-- We also add leading spaces and surrounding markup and punctuation to the\n\t-- various parts of the citation, but only when they are non-nil.\n\tlocal EditorCount;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- used only for choosing {ed.) or (eds.) annotation at end of editor name-list\n\tdo\n\t\tlocal last_first_list;\n\t\tlocal maximum;\n\t\tlocal control = { \n\t\t\tformat = NameListFormat,\t\t\t\t\t\t\t\t\t\t\t-- empty string or 'vanc'\n\t\t\tmaximum = nil,\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- as if display-authors or display-editors not set\n\t\t\tlastauthoramp = LastAuthorAmp,\n\t\t\tpage_name = this_page.text\t\t\t\t\t\t\t\t\t\t\t-- get current page name so that we don't wikilink to it via editorlinkn\n\t\t};\n\n\t\tdo\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- do editor name list first because coauthors can modify control table\n\t\t\tmaximum , editor_etal = get_display_authors_editors (A['DisplayEditors'], #e, 'editors', editor_etal);\n\t\t\t--[[ Preserve old-style implicit et al.\n\t\t\t\u4e34\u65f6\u4fee\u590d\"Category:\u542b\u6709\u65e7\u5f0f\u7f29\u7565\u6807\u7b7e\u7684\u5f15\u7528\u7684\u9875\u9762 in editors\"\u7684\u95ee\u9898\uff0c\u4e2d\u6587\u7248\u76ee\u524d\u4e0e\u82f1\u6587\u7248\u903b\u8f91\u4e0d\u4e00\u6837\uff0c\u6682\u65f6\u4e0d\u9700\u8981\u8fd9\u4e2a\u5206\u7c7b\u3002\u7b49\u4ee5\u540e\u66f4\u65b0\u65f6\u518d\u770b\u600e\u4e48\u5904\u7406 --2017.6.23 shizhao\n\t\t\t\n\t\t\tif not is_set(maximum) and #e == 4 then \n\t\t\t\tmaximum = 3;\n\t\t\t\ttable.insert( z.message_tail, { set_error('implict_etal_editor', {}, true) } );\n\t\t\tend\n\t\t\t]]\n\n\t\t\tcontrol.maximum = maximum;\n\t\t\t\n\t\t\tlast_first_list, EditorCount = list_people(control, e, editor_etal, 'editor');\n\n\t\t\tif is_set (Editors) then\n\t\t\t\tif editor_etal then\n\t\t\t\t\tEditors = Editors .. ' ' .. cfg.messages['et al'];\t\t\t-- add et al. to editors parameter beause |display-editors=etal\n\t\t\t\t\tEditorCount = 2;\t\t\t\t\t\t\t\t\t\t\t-- with et al., |editors= is multiple names; spoof to display (eds.) annotation\n\t\t\t\telse\n\t\t\t\t\tEditorCount = 2;\t\t\t\t\t\t\t\t\t\t\t-- we don't know but assume |editors= is multiple names; spoof to display (eds.) annotation\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tEditors = last_first_list;\t\t\t\t\t\t\t\t\t\t-- either an author name list or an empty string\n\t\t\tend\n\n\t\t\tif 1 == EditorCount and (true == editor_etal or 1 < #e) then\t\t-- only one editor displayed but includes etal then \n\t\t\t\tEditorCount = 2;\t\t\t\t\t\t\t\t\t\t\t\t-- spoof to display (eds.) annotation\n\t\t\tend\n\t\tend\n\t\tdo\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- now do translators\n\t\t\tcontrol.maximum = #t;\t\t\t\t\t\t\t\t\t\t\t\t-- number of translators\n\t\t\tTranslators = list_people(control, t, false, 'translator');\t\t\t-- et al not currently supported\n\t\tend\n\t\tdo\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- now do contributors\n\t\t\tcontrol.maximum = #c;\t\t\t\t\t\t\t\t\t\t\t\t-- number of contributors\n\t\t\tContributors = list_people(control, c, false, 'contributor');\t\t-- et al not currently supported\n\t\tend\n\t\tdo\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- now do authors\n\t\t\tcontrol.maximum , author_etal = get_display_authors_editors (A['DisplayAuthors'], #a, 'authors', author_etal);\n\n\t\t\tif is_set(Coauthors) then\t\t\t\t\t\t\t\t\t\t\t-- if the coauthor field is also used, prevent ampersand and et al. formatting.\n\t\t\t\tcontrol.lastauthoramp = nil;\n\t\t\t\tcontrol.maximum = #a + 1;\n\t\t\tend\n\t\t\t\n\t\t\tlast_first_list = list_people(control, a, author_etal, 'author');\n\n\t\t\tif is_set (Authors) then\n\t\t\t\tAuthors, author_etal = name_has_etal (Authors, author_etal, false);\t-- find and remove variations on et al.\n\t\t\t\tif author_etal then\n\t\t\t\t\tAuthors = Authors .. ' ' .. cfg.messages['et al'];\t\t\t-- add et al. to authors parameter\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tAuthors = last_first_list;\t\t\t\t\t\t\t\t\t\t-- either an author name list or an empty string\n\t\t\tend\n\t\tend\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- end of do\n\n\t\tif not is_set(Authors) and is_set(Coauthors) then\t\t\t\t\t\t-- coauthors aren't displayed if one of authors=, authorn=, or lastn= isn't specified\n\t\t\ttable.insert( z.message_tail, { set_error('coauthors_missing_author', {}, true) } );\t-- emit error message\n\t\tend\n\tend\n\n-- apply |[xx-]format= styling; at the end, these parameters hold correctly styled format annotation,\n-- an error message if the associated url is not set, or an empty string for concatenation\n\tArchiveFormat = style_format (ArchiveFormat, ArchiveURL, 'archive-format', 'archive-url');\n\tConferenceFormat = style_format (ConferenceFormat, ConferenceURL, 'conference-format', 'conference-url');\n\tFormat = style_format (Format, URL, 'format', 'url');\n\tLayFormat = style_format (LayFormat, LayURL, 'lay-format', 'lay-url');\n\tTranscriptFormat = style_format (TranscriptFormat, TranscriptURL, 'transcript-format', 'transcripturl');\n\n-- special case for chapter format so no error message or cat when chapter not supported\n\tif not (in_array(config.CitationClass, {'web','news','journal', 'magazine', 'pressrelease','podcast', 'newsgroup', 'arxiv'}) or\n\t\t('citation' == config.CitationClass and is_set (Periodical) and not is_set (Encyclopedia))) then\n\t\t\tChapterFormat = style_format (ChapterFormat, ChapterURL, 'chapter-format', 'chapter-url');\n\tend\n\n\tif  not is_set(URL) then --and\n\t\tif in_array(config.CitationClass, {\"web\",\"podcast\", \"mailinglist\"}) then\t\t-- Test if cite web or cite podcast |url= is missing or empty \n\t\t\ttable.insert( z.message_tail, { set_error( 'cite_web_url', {}, true ) } );\n\t\tend\n\t\t\n\t\t-- Test if accessdate is given without giving a URL\n\t\tif is_set(AccessDate) and not is_set(ChapterURL)then\t\t\t\t\t-- ChapterURL may be set when the others are not set; TODO: move this to a separate test?\n\t\t\ttable.insert( z.message_tail, { set_error( 'accessdate_missing_url', {}, true ) } );\n\t\t\tAccessDate = '';\n\t\tend\n\tend\n\n\tlocal OriginalURL, OriginalURLorigin, OriginalFormat;\t\t\t\t\t\t-- TODO: swap chapter and title here so that archive applies to most specific if both are set?\n\tDeadURL = DeadURL:lower();\t\t\t\t\t\t\t\t\t\t\t\t\t-- used later when assembling archived text\n\tif is_set( ArchiveURL ) then\n\t\tif is_set (URL) then\n\t\t\tOriginalURL = URL;\t\t\t\t\t\t\t\t\t\t\t\t\t-- save copy of original source URL\n\t\t\tOriginalURLorigin = URLorigin;\t\t\t\t\t\t\t\t\t\t-- name of url parameter for error messages\n\t\t\tOriginalFormat = Format;\t\t\t\t\t\t\t\t\t\t\t-- and original |format=\n\t\t\tif 'no' ~= DeadURL then\t\t\t\t\t\t\t\t\t\t\t\t-- if URL set then archive-url applies to it\n\t\t\t\tURL = ArchiveURL\t\t\t\t\t\t\t\t\t\t\t\t-- swap-in the archive's url\n\t\t\t\tURLorigin = A:ORIGIN('ArchiveURL')\t\t\t\t\t\t\t\t-- name of archive url parameter for error messages\n\t\t\t\tFormat = ArchiveFormat or '';\t\t\t\t\t\t\t\t\t-- swap in archive's format\n\t\t\tend\n\t\telseif is_set (ChapterURL) then \t\t\t\t\t\t\t\t\t\t-- URL not set so if chapter-url is set apply archive url to it\n\t\t\tOriginalURL = ChapterURL;\t\t\t\t\t\t\t\t\t\t\t-- save copy of source chapter's url for archive text\n\t\t\tOriginalURLorigin = ChapterURLorigin;\t\t\t\t\t\t\t\t-- name of chapter-url parameter for error messages\n\t\t\tOriginalFormat = ChapterFormat;\t\t\t\t\t\t\t\t\t\t-- and original |format=\n\t\t\tif 'no' ~= DeadURL then\n\t\t\t\tChapterURL = ArchiveURL\t\t\t\t\t\t\t\t\t\t\t-- swap-in the archive's url\n\t\t\t\tChapterURLorigin = A:ORIGIN('ArchiveURL')\t\t\t\t\t\t-- name of archive-url parameter for error messages\n\t\t\t\tChapterFormat = ArchiveFormat or '';\t\t\t\t\t\t\t-- swap in archive's format\n\t\t\tend\n\t\tend\n\tend\n\n\tif in_array(config.CitationClass, {'web','news','journal', 'magazine', 'pressrelease','podcast', 'newsgroup', 'arxiv'}) or\t-- if any of the 'periodical' cites except encyclopedia\n\t\t('citation' == config.CitationClass and is_set (Periodical) and not is_set (Encyclopedia)) then\n\t\t\tlocal chap_param;\n\t\t\tif is_set (Chapter) then\t\t\t\t\t\t\t\t\t\t\t-- get a parameter name from one of these chapter related meta-parameters\n\t\t\t\tchap_param = A:ORIGIN ('Chapter')\n\t\t\telseif is_set (TransChapter) then\n\t\t\t\tchap_param = A:ORIGIN ('TransChapter')\n\t\t\telseif is_set (ChapterURL) then\n\t\t\t\tchap_param = A:ORIGIN ('ChapterURL')\n\t\t\telseif is_set (ScriptChapter) then\n\t\t\t\tchap_param = A:ORIGIN ('ScriptChapter')\n\t\t\telse is_set (ChapterFormat)\n\t\t\t\tchap_param = A:ORIGIN ('ChapterFormat')\n\t\t\tend\n\n\t\t\tif is_set (chap_param) then\t\t\t\t\t\t\t\t\t\t\t-- if we found one\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'chapter_ignored', {chap_param}, true ) } );\t\t-- add error message\n\t\t\t\tChapter = '';\t\t\t\t\t\t\t\t\t\t\t\t\t-- and set them to empty string to be safe with concatenation\n\t\t\t\tTransChapter = '';\n\t\t\t\tChapterURL = '';\n\t\t\t\tScriptChapter = '';\n\t\t\t\tChapterFormat = '';\n\t\t\tend\n\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- otherwise, format chapter / article title\n\t\tlocal no_quotes = false;\t\t\t\t\t\t\t\t\t\t\t\t-- default assume that we will be quoting the chapter parameter value\n\t\tif is_set (Contribution) and 0 < #c then\t\t\t\t\t\t\t\t-- if this is a contribution with contributor(s)\n\t\t\tif in_array (Contribution:lower(), cfg.keywords.contribution) then\t-- and a generic contribution title\n\t\t\t\tno_quotes = true;\t\t\t\t\t\t\t\t\t\t\t\t-- then render it unquoted\n\t\t\tend\n\t\tend\n\n\t\tChapter = format_chapter_title (ScriptChapter, Chapter, TransChapter, ChapterURL, ChapterURLorigin, no_quotes);\t\t-- Contribution is also in Chapter\n\t\tif is_set (Chapter) then\n\t\t\tif 'map' == config.CitationClass and is_set (TitleType) then\n\t\t\t\tChapter = Chapter .. ' ' .. TitleType;\n\t\t\tend\n\t\t\tChapter = Chapter .. ChapterFormat .. sepc .. ' ';\n\t\telseif is_set (ChapterFormat) then\t\t\t\t\t\t\t\t\t\t-- |chapter= not set but |chapter-format= is so ...\n\t\t\tChapter = ChapterFormat .. sepc .. ' ';\t\t\t\t\t\t\t\t-- ... ChapterFormat has error message, we want to see it\n\t\tend\n\tend\n\n\t-- Format main title.\n\tif is_set(TitleLink) and is_set(Title) then\n\t\tTitle = \"[[\" .. TitleLink .. \"|\" .. Title .. \"]]\"\n\tend\n\n\tif in_array(config.CitationClass, {'web','news','journal', 'magazine', 'pressrelease','podcast', 'newsgroup', 'mailinglist', 'arxiv'}) or\n\t\t('citation' == config.CitationClass and is_set (Periodical) and not is_set (Encyclopedia)) or\n\t\t('map' == config.CitationClass and is_set (Periodical)) then\t\t\t-- special case for cite map when the map is in a periodical treat as an article\n\t\t\tTitle = kern_quotes (Title);\t\t\t\t\t\t\t\t\t\t-- if necessary, separate title's leading and trailing quote marks from Module provided quote marks\n\t\t\tTitle = wrap_style ('quoted-title', Title);\n\t\n\t\t\tTitle = script_concatenate (Title, ScriptTitle);\t\t\t\t\t-- <bdi> tags, lang atribute, categorization, etc; must be done after title is wrapped\n\t\t\tTransTitle= wrap_style ('trans-quoted-title', TransTitle );\n\telseif 'report' == config.CitationClass then\t\t\t\t\t\t\t\t-- no styling for cite report\n\t\tTitle = script_concatenate (Title, ScriptTitle);\t\t\t\t\t\t-- <bdi> tags, lang atribute, categorization, etc; must be done after title is wrapped\n\t\tTransTitle= wrap_style ('trans-quoted-title', TransTitle );\t\t\t\t-- for cite report, use this form for trans-title\n\telse\n\t\tTitle = wrap_style ('italic-title', Title);\n\t\tTitle = script_concatenate (Title, ScriptTitle);\t\t\t\t\t\t-- <bdi> tags, lang atribute, categorization, etc; must be done after title is wrapped\n\t\tTransTitle = wrap_style ('trans-italic-title', TransTitle);\n\tend\n\n\tTransError = \"\";\n\tif is_set(TransTitle) then\n\t\tif is_set(Title) then\n\t\t\tTransTitle = \" \" .. TransTitle;\n\t\telse\n\t\t\tTransError = \" \" .. set_error( 'trans_missing_title', {'title'} );\n\t\tend\n\tend\n\t\n\tTitle = Title .. TransTitle;\n\t\n\tif is_set(Title) then\n\t\tif not is_set(TitleLink) and is_set(URL) then \n\t\t\tTitle = external_link( URL, Title, URLorigin ) .. TransError .. Format;\n\t\t\tURL = \"\";\n\t\t\tFormat = \"\";\n\t\telse\n\t\t\tTitle = Title .. TransError;\n\t\tend\n\tend\n\n\tif is_set(Place) then\n\t\tPlace = \" \" .. wrap_msg ('written', Place, use_lowercase) .. sepc .. \" \";\n\tend\n\n\tif is_set (Conference) then\n\t\tif is_set (ConferenceURL) then\n\t\t\tConference = external_link( ConferenceURL, Conference, ConferenceURLorigin );\n\t\tend\n\t\tConference = sepc .. \" \" .. Conference .. ConferenceFormat;\n\telseif is_set(ConferenceURL) then\n\t\tConference = sepc .. \" \" .. external_link( ConferenceURL, nil, ConferenceURLorigin );\n\tend\n\n\tif not is_set(Position) then\n\t\tlocal Minutes = A['Minutes'];\n\t\tlocal Time = A['Time'];\n\n\t\tif is_set(Minutes) then\n\t\t\tif is_set (Time) then\n\t\t\t\ttable.insert( z.message_tail, { set_error( 'redundant_parameters', {wrap_style ('parameter', 'minutes') .. ' and ' .. wrap_style ('parameter', 'time')}, true ) } );\n\t\t\tend\n\t\t\tPosition = \" \" .. Minutes .. \" \" .. cfg.messages['minutes'];\n\t\telse\n\t\t\tif is_set(Time) then\n\t\t\t\tlocal TimeCaption = A['TimeCaption']\n\t\t\t\tif not is_set(TimeCaption) then\n\t\t\t\t\tTimeCaption = cfg.messages['event'];\n\t\t\t\t\tif sepc ~= '.' then\n\t\t\t\t\t\tTimeCaption = TimeCaption:lower();\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tPosition = \" \" .. TimeCaption .. \" \" .. Time;\n\t\t\tend\n\t\tend\n\telse\n\t\tPosition = \" \" .. Position;\n\t\tAt = '';\n\tend\n\n\tPage, Pages, Sheet, Sheets = format_pages_sheets (Page, Pages, Sheet, Sheets, config.CitationClass, Periodical_origin, sepc, NoPP, use_lowercase);\n\n\tAt = is_set(At) and (sepc .. \" \" .. At) or \"\";\n\tPosition = is_set(Position) and (sepc .. \" \" .. Position) or \"\";\n\tif config.CitationClass == 'map' then\n\t\tlocal Section = A['Section'];\n\t\tlocal Sections = A['Sections'];\n\t\tlocal Inset = A['Inset'];\n\t\t\n\t\tif is_set( Inset ) then\n\t\t\tInset = sepc .. \" \" .. wrap_msg ('inset', Inset, use_lowercase);\n\t\tend\t\t\t\n\n\t\tif is_set( Sections ) then\n\t\t\tSection = sepc .. \" \" .. wrap_msg ('sections', Sections, use_lowercase);\n\t\telseif is_set( Section ) then\n\t\t\tSection = sepc .. \" \" .. wrap_msg ('section', Section, use_lowercase);\n\t\tend\n\t\tAt = At .. Inset .. Section;\t\t\n\tend\t\n\n\tif is_set (Language) then\n\t\tLanguage = language_parameter (Language);\t\t\t\t\t\t\t\t-- format, categories, name from ISO639-1, etc\n\telse\n\t\tLanguage=\"\";\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- language not specified so make sure this is an empty string;\n\tend\n\n\tOthers = is_set(Others) and (sepc .. \" \" .. Others) or \"\";\n\t\n\tif is_set (Translators) then\n\t\tOthers = sepc .. ' \u7531' .. Translators .. '\u7ffb\u8bd1 ' .. Others; \n\tend\n\n\tTitleNote = is_set(TitleNote) and (sepc .. \" \" .. TitleNote) or \"\";\n\tif is_set (Edition) then\n\t\tif Edition:match ('%f[%a][Ee]d%.?$') or Edition:match ('%f[%a][Ee]dition$') then\n\t\t\tadd_maint_cat ('extra_text', 'edition');\n\t\tend\n\t\tEdition = \" \" .. wrap_msg ('edition', Edition);\n\telse\n\t\tEdition = '';\n\tend\n\n\tSeries = is_set(Series) and (sepc .. \" \" .. Series) or \"\";\n\tOrigYear = is_set(OrigYear) and (\" [\" .. OrigYear .. \"]\") or \"\";\n\tAgency = is_set(Agency) and (sepc .. \" \" .. Agency) or \"\";\n\n\tVolume = format_volume_issue (Volume, Issue, config.CitationClass, Periodical_origin, sepc, use_lowercase);\n\n\t------------------------------------ totally unrelated data\n\tif is_set(Via) then\n\t\tVia = \" \" .. wrap_msg ('via', Via);\n\tend\n\n--[[\nSubscription implies paywall; Registration does not.  If both are used in a citation, the subscription required link\nnote is displayed. There are no error messages for this condition.\n\n]]\n\tif is_set (SubscriptionRequired) then\n\t\tSubscriptionRequired = sepc .. \" \" .. cfg.messages['subscription'];\t\t-- subscription required message\n\telseif is_set (RegistrationRequired) then\n\t\tSubscriptionRequired = sepc .. \" \" .. cfg.messages['registration'];\t\t-- registration required message\n\telse\n\t\tSubscriptionRequired = '';\t\t\t\t\t\t\t\t\t\t\t\t-- either or both might be set to something other than yes true y\n\tend\n\n\tif is_set(AccessDate) then\n\t\tlocal retrv_text = \" \" .. cfg.messages['retrieved']\n\n\t\tAccessDate = nowrap_date (AccessDate);\t\t\t\t\t\t\t\t\t-- wrap in nowrap span if date in appropriate format\n\t\tif (sepc ~= \".\") then retrv_text = retrv_text:lower() end\t\t\t\t-- if 'citation', lower case\n\t\tAccessDate = substitute (retrv_text, AccessDate);\t\t\t\t\t\t-- add retrieved text\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- neither of these work; don't know why; it seems that substitute() isn't being called\t\n\t\tAccessDate = substitute (cfg.presentation['accessdate'], {sepc, AccessDate});\t-- allow editors to hide accessdates\n\tend\n\t\n\tif is_set(ID) then ID = sepc ..\" \".. ID; end\n   \tif \"thesis\" == config.CitationClass and is_set(Docket) then\n\t\tID = sepc ..\" Docket \".. Docket .. ID;\n\tend\n   \tif \"report\" == config.CitationClass and is_set(Docket) then\t\t\t\t\t-- for cite report when |docket= is set\n\t\tID = sepc .. ' ' .. Docket;\t\t\t\t\t\t\t\t\t\t\t\t-- overwrite ID even if |id= is set\n\tend\n\n\tID_list = build_id_list( ID_list, {DoiBroken = DoiBroken, ASINTLD = ASINTLD, IgnoreISBN = IgnoreISBN, Embargo=Embargo, Class = Class} );\n\n\tif is_set(URL) then\n\t\tURL = \" \" .. external_link( URL, nil, URLorigin );\n\tend\n\n\tif is_set(Quote) then\n\t\tif Quote:sub(1,1) == '\"' and Quote:sub(-1,-1) == '\"' then\t\t\t\t-- if first and last characters of quote are quote marks\n\t\t\tQuote = Quote:sub(2,-2);\t\t\t\t\t\t\t\t\t\t\t-- strip them off\n\t\tend\n\t\tQuote = sepc ..\" \" .. wrap_style ('quoted-text', Quote ); \t\t\t\t-- wrap in <q>...</q> tags\n\t\tPostScript = \"\";\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- cs1|2 does not supply terminal punctuation when |quote= is set\n\tend\n\t\n\tlocal Archived\n\tif is_set(ArchiveURL) then\n\t\tif not is_set(ArchiveDate) then\n\t\t\tArchiveDate = set_error('archive_missing_date');\n\t\tend\n\t\tif \"no\" == DeadURL then\n\t\t\tlocal arch_text = cfg.messages['archived'];\n\t\t\tif sepc ~= \".\" then arch_text = arch_text:lower() end\n\t\t\tArchived = sepc .. \" \" .. substitute( cfg.messages['archived-not-dead'],\n\t\t\t\t{ external_link( ArchiveURL, arch_text, A:ORIGIN('ArchiveURL') ) .. ArchiveFormat, ArchiveDate } );\n\t\t\tif not is_set(OriginalURL) then\n\t\t\t\tArchived = Archived .. \" \" .. set_error('archive_missing_url');\t\t\t\t\t\t\t   \n\t\t\tend\n\t\telseif is_set(OriginalURL) then\t\t\t\t\t\t\t\t\t\t\t-- DeadURL is empty, 'yes', 'true', 'y', 'unfit', 'usurped'\n\t\t\tlocal arch_text = cfg.messages['archived-dead'];\n\t\t\tif sepc ~= \".\" then arch_text = arch_text:lower() end\n\t\t\tif in_array (DeadURL, {'unfit', 'usurped'}) then\n\t\t\t\tArchived = sepc .. \" \" .. 'Archived from the original on ' .. ArchiveDate;\t-- format already styled\n\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- DeadURL is empty, 'yes', 'true', or 'y'\n\t\t\t\tArchived = sepc .. \" \" .. substitute( arch_text,\n\t\t\t\t\t{ external_link( OriginalURL, cfg.messages['original'], OriginalURLorigin ) .. OriginalFormat, ArchiveDate } );\t-- format already styled\n\t\t\tend\t\n\t\telse\n\t\t\tlocal arch_text = cfg.messages['archived-missing'];\n\t\t\tif sepc ~= \".\" then arch_text = arch_text:lower() end\n\t\t\tArchived = sepc .. \" \" .. substitute( arch_text, \n\t\t\t\t{ set_error('archive_missing_url'), ArchiveDate } );\n\t\tend\n\telseif is_set (ArchiveFormat) then\n\t\tArchived = ArchiveFormat;\t\t\t\t\t\t\t\t\t\t\t\t-- if set and ArchiveURL not set ArchiveFormat has error message\n\telse\n\t\tArchived = \"\"\n\tend\n\t\n\tlocal Lay = '';\n\tif is_set(LayURL) then\n\t\tif is_set(LayDate) then LayDate = \" (\" .. LayDate .. \")\" end\n\t\tif is_set(LaySource) then \n\t\t\tLaySource = \" &ndash; ''\" .. safe_for_italics(LaySource) .. \"''\";\n\t\telse\n\t\t\tLaySource = \"\";\n\t\tend\n\t\tif sepc == '.' then\n\t\t\tLay = sepc .. \" \" .. external_link( LayURL, cfg.messages['lay summary'], A:ORIGIN('LayURL') ) .. LayFormat .. LaySource .. LayDate\n\t\telse\n\t\t\tLay = sepc .. \" \" .. external_link( LayURL, cfg.messages['lay summary']:lower(), A:ORIGIN('LayURL') ) .. LayFormat .. LaySource .. LayDate\n\t\tend\t\t\t\n\telseif is_set (LayFormat) then\t\t\t\t\t\t\t\t\t\t\t\t-- Test if |lay-format= is given without giving a |lay-url=\n\t\tLay = sepc .. LayFormat;\t\t\t\t\t\t\t\t\t\t\t\t-- if set and LayURL not set, then LayFormat has error message\n\tend\n\n\tif is_set(Transcript) then\n\t\tif is_set(TranscriptURL) then\n\t\t\tTranscript = external_link( TranscriptURL, Transcript, TranscriptURLorigin );\n\t\tend\n\t\tTranscript = sepc .. ' ' .. Transcript .. TranscriptFormat;\n\telseif is_set(TranscriptURL) then\n\t\tTranscript = external_link( TranscriptURL, nil, TranscriptURLorigin );\n\tend\n\n\tlocal Publisher;\n\tif is_set(Periodical) and\n\t\tnot in_array(config.CitationClass, {\"encyclopaedia\",\"web\",\"pressrelease\",\"podcast\"}) then\n\t\tif is_set(PublisherName) then\n\t\t\tif is_set(PublicationPlace) then\n\t\t\t\tPublisher = PublicationPlace .. \": \" .. PublisherName;\n\t\t\telse\n\t\t\t\tPublisher = PublisherName;  \n\t\t\tend\n\t\telseif is_set(PublicationPlace) then\n\t\t\tPublisher= PublicationPlace;\n\t\telse \n\t\t\tPublisher = \"\";\n\t\tend\n\t\tif is_set(Publisher) then\n\t\t\tPublisher = \" (\" .. Publisher .. \")\";\n\t\tend\n\telse\n\t\tif is_set(PublisherName) then\n\t\t\tif is_set(PublicationPlace) then\n\t\t\t\tPublisher = sepc .. \" \" .. PublicationPlace .. \": \" .. PublisherName;\n\t\t\telse\n\t\t\t\tPublisher = sepc .. \" \" .. PublisherName;  \n\t\t\tend\t\t\t\n\t\telseif is_set(PublicationPlace) then \n\t\t\tPublisher= sepc .. \" \" .. PublicationPlace;\n\t\telse \n\t\t\tPublisher = '';\n\t\tend\n\tend\n\t\n\t-- Several of the above rely upon detecting this as nil, so do it last.\n\tif is_set(Periodical) then\n\t\tif is_set(Title) or is_set(TitleNote) then \n\t\t\tPeriodical = sepc .. \" \" .. wrap_style ('italic-title', Periodical) \n\t\telse \n\t\t\tPeriodical = wrap_style ('italic-title', Periodical)\n\t\tend\n\tend\n\n--[[\nHandle the oddity that is cite speech.  This code overrides whatever may be the value assigned to TitleNote (through |department=) and forces it to be \" (Speech)\" so that\nthe annotation directly follows the |title= parameter value in the citation rather than the |event= parameter value (if provided).\n]]\n\tif \"speech\" == config.CitationClass then\t\t\t\t-- cite speech only\n\t\tTitleNote = \" (Speech)\";\t\t\t\t\t\t\t-- annotate the citation\n\t\tif is_set (Periodical) then\t\t\t\t\t\t\t-- if Periodical, perhaps because of an included |website= or |journal= parameter \n\t\t\tif is_set (Conference) then\t\t\t\t\t\t-- and if |event= is set\n\t\t\t\tConference = Conference .. sepc .. \" \";\t\t-- then add appropriate punctuation to the end of the Conference variable before rendering\n\t\t\tend\n\t\tend\n\tend\n\n\t-- Piece all bits together at last.  Here, all should be non-nil.\n\t-- We build things this way because it is more efficient in LUA\n\t-- not to keep reassigning to the same string variable over and over.\n\n\tlocal tcommon;\n\tlocal tcommon2;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- used for book cite when |contributor= is set\n\t\n\tif in_array(config.CitationClass, {\"journal\",\"citation\"}) and is_set(Periodical) then\n\t\tif is_set(Others) then Others = Others .. sepc .. \" \" end\n\t\ttcommon = safe_join( {Others, Title, TitleNote, Conference, Periodical, Format, TitleType, Series, \n\t\t\tEdition, Publisher, Agency}, sepc );\n\t\t\n\telseif in_array(config.CitationClass, {\"book\",\"citation\"}) and not is_set(Periodical) then\t\t-- special cases for book cites\n\t\tif is_set (Contributors) then\t\t\t\t\t\t\t\t\t\t\t-- when we are citing foreword, preface, introduction, etc\n\t\t\ttcommon = safe_join( {Title, TitleNote}, sepc );\t\t\t\t\t-- author and other stuff will come after this and before tcommon2\n\t\t\ttcommon2 = safe_join( {Conference, Periodical, Format, TitleType, Series, Volume, Others, Edition, Publisher, Agency}, sepc );\n\t\telse\n\t\t\ttcommon = safe_join( {Title, TitleNote, Conference, Periodical, Format, TitleType, Series, Volume, Others, Edition, Publisher, Agency}, sepc );\n\t\tend\n\n\telseif 'map' == config.CitationClass then\t\t\t\t\t\t\t\t\t-- special cases for cite map\n\t\tif is_set (Chapter) then\t\t\t\t\t\t\t\t\t\t\t\t-- map in a book; TitleType is part of Chapter\n\t\t\ttcommon = safe_join( {Title, Format, Edition, Scale, Series, Cartography, Others, Publisher, Volume}, sepc );\n\t\telseif is_set (Periodical) then\t\t\t\t\t\t\t\t\t\t\t-- map in a periodical\n\t\t\ttcommon = safe_join( {Title, TitleType, Format, Periodical, Scale, Series, Cartography, Others, Publisher, Volume}, sepc );\n\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- a sheet or stand-alone map\n\t\t\ttcommon = safe_join( {Title, TitleType, Format, Edition, Scale, Series, Cartography, Others, Publisher}, sepc );\n\t\tend\n\t\t\n\telseif 'episode' == config.CitationClass then\t\t\t\t\t\t\t\t-- special case for cite episode\n\t\ttcommon = safe_join( {Title, TitleNote, TitleType, Series, Transcript, Edition, Publisher}, sepc );\n\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- all other CS1 templates\n\t\ttcommon = safe_join( {Title, TitleNote, Conference, Periodical, Format, TitleType, Series, \n\t\t\tVolume, Others, Edition, Publisher, Agency}, sepc );\n\tend\n\t\n\tif #ID_list > 0 then\n\t\tID_list = safe_join( { sepc .. \" \",  table.concat( ID_list, sepc .. \" \" ), ID }, sepc );\n\telse\n\t\tID_list = ID;\n\tend\n\t\n\t-- LOCAL\n\tlocal xDate = Date\n\tlocal pgtext = Position .. Sheet .. Sheets .. Page .. Pages .. At;\n\tif ( is_set(Periodical) and Date ~= '' and\n\t\tnot in_array(config.CitationClass, {\"encyclopaedia\",\"web\"}) )\n\t\tor ( in_array(config.CitationClass, {\"book\",\"news\"}) ) then\n\t\tif in_array(config.CitationClass, {\"journal\",\"citation\"}) and ( Volume ~= '' or Issue ~= '' ) then\n\t\t\txDate = xDate .. ',' .. Volume\n\t\tend\n\t\txDate = xDate .. pgtext\n\t\tpgtext = ''\n\tend\n\tif PublicationDate and PublicationDate ~= '' then\n\t\txDate = xDate .. ' (' .. PublicationDate .. ')'\n\tend\n\tif OrigYear ~= '' then\n\t\txDate = xDate .. OrigYear\n\tend\n\tif AccessDate ~= '' then\n\t\txDate = xDate .. ' ' .. AccessDate\n\tend\n\tif xDate ~= '' then\n\t\txDate = sepc .. ' ' .. xDate\n\tend\n\t-- END LOCAL\n\t\n\tlocal idcommon = safe_join( { URL, xDate, ID_list, Archived, Via, SubscriptionRequired, Lay, Language, Quote }, sepc );\n\tlocal text;\n\n\tif is_set(Authors) then\n\t\tif is_set(Coauthors) then\n\t\t\tif 'vanc' == NameListFormat then\t\t\t\t\t\t\t\t\t-- separate authors and coauthors with proper name-list-separator\n\t\t\t\tAuthors = Authors .. ', ' .. Coauthors;\n\t\t\telse\n\t\t\t\tAuthors = Authors .. '; ' .. Coauthors;\n\t\t\tend\n\t\tend\n\t\tAuthors = terminate_name_list (Authors, sepc);\t\t\t\t\t\t-- when no date, terminate with 0 or 1 sepc and a space\n\t\tif is_set(Editors) then\n\t\t\tlocal in_text = \" \";\n\t\t\tlocal post_text = \"\";\n\t\t\tif is_set(Chapter) and 0 == #c then\n\t\t\t\tin_text = in_text .. cfg.messages['in'] .. \" \"\n\t\t\t\tif (sepc ~= '.') then in_text = in_text:lower() end\t\t\t\t-- lowercase for cs2\n\t\t\telse\n\t\t\t\tif EditorCount <= 1 then\n\t\t\t\t\tpost_text = \", \" .. cfg.messages['editor'];\n\t\t\t\telse\n\t\t\t\t\tpost_text = \", \" .. cfg.messages['editors'];\n\t\t\t\tend\n\t\t\tend \n\t\t\tEditors = terminate_name_list (in_text .. Editors .. post_text, sepc);\t-- terminate with 0 or 1 sepc and a space\n\t\tend\n\t\tif is_set (Contributors) then\t\t\t\t\t\t\t\t\t\t\t-- book cite and we're citing the intro, preface, etc\n\t\t\tlocal by_text = sepc .. ' ' .. cfg.messages['by'] .. ' ';\n\t\t\tif (sepc ~= '.') then by_text = by_text:lower() end\t\t\t\t\t-- lowercase for cs2\n\t\t\tAuthors = by_text .. Authors;\t\t\t\t\t\t\t\t\t\t-- author follows title so tweak it here\n\t\t\tif is_set (Editors) then\t\t\t\t\t\t\t\t\t\t\t-- when Editors make sure that Authors gets terminated\n\t\t\t\tAuthors = terminate_name_list (Authors, sepc);\t\t\t\t\t-- terminate with 0 or 1 sepc and a space\n\t\t\tend\n\t\t\tContributors = terminate_name_list (Contributors, sepc);\t\t-- terminate with 0 or 1 sepc and a space\n\t\t\ttext = safe_join( {Contributors, Chapter, tcommon, Authors, Place, Editors, tcommon2, pgtext, idcommon }, sepc );\n\t\telse\n\t\t\ttext = safe_join( {Authors, Chapter, Place, Editors, tcommon, pgtext, idcommon }, sepc );\n\t\tend\n\telseif is_set(Editors) then\n\t\tif EditorCount <= 1 then\n\t\t\tEditors = Editors .. \" (\" .. cfg.messages['editor'] .. \")\" .. sepc .. \" \"\n\t\telse\n\t\t\tEditors = Editors .. \" (\" .. cfg.messages['editors'] .. \")\" .. sepc .. \" \"\n\t\tend\n\t\ttext = safe_join( {Editors, Chapter, Place, tcommon, pgtext, idcommon}, sepc );\n\telse\n\t\tif config.CitationClass==\"journal\" and is_set(Periodical) then\n\t\t\ttext = safe_join( {Chapter, Place, tcommon, pgtext, idcommon}, sepc );\n\t\telse\n\t\t\ttext = safe_join( {Chapter, Place, tcommon, pgtext, idcommon}, sepc );\n\t\tend\n\tend\n\t\n\tif is_set(PostScript) and PostScript ~= sepc then\n\t\ttext = safe_join( {text, sepc}, sepc );  --Deals with italics, spaces, etc.\n\t\ttext = text:sub(1,-sepc:len()-1);\n\tend\t\n\t\n\ttext = safe_join( {text, PostScript}, sepc );\n\n\t-- Now enclose the whole thing in a <cite/> element\n\tlocal options = {};\n\t\n\tif is_set(config.CitationClass) and config.CitationClass ~= \"citation\" then\n\t\toptions.class = config.CitationClass;\n\t\toptions.class = \"citation \" .. config.CitationClass;\t\t\t\t\t-- class=citation required for blue highlight when used with |ref=\n\telse\n\t\toptions.class = \"citation\";\n\tend\n\t\n\tif is_set(Ref) and Ref:lower() ~= \"none\" then\t\t\t\t\t\t\t\t-- set reference anchor if appropriate\n\t\tlocal id = Ref\n\t\tif ('harv' == Ref ) then\n\t\t\tlocal namelist = {};\t\t\t\t\t\t\t\t\t\t\t\t-- holds selected contributor, author, editor name list\n--\t\t\tlocal year = first_set (Year, anchor_year);\t\t\t\t\t\t\t-- Year first for legacy citations and for YMD dates that require disambiguation\n\t\t\tlocal year = first_set ({Year, anchor_year}, 2);\t\t\t\t\t-- Year first for legacy citations and for YMD dates that require disambiguation\n\n\t\t\tif #c > 0 then\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- if there is a contributor list\n\t\t\t\tnamelist = c;\t\t\t\t\t\t\t\t\t\t\t\t\t-- select it\n\t\t\telseif #a > 0 then\t\t\t\t\t\t\t\t\t\t\t\t\t-- or an author list\n\t\t\t\tnamelist = a;\n\t\t\telseif #e > 0 then\t\t\t\t\t\t\t\t\t\t\t\t\t-- or an editor list\n\t\t\t\tnamelist = e;\n\t\t\tend\n\t\t\tid = anchor_id (namelist, year);\t\t\t\t\t\t\t\t\t-- go make the CITEREF anchor\n\t\tend\n\t\toptions.id = id;\n\tend\n\t\n\tif string.len(text:gsub(\"<span[^>/]*>.-</span>\", \"\"):gsub(\"%b<>\",\"\")) <= 2 then\n\t\tz.error_categories = {};\n\t\ttext = set_error('empty_citation');\n\t\tz.message_tail = {};\n\tend\n\t\n\tif is_set(options.id) then \n\t\ttext = '<cite id=\"' .. mw.uri.anchorEncode(options.id) ..'\" class=\"' .. mw.text.nowiki(options.class) .. '\">' .. text .. \"</cite>\";\n\telse\n\t\ttext = '<cite class=\"' .. mw.text.nowiki(options.class) .. '\">' .. text .. \"</cite>\";\n\tend\t\t\n\n\tlocal empty_span = '<span style=\"display:none;\">&nbsp;</span>';\n\t\n\t-- Note: Using display: none on the COinS span breaks some clients.\n\tlocal OCinS = '<span title=\"' .. OCinSoutput .. '\" class=\"Z3988\">' .. empty_span .. '</span>';\n\ttext = text .. OCinS;\n\t\n\tif #z.message_tail ~= 0 then\n\t\ttext = text .. \" \";\n\t\tfor i,v in ipairs( z.message_tail ) do\n\t\t\tif is_set(v[1]) then\n\t\t\t\tif i == #z.message_tail then\n\t\t\t\t\ttext = text .. error_comment( v[1], v[2] );\n\t\t\t\telse\n\t\t\t\t\ttext = text .. error_comment( v[1] .. \"; \", v[2] );\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tif #z.maintenance_cats ~= 0 then\n\t\ttext = text .. '<span class=\"citation-comment\" style=\"display:none; color:#33aa33\">';\n\t\tfor _, v in ipairs( z.maintenance_cats ) do\t\t\t\t\t\t\t\t-- append maintenance categories\n\t\t\ttext = text .. ' ' .. v .. ' ([[:Category:' .. v ..'|link]])';\n\t\tend\n\t\ttext = text .. '</span>';\t-- maintenance mesages (realy just the names of the categories for now)\n\tend\n\t\n\tno_tracking_cats = no_tracking_cats:lower();\n\tif in_array(no_tracking_cats, {\"\", \"no\", \"false\", \"n\"}) then\n\t\tfor _, v in ipairs( z.error_categories ) do\n\t\t\ttext = text .. '[[Category:' .. v ..']]';\n\t\tend\n\t\tfor _, v in ipairs( z.maintenance_cats ) do\t\t\t\t\t\t\t\t-- append maintenance categories\n\t\t\ttext = text .. '[[Category:' .. v ..']]';\n\t\tend\n\t\tfor _, v in ipairs( z.properties_cats ) do\t\t\t\t\t\t\t\t-- append maintenance categories\n\t\t\ttext = text .. '[[Category:' .. v ..']]';\n\t\tend\n\tend\n\t\n\treturn text\nend\n\n--[[--------------------------< H A S _ I N V I S I B L E _ C H A R S >----------------------------------------\n\nThis function searches a parameter's value for nonprintable or invisible characters.  The search stops at the first match.\n\nSometime after this module is done with rendering a citation, some C0 control characters are replaced with the\nreplacement character.  That replacement character is not detected by this test though it is visible to readers\nof the rendered citation.  This function will detect the replacement character when it is part of the wikisource.\n\nOutput of this function is an error message that identifies the character or the Unicode group that the character\nbelongs to along with its position in the parameter value.\n\n]]\n--[[\nlocal function has_invisible_chars (param, v)\n\tlocal position = '';\n\tlocal i=1;\n\n\twhile cfg.invisible_chars[i] do\n\t\tlocal char=cfg.invisible_chars[i][1]\t\t\t\t\t\t\t\t\t-- the character or group name\n\t\tlocal pattern=cfg.invisible_chars[i][2]\t\t\t\t\t\t\t\t\t-- the pattern used to find it\n\t\tv = mw.text.unstripNoWiki( v );\t\t\t\t\t\t\t\t\t\t\t-- remove nowiki stripmarkers\n\t\tposition = mw.ustring.find (v, pattern)\t\t\t\t\t\t\t\t\t-- see if the parameter value contains characters that match the pattern\n\t\tif position then\n\t\t\ttable.insert( z.message_tail, { set_error( 'invisible_char', {char, wrap_style ('parameter', param), position}, true ) } );\t-- add error message\n\t\t\treturn;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- and done with this parameter\n\t\tend\n\t\ti=i+1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- bump our index\n\tend\nend\n]]\n\n--[[--------------------------< Z . C I T A T I O N >----------------------------------------------------------\n\nThis is used by templates such as {{cite book}} to create the actual citation text.\n\n]]\n\nfunction z.citation(frame)\n\tlocal pframe = frame:getParent()\n\tlocal validation;\n\t\n\tif nil ~= string.find (frame:getTitle(), 'sandbox', 1, true) then\t\t\t-- did the {{#invoke:}} use sandbox version?\n\t\tcfg = mw.loadData ('Module:Citation/CS1/Configuration/sandbox');\t\t-- load sandbox versions of Configuration and Whitelist and ...\n\t\twhitelist = mw.loadData ('Module:Citation/CS1/Whitelist/sandbox');\n\t\tvalidation = require ('Module:Citation/CS1/Date_validation/sandbox');\t-- ... sandbox version of date validation code\n\n\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- otherwise\n\t\tcfg = mw.loadData ('Module:Citation/CS1/Configuration');\t\t\t\t-- load live versions of Configuration and Whitelist and ...\n\t\twhitelist = mw.loadData ('Module:Citation/CS1/Whitelist');\n\t\tvalidation = require ('Module:Citation/CS1/Date_validation');\t\t\t-- ... live version of date validation code\n\tend\n\n\tdates = validation.dates;\t\t\t\t\t\t\t\t\t\t\t\t\t-- imported functions\n\tyear_date_check = validation.year_date_check;\n\n\tlocal args = {};\n\tlocal suggestions = {};\n\tlocal error_text, error_state;\n\n\tlocal config = {};\n\tfor k, v in pairs( frame.args ) do\n\t\tconfig[k] = v;\n\t\targs[k] = v;\t   \n\tend\t\n\n\tlocal capture;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-- the single supported capture when matching unknown parameters using patterns\n\tfor k, v in pairs( pframe.args ) do\n\t\tif v ~= '' then\n\t\t\tif not validate( k ) then\t\t\t\n\t\t\t\terror_text = \"\";\n\t\t\t\tif type( k ) ~= 'string' then\n\t\t\t\t\t-- Exclude empty numbered parameters\n\t\t\t\t\tif v:match(\"%S+\") ~= nil then\n\t\t\t\t\t\terror_text, error_state = set_error( 'text_ignored', {v}, true );\n\t\t\t\t\tend\n\t\t\t\telseif validate( k:lower() ) then \n\t\t\t\t\terror_text, error_state = set_error( 'parameter_ignored_suggest', {k, k:lower()}, true );\n\t\t\t\telse\n\t\t\t\t\tif nil == suggestions.suggestions then\t\t\t\t\t\t-- if this table is nil then we need to load it\n\t\t\t\t\t\tif nil ~= string.find (frame:getTitle(), 'sandbox', 1, true) then\t\t\t-- did the {{#invoke:}} use sandbox version?\n\t\t\t\t\t\t\tsuggestions = mw.loadData( 'Module:Citation/CS1/Suggestions/sandbox' );\t-- use the sandbox version\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsuggestions = mw.loadData( 'Module:Citation/CS1/Suggestions' );\t\t\t-- use the live version\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tfor pattern, param in pairs (suggestions.patterns) do\t\t-- loop through the patterns to see if we can suggest a proper parameter\n\t\t\t\t\t\tcapture = k:match (pattern);\t\t\t\t\t\t\t-- the whole match if no caputre in pattern else the capture if a match\n\t\t\t\t\t\tif capture then\t\t\t\t\t\t\t\t\t\t\t-- if the pattern matches \n\t\t\t\t\t\t\tparam = substitute( param, capture );\t\t\t\t-- add the capture to the suggested parameter (typically the enumerator)\n\t\t\t\t\t\t\terror_text, error_state = set_error( 'parameter_ignored_suggest', {k, param}, true );\t-- set the error message\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tif not is_set (error_text) then\t\t\t\t\t\t\t\t-- couldn't match with a pattern, is there an expicit suggestion?\n\t\t\t\t\t\tif suggestions.suggestions[ k:lower() ] ~= nil then\n\t\t\t\t\t\t\terror_text, error_state = set_error( 'parameter_ignored_suggest', {k, suggestions.suggestions[ k:lower() ]}, true );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\terror_text, error_state = set_error( 'parameter_ignored', {k}, true );\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\t\t\t\t  \n\t\t\t\tif error_text ~= '' then\n\t\t\t\t\ttable.insert( z.message_tail, {error_text, error_state} );\n\t\t\t\tend\t\t\t\t\n\t\t\tend\n\t\t\targs[k] = v;\n\t\telseif args[k] ~= nil or (k == 'postscript') then\n\t\t\targs[k] = v;\n\t\tend\t\t\n\tend\t\n\n\tfor k, v in pairs( args ) do\n\t\tif 'string' == type (k) then\t\t\t\t\t\t\t\t\t\t\t-- don't evaluate positional parameters\n\t\t\thas_invisible_chars (k, v);\n\t\tend\n\tend\n\treturn citation0( config, args)\nend\n\nreturn z"}}}